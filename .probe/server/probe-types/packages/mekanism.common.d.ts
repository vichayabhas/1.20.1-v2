declare module "packages/mekanism/common/capabilities/chemical/dynamic/$IGasTracker" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export interface $IGasTracker extends $IContentsListener {

 "getGasTanks"(side: $Direction$Type): $List<($IGasTank)>
 "onContentsChanged"(): void
}

export namespace $IGasTracker {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGasTracker$Type = ($IGasTracker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGasTracker_ = $IGasTracker$Type;
}}
declare module "packages/mekanism/common/tile/base/$WrenchResult" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $WrenchResult extends $Enum<($WrenchResult)> {
static readonly "DISMANTLED": $WrenchResult
static readonly "SUCCESS": $WrenchResult
static readonly "PASS": $WrenchResult
static readonly "NO_SECURITY": $WrenchResult


public static "values"(): ($WrenchResult)[]
public static "valueOf"(name: string): $WrenchResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrenchResult$Type = (("pass") | ("success") | ("dismantled") | ("no_security")) | ($WrenchResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrenchResult_ = $WrenchResult$Type;
}}
declare module "packages/mekanism/common/tile/base/$TileEntityMekanism" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ListTag, $ListTag$Type} from "packages/net/minecraft/nbt/$ListTag"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFrequencyHandler, $IFrequencyHandler$Type} from "packages/mekanism/common/lib/frequency/$IFrequencyHandler"
import {$ITileComponent, $ITileComponent$Type} from "packages/mekanism/common/tile/component/$ITileComponent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ITierUpgradable, $ITierUpgradable$Type} from "packages/mekanism/common/tile/interfaces/$ITierUpgradable"
import {$SoundSource, $SoundSource$Type} from "packages/net/minecraft/sounds/$SoundSource"
import {$BoundMethodHolder, $BoundMethodHolder$Type} from "packages/mekanism/common/integration/computer/$BoundMethodHolder"
import {$ITrackableContainer, $ITrackableContainer$Type} from "packages/mekanism/common/inventory/container/$ITrackableContainer"
import {$FrequencyType, $FrequencyType$Type} from "packages/mekanism/common/lib/frequency/$FrequencyType"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IHeatCapacitor, $IHeatCapacitor$Type} from "packages/mekanism/api/heat/$IHeatCapacitor"
import {$ITileActive, $ITileActive$Type} from "packages/mekanism/common/tile/interfaces/$ITileActive"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Slurry, $Slurry$Type} from "packages/mekanism/api/chemical/slurry/$Slurry"
import {$IMekanismFluidHandler, $IMekanismFluidHandler$Type} from "packages/mekanism/api/fluid/$IMekanismFluidHandler"
import {$IHeatHandler, $IHeatHandler$Type} from "packages/mekanism/api/heat/$IHeatHandler"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$WrenchResult, $WrenchResult$Type} from "packages/mekanism/common/tile/base/$WrenchResult"
import {$IInfusionTank, $IInfusionTank$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionTank"
import {$ISecurityTile, $ISecurityTile$Type} from "packages/mekanism/common/lib/security/$ISecurityTile"
import {$ITileDirectional, $ITileDirectional$Type} from "packages/mekanism/common/tile/interfaces/$ITileDirectional"
import {$IUpgradeData, $IUpgradeData$Type} from "packages/mekanism/common/upgrade/$IUpgradeData"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$ITileRedstone, $ITileRedstone$Type} from "packages/mekanism/common/tile/interfaces/$ITileRedstone"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IInfusionTile, $IInfusionTile$Type} from "packages/mekanism/common/tile/interfaces/chemical/$IInfusionTile"
import {$HeatAPI$HeatTransfer, $HeatAPI$HeatTransfer$Type} from "packages/mekanism/api/heat/$HeatAPI$HeatTransfer"
import {$ISustainedInventory, $ISustainedInventory$Type} from "packages/mekanism/common/tile/interfaces/$ISustainedInventory"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$CapabilityTileEntity, $CapabilityTileEntity$Type} from "packages/mekanism/common/tile/base/$CapabilityTileEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$ISlurryTank, $ISlurryTank$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryTank"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$IMekanismStrictEnergyHandler, $IMekanismStrictEnergyHandler$Type} from "packages/mekanism/api/energy/$IMekanismStrictEnergyHandler"
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$ITileRadioactive, $ITileRadioactive$Type} from "packages/mekanism/common/tile/interfaces/$ITileRadioactive"
import {$SlurryStack, $SlurryStack$Type} from "packages/mekanism/api/chemical/slurry/$SlurryStack"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$Pigment, $Pigment$Type} from "packages/mekanism/api/chemical/pigment/$Pigment"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$IChemicalTankHolder, $IChemicalTankHolder$Type} from "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IMekanismInventory, $IMekanismInventory$Type} from "packages/mekanism/api/inventory/$IMekanismInventory"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$Type} from "packages/mekanism/common/lib/frequency/$Frequency$FrequencyIdentity"
import {$TileComponentFrequency, $TileComponentFrequency$Type} from "packages/mekanism/common/lib/frequency/$TileComponentFrequency"
import {$InfuseType, $InfuseType$Type} from "packages/mekanism/api/chemical/infuse/$InfuseType"
import {$SubstanceType, $SubstanceType$Type} from "packages/mekanism/common/tile/base/$SubstanceType"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IConfigCardAccess, $IConfigCardAccess$Type} from "packages/mekanism/api/$IConfigCardAccess"
import {$TileComponentUpgrade, $TileComponentUpgrade$Type} from "packages/mekanism/common/tile/component/$TileComponentUpgrade"
import {$ChemicalHandlerManager$InfusionHandlerManager, $ChemicalHandlerManager$InfusionHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager$InfusionHandlerManager"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$IComparatorSupport, $IComparatorSupport$Type} from "packages/mekanism/common/tile/interfaces/$IComparatorSupport"
import {$IEnergyContainer, $IEnergyContainer$Type} from "packages/mekanism/api/energy/$IEnergyContainer"
import {$IPigmentTank, $IPigmentTank$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentTank"
import {$IGasTile, $IGasTile$Type} from "packages/mekanism/common/tile/interfaces/chemical/$IGasTile"
import {$IPigmentTile, $IPigmentTile$Type} from "packages/mekanism/common/tile/interfaces/chemical/$IPigmentTile"
import {$IComputerTile, $IComputerTile$Type} from "packages/mekanism/common/integration/computer/$IComputerTile"
import {$IRedstoneControl$RedstoneControl, $IRedstoneControl$RedstoneControl$Type} from "packages/mekanism/common/tile/interfaces/$IRedstoneControl$RedstoneControl"
import {$TileComponentSecurity, $TileComponentSecurity$Type} from "packages/mekanism/common/tile/component/$TileComponentSecurity"
import {$Gas, $Gas$Type} from "packages/mekanism/api/chemical/gas/$Gas"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$ChemicalHandlerManager$SlurryHandlerManager, $ChemicalHandlerManager$SlurryHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager$SlurryHandlerManager"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$PigmentStack, $PigmentStack$Type} from "packages/mekanism/api/chemical/pigment/$PigmentStack"
import {$IExtendedFluidTank, $IExtendedFluidTank$Type} from "packages/mekanism/api/fluid/$IExtendedFluidTank"
import {$ISlurryTile, $ISlurryTile$Type} from "packages/mekanism/common/tile/interfaces/chemical/$ISlurryTile"
import {$SecurityMode, $SecurityMode$Type} from "packages/mekanism/api/security/$SecurityMode"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$ITileSound, $ITileSound$Type} from "packages/mekanism/common/tile/interfaces/$ITileSound"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ChemicalHandlerManager$PigmentHandlerManager, $ChemicalHandlerManager$PigmentHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager$PigmentHandlerManager"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$ITileUpgradable, $ITileUpgradable$Type} from "packages/mekanism/common/tile/interfaces/$ITileUpgradable"
import {$ChemicalHandlerManager$GasHandlerManager, $ChemicalHandlerManager$GasHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager$GasHandlerManager"
import {$ITileHeatHandler, $ITileHeatHandler$Type} from "packages/mekanism/common/capabilities/heat/$ITileHeatHandler"
import {$Upgrade, $Upgrade$Type} from "packages/mekanism/api/$Upgrade"
import {$InfusionStack, $InfusionStack$Type} from "packages/mekanism/api/chemical/infuse/$InfusionStack"
import {$Nameable, $Nameable$Type} from "packages/net/minecraft/world/$Nameable"

export class $TileEntityMekanism extends $CapabilityTileEntity implements $IFrequencyHandler, $ITileDirectional, $IConfigCardAccess, $ITileActive, $ITileSound, $ITileRedstone, $ISecurityTile, $IMekanismInventory, $ISustainedInventory, $ITileUpgradable, $ITierUpgradable, $IComparatorSupport, $ITrackableContainer, $IMekanismFluidHandler, $IMekanismStrictEnergyHandler, $ITileHeatHandler, $IGasTile, $IInfusionTile, $IPigmentTile, $ISlurryTile, $IComputerTile, $ITileRadioactive, $Nameable {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "close"(player: $Player$Type): void
public "open"(player: $Player$Type): void
public "handles"(type: $SubstanceType$Type): boolean
public "onNeighborChange"(block: $Block$Type, neighborPos: $BlockPos$Type): void
public "canHandleHeat"(): boolean
public "setActive"(active: boolean): void
public "load"(nbt: $CompoundTag$Type): void
public "m_183515_"(nbtTags: $CompoundTag$Type): void
public "setRemoved"(): void
/**
 * 
 * @deprecated
 */
public "setBlockState"(newState: $BlockState$Type): void
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "onContentsChanged"(): void
public "getFrequencyComponent"(): $TileComponentFrequency
public "getBlockTypeRegistryName"(): $ResourceLocation
public "shouldDumpRadiation"(): boolean
public "recalculateUpgrades"(upgrade: $Upgrade$Type): void
public "getSupportedUpgrade"(): $Set<($Upgrade)>
public "addContainerTrackers"(container: $MekanismContainer$Type): void
public "getSustainedInventory"(): $ListTag
public "setSustainedInventory"(nbtTags: $ListTag$Type): void
public "getConfigurationData"(player: $Player$Type): $CompoundTag
public "validateSecurityIsPublic"(): void
public "configurationDataSet"(): void
public "getConfigurationDataType"(): $BlockEntityType<(any)>
public "setConfigurationData"(player: $Player$Type, data: $CompoundTag$Type): void
public "isActivatable"(): boolean
public "getDirection"(): $Direction
public "setFacing"(direction: $Direction$Type): void
public "supportsRedstone"(): boolean
public "getControlType"(): $IRedstoneControl$RedstoneControl
public "supportsUpgrades"(): boolean
public "getComponents"(): $List<($ITileComponent)>
public "addComponent"(component: $ITileComponent$Type): void
public "getComponent"(): $TileComponentUpgrade
public "updatePower"(): void
public "openGui"(player: $Player$Type): $InteractionResult
public "getBlockType"(): $Block
public "isPowered"(): boolean
public "wasPowered"(): boolean
public "setCustomName"(name: $Component$Type): void
public static "tickClient"(level: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, tile: $TileEntityMekanism$Type): void
public "getRedstoneLevel"(): integer
public static "tickServer"(level: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, tile: $TileEntityMekanism$Type): void
public "getEnergyContainers"(side: $Direction$Type): $List<($IEnergyContainer)>
public "getAmbientTemperature"(side: $Direction$Type): double
public "getCurrentRedstoneLevel"(): integer
public "markDirtyComparator"(): void
public "blockRemoved"(): void
public "canBeUpgraded"(): boolean
public "hasSecurity"(): boolean
public "supportsComparator"(): boolean
public "hasGui"(): boolean
public "isDirectional"(): boolean
public "hasSound"(): boolean
public "hasComputerSupport"(): boolean
public "persists"(type: $SubstanceType$Type): boolean
public "tryWrench"(state: $BlockState$Type, player: $Player$Type, hand: $InteractionHand$Type, rayTrace: $BlockHitResult$Type): $WrenchResult
public "isNameable"(): boolean
public "persistInventory"(): boolean
public "parseUpgradeData"(data: $IUpgradeData$Type): void
public "getGasManager"(): $ChemicalHandlerManager$GasHandlerManager
public "setControlType"(type: $IRedstoneControl$RedstoneControl$Type): void
public "getInfusionManager"(): $ChemicalHandlerManager$InfusionHandlerManager
public "getConfigCardName"(): string
public "getInputRate"(): $FloatingLong
public "getSlurryManager"(): $ChemicalHandlerManager$SlurryHandlerManager
public "getSecurity"(): $TileComponentSecurity
public "getRadiationScale"(): float
public "getPigmentManager"(): $ChemicalHandlerManager$PigmentHandlerManager
public "onSecurityChanged"(old: $SecurityMode$Type, mode: $SecurityMode$Type): void
public "getComputerMethods"(holder: $BoundMethodHolder$Type): void
public "getActive"(): boolean
public "onAdded"(): void
public "getName"(): $Component
public "getReducedUpdateTag"(): $CompoundTag
public "getComputerName"(): string
public "getDisplayName"(): $Component
public "getCustomName"(): $Component
public "getInventorySlots"(side: $Direction$Type): $List<($IInventorySlot)>
public "getFluidTanks"(side: $Direction$Type): $List<($IExtendedFluidTank)>
public "getHeatCapacitors"(side: $Direction$Type): $List<($IHeatCapacitor)>
public "hasInventory"(): boolean
public "getAdjacent"(side: $Direction$Type): $IHeatHandler
public "canHandleEnergy"(): boolean
public "insertEnergy"(container: integer, amount: $FloatingLong$Type, side: $Direction$Type, action: $Action$Type): $FloatingLong
public "canHandleFluid"(): boolean
public "canHandlePigment"(): boolean
public "canHandleInfusion"(): boolean
public "canHandleGas"(): boolean
public "canHandleSlurry"(): boolean
public "getFrequency"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): FREQ
public "setFrequency"(type: $FrequencyType$Type<(any)>, data: $Frequency$FrequencyIdentity$Type, player: $UUID$Type): void
public "setFrequency"(type: $FrequencyType$Type<(any)>, frequencyCompound: $CompoundTag$Type): void
public "removeFrequency"(type: $FrequencyType$Type<(any)>, data: $Frequency$FrequencyIdentity$Type, player: $UUID$Type): void
public "getPublicCache"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): $List<(FREQ)>
public "getPrivateCache"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): $List<(FREQ)>
public "getOppositeDirection"(): $Direction
public "getLeftSide"(): $Direction
public "getRightSide"(): $Direction
public "isConfigurationDataCompatible"(arg0: $BlockEntityType$Type<(any)>): boolean
public "getSoundCategory"(): $SoundSource
public "getSoundPos"(): $BlockPos
public "getInitialVolume"(): float
public "getVolume"(): float
public "onPowerChange"(): void
public "canPulse"(): boolean
public "setSecurityMode"(mode: $SecurityMode$Type): void
public "setOwnerUUID"(owner: $UUID$Type): void
public "getSecurityMode"(): $SecurityMode
public "getOwnerName"(): string
public "getOwnerUUID"(): $UUID
public "getSlots"(arg0: $Direction$Type): integer
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: $Direction$Type, arg3: $Action$Type): $ItemStack
public "getStackInSlot"(arg0: integer, arg1: $Direction$Type): $ItemStack
public "getSlotLimit"(arg0: integer, arg1: $Direction$Type): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type, arg2: $Direction$Type): boolean
public "extractItem"(arg0: integer, arg1: integer, arg2: $Direction$Type, arg3: $Action$Type): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type, arg2: $Direction$Type): void
public "getInventorySlot"(arg0: integer, arg1: $Direction$Type): $IInventorySlot
public "isInventoryEmpty"(arg0: $Direction$Type): boolean
public "isInventoryEmpty"(): boolean
public "hasSustainedInventory"(): boolean
public "getInfo"(upgrade: $Upgrade$Type): $List<($Component)>
public "getUpgradeData"(): $IUpgradeData
public "getTanks"(arg0: $Direction$Type): integer
public "getTankCapacity"(arg0: integer, arg1: $Direction$Type): integer
public "getFluidInTank"(arg0: integer, arg1: $Direction$Type): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type): boolean
public "getFluidTank"(arg0: integer, arg1: $Direction$Type): $IExtendedFluidTank
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type): void
public "insertFluid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type, arg3: $Action$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Direction$Type, arg3: $Action$Type): $FluidStack
public "getEnergyContainer"(arg0: integer, arg1: $Direction$Type): $IEnergyContainer
public "getEnergyContainerCount"(arg0: $Direction$Type): integer
public "extractEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type, arg3: $Action$Type): $FloatingLong
public "getEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "setEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type): void
public "getMaxEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "getNeededEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "simulate"(): $HeatAPI$HeatTransfer
public "simulateEnvironment"(): double
public "updateHeatCapacitors"(side: $Direction$Type): void
public "incrementAdjacentTransfer"(currentAdjacentTransfer: double, tempToTransfer: double, side: $Direction$Type): double
public "simulateAdjacent"(): double
public "getInitialGasManager"(listener: $IContentsListener$Type): $ChemicalHandlerManager$GasHandlerManager
public "getInitialGasTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($Gas), ($GasStack), ($IGasTank)>
public "extractGasCheck"(tank: integer, side: $Direction$Type): boolean
public "insertGasCheck"(tank: integer, side: $Direction$Type): boolean
public "getGasTanks"(side: $Direction$Type): $List<($IGasTank)>
public "getInitialInfusionManager"(listener: $IContentsListener$Type): $ChemicalHandlerManager$InfusionHandlerManager
public "extractInfusionCheck"(tank: integer, side: $Direction$Type): boolean
public "insertInfusionCheck"(tank: integer, side: $Direction$Type): boolean
public "getInitialInfusionTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($InfuseType), ($InfusionStack), ($IInfusionTank)>
public "getInfusionTanks"(side: $Direction$Type): $List<($IInfusionTank)>
public "getInitialPigmentManager"(listener: $IContentsListener$Type): $ChemicalHandlerManager$PigmentHandlerManager
public "getInitialPigmentTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($Pigment), ($PigmentStack), ($IPigmentTank)>
public "extractPigmentCheck"(tank: integer, side: $Direction$Type): boolean
public "insertPigmentCheck"(tank: integer, side: $Direction$Type): boolean
public "getPigmentTanks"(side: $Direction$Type): $List<($IPigmentTank)>
public "getInitialSlurryManager"(listener: $IContentsListener$Type): $ChemicalHandlerManager$SlurryHandlerManager
public "getInitialSlurryTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($Slurry), ($SlurryStack), ($ISlurryTank)>
public "extractSlurryCheck"(tank: integer, side: $Direction$Type): boolean
public "insertSlurryCheck"(tank: integer, side: $Direction$Type): boolean
public "getSlurryTanks"(side: $Direction$Type): $List<($ISlurryTank)>
public "isComputerCapabilityPersistent"(): boolean
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getRadiationParticleCount"(): integer
public "hasCustomName"(): boolean
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
public "getSlots"(): integer
public "getInventorySideFor"(): $Direction
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "getStackInSlot"(arg0: integer): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type): void
public "supportsUpgrade"(upgradeType: $Upgrade$Type): boolean
public "getTanks"(): integer
public "getTankCapacity"(arg0: integer): integer
public "getFluidInTank"(arg0: integer): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$Type): void
public "insertFluid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Action$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$Type, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "getFluidSideFor"(): $Direction
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Action$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$Type, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "getEnergyContainerCount"(): integer
public "extractEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Action$Type): $FloatingLong
public "extractEnergy"(arg0: $FloatingLong$Type, arg1: $Direction$Type, arg2: $Action$Type): $FloatingLong
public "getEnergy"(arg0: integer): $FloatingLong
public "setEnergy"(arg0: integer, arg1: $FloatingLong$Type): void
public "getMaxEnergy"(arg0: integer): $FloatingLong
public "getNeededEnergy"(arg0: integer): $FloatingLong
public "insertEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Action$Type): $FloatingLong
public "insertEnergy"(arg0: $FloatingLong$Type, arg1: $Direction$Type, arg2: $Action$Type): $FloatingLong
public "getEnergySideFor"(): $Direction
public "getHeatCapacity"(arg0: integer, arg1: $Direction$Type): double
public "getHeatCapacitor"(arg0: integer, arg1: $Direction$Type): $IHeatCapacitor
public "handleHeat"(arg0: integer, arg1: double, arg2: $Direction$Type): void
public "getTemperature"(arg0: integer, arg1: $Direction$Type): double
public "getHeatCapacitorCount"(arg0: $Direction$Type): integer
public "getTotalInverseInsulation"(arg0: $Direction$Type): double
public "getInverseConduction"(arg0: integer, arg1: $Direction$Type): double
public "getInverseInsulation"(arg0: integer, arg1: $Direction$Type): double
public "ownerMatches"(arg0: $Player$Type): boolean
/**
 * 
 * @deprecated
 */
public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
/**
 * 
 * @deprecated
 */
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$Type, arg1: $Action$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Action$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$Type, arg1: $Action$Type): $FluidStack
public "extractEnergy"(arg0: $FloatingLong$Type, arg1: $Action$Type): $FloatingLong
public "insertEnergy"(arg0: $FloatingLong$Type, arg1: $Action$Type): $FloatingLong
public "getHeatCapacity"(arg0: integer): double
public "handleHeat"(arg0: double, arg1: $Direction$Type): void
public "handleHeat"(arg0: integer, arg1: double): void
public "getHeatSideFor"(): $Direction
public "getTotalInverseConductionCoefficient"(arg0: $Direction$Type): double
public "getTemperature"(arg0: integer): double
public "getTotalHeatCapacity"(arg0: $Direction$Type): double
public "getHeatCapacitorCount"(): integer
public "getInverseConduction"(arg0: integer): double
public "getTotalTemperature"(arg0: $Direction$Type): double
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "isMutable"(): boolean
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "getSlotLimit"(i: integer): integer
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "kjs$self"(): $IItemHandler
public "handleHeat"(arg0: double): void
public "getTotalHeatCapacity"(): double
public "getTotalInverseConduction"(): double
public "getTotalTemperature"(): double
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "asContainer"(): $Container
public "getWidth"(): integer
public "find"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "clear"(ingredient: $Ingredient$Type): void
public "clear"(): void
public "setChanged"(): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "getHeight"(): integer
set "active"(value: boolean)
set "blockState"(value: $BlockState$Type)
get "frequencyComponent"(): $TileComponentFrequency
get "blockTypeRegistryName"(): $ResourceLocation
get "supportedUpgrade"(): $Set<($Upgrade)>
get "sustainedInventory"(): $ListTag
set "sustainedInventory"(value: $ListTag$Type)
get "configurationDataType"(): $BlockEntityType<(any)>
get "activatable"(): boolean
get "direction"(): $Direction
set "facing"(value: $Direction$Type)
get "controlType"(): $IRedstoneControl$RedstoneControl
get "components"(): $List<($ITileComponent)>
get "component"(): $TileComponentUpgrade
get "blockType"(): $Block
get "powered"(): boolean
set "customName"(value: $Component$Type)
get "redstoneLevel"(): integer
get "currentRedstoneLevel"(): integer
get "directional"(): boolean
get "nameable"(): boolean
get "gasManager"(): $ChemicalHandlerManager$GasHandlerManager
set "controlType"(value: $IRedstoneControl$RedstoneControl$Type)
get "infusionManager"(): $ChemicalHandlerManager$InfusionHandlerManager
get "configCardName"(): string
get "inputRate"(): $FloatingLong
get "slurryManager"(): $ChemicalHandlerManager$SlurryHandlerManager
get "security"(): $TileComponentSecurity
get "radiationScale"(): float
get "pigmentManager"(): $ChemicalHandlerManager$PigmentHandlerManager
get "active"(): boolean
get "name"(): $Component
get "reducedUpdateTag"(): $CompoundTag
get "computerName"(): string
get "displayName"(): $Component
get "customName"(): $Component
get "oppositeDirection"(): $Direction
get "leftSide"(): $Direction
get "rightSide"(): $Direction
get "soundCategory"(): $SoundSource
get "soundPos"(): $BlockPos
get "initialVolume"(): float
get "volume"(): float
set "securityMode"(value: $SecurityMode$Type)
set "ownerUUID"(value: $UUID$Type)
get "securityMode"(): $SecurityMode
get "ownerName"(): string
get "ownerUUID"(): $UUID
get "inventoryEmpty"(): boolean
get "upgradeData"(): $IUpgradeData
get "computerCapabilityPersistent"(): boolean
get "radiationParticleCount"(): integer
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
get "slots"(): integer
get "inventorySideFor"(): $Direction
get "tanks"(): integer
get "fluidSideFor"(): $Direction
get "energyContainerCount"(): integer
get "energySideFor"(): $Direction
get "heatSideFor"(): $Direction
get "heatCapacitorCount"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "totalHeatCapacity"(): double
get "totalInverseConduction"(): double
get "totalTemperature"(): double
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityMekanism$Type = ($TileEntityMekanism);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityMekanism_ = $TileEntityMekanism$Type;
}}
declare module "packages/mekanism/common/content/blocktype/$Machine$FactoryMachine" {
import {$FactoryType, $FactoryType$Type} from "packages/mekanism/common/content/blocktype/$FactoryType"
import {$MekanismLang, $MekanismLang$Type} from "packages/mekanism/common/$MekanismLang"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$Machine, $Machine$Type} from "packages/mekanism/common/content/blocktype/$Machine"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $Machine$FactoryMachine<TILE extends $TileEntityMekanism> extends $Machine<(TILE)> {

constructor(tileEntitySupplier: $Supplier$Type<($TileEntityTypeRegistryObject$Type<(TILE)>)>, description: $MekanismLang$Type, factoryType: $FactoryType$Type)

public "getFactoryType"(): $FactoryType
get "factoryType"(): $FactoryType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Machine$FactoryMachine$Type<TILE> = ($Machine$FactoryMachine<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Machine$FactoryMachine_<TILE> = $Machine$FactoryMachine$Type<(TILE)>;
}}
declare module "packages/mekanism/common/item/$ItemUpgrade" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Upgrade, $Upgrade$Type} from "packages/mekanism/api/$Upgrade"
import {$IUpgradeItem, $IUpgradeItem$Type} from "packages/mekanism/common/item/interfaces/$IUpgradeItem"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemUpgrade extends $Item implements $IUpgradeItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(type: $Upgrade$Type, properties: $Item$Properties$Type)

public "getUpgradeType"(stack: $ItemStack$Type): $Upgrade
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemUpgrade$Type = ($ItemUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemUpgrade_ = $ItemUpgrade$Type;
}}
declare module "packages/mekanism/common/block/basic/$BlockResource" {
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockResourceInfo, $BlockResourceInfo$Type} from "packages/mekanism/common/resource/$BlockResourceInfo"
import {$BlockMekanism, $BlockMekanism$Type} from "packages/mekanism/common/block/$BlockMekanism"

export class $BlockResource extends $BlockMekanism {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(resource: $BlockResourceInfo$Type)

public "isPortalFrame"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type): boolean
public "getResourceInfo"(): $BlockResourceInfo
get "resourceInfo"(): $BlockResourceInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockResource$Type = ($BlockResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockResource_ = $BlockResource$Type;
}}
declare module "packages/mekanism/common/block/$BlockEnergyCube" {
import {$TileEntityEnergyCube, $TileEntityEnergyCube$Type} from "packages/mekanism/common/tile/$TileEntityEnergyCube"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$Type} from "packages/mekanism/common/block/prefab/$BlockTile$BlockTileModel"
import {$Machine, $Machine$Type} from "packages/mekanism/common/content/blocktype/$Machine"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PathComputationType, $PathComputationType$Type} from "packages/net/minecraft/world/level/pathfinder/$PathComputationType"

export class $BlockEnergyCube extends $BlockTile$BlockTileModel<($TileEntityEnergyCube), ($Machine<($TileEntityEnergyCube)>)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(type: $Machine$Type<($TileEntityEnergyCube$Type)>)

/**
 * 
 * @deprecated
 */
public "isPathfindable"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, pathType: $PathComputationType$Type): boolean
/**
 * 
 * @deprecated
 */
public "getShape"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEnergyCube$Type = ($BlockEnergyCube);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEnergyCube_ = $BlockEnergyCube$Type;
}}
declare module "packages/mekanism/common/content/qio/filter/$QIOFilter" {
import {$Finder, $Finder$Type} from "packages/mekanism/common/lib/inventory/$Finder"
import {$BaseFilter, $BaseFilter$Type} from "packages/mekanism/common/content/filter/$BaseFilter"

export class $QIOFilter<FILTER extends $QIOFilter<(FILTER)>> extends $BaseFilter<(FILTER)> {

constructor()

public "getFinder"(): $Finder
get "finder"(): $Finder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOFilter$Type<FILTER> = ($QIOFilter<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOFilter_<FILTER> = $QIOFilter$Type<(FILTER)>;
}}
declare module "packages/mekanism/common/content/qio/$QIOCraftingTransferHelper$SingularHashedItemSource" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"

export class $QIOCraftingTransferHelper$SingularHashedItemSource {

constructor(qioSource: $UUID$Type, used: integer)
constructor(slot: byte, used: integer)

public "getSlot"(): byte
public "setUsed"(used: integer): void
public "getUsed"(): integer
public "getQioSource"(): $UUID
get "slot"(): byte
set "used"(value: integer)
get "used"(): integer
get "qioSource"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOCraftingTransferHelper$SingularHashedItemSource$Type = ($QIOCraftingTransferHelper$SingularHashedItemSource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOCraftingTransferHelper$SingularHashedItemSource_ = $QIOCraftingTransferHelper$SingularHashedItemSource$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemFreeRunners" {
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CreativeModeTab$Output, $CreativeModeTab$Output$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$Output"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$ItemFreeRunners$FreeRunnerMode, $ItemFreeRunners$FreeRunnerMode$Type} from "packages/mekanism/common/item/gear/$ItemFreeRunners$FreeRunnerMode"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$Type} from "packages/mekanism/common/registration/impl/$CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemSpecialArmor, $ItemSpecialArmor$Type} from "packages/mekanism/common/item/gear/$ItemSpecialArmor"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$IModeItem, $IModeItem$Type} from "packages/mekanism/common/item/interfaces/$IModeItem"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$DispenseItemBehavior, $DispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DispenseItemBehavior"
import {$IItemHUDProvider, $IItemHUDProvider$Type} from "packages/mekanism/common/item/interfaces/$IItemHUDProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemFreeRunners extends $ItemSpecialArmor implements $IItemHUDProvider, $IModeItem, $CreativeTabDeferredRegister$ICustomCreativeTabContents {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)
constructor(material: $ArmorMaterial$Type, properties: $Item$Properties$Type)

public "setMode"(itemStack: $ItemStack$Type, mode: $ItemFreeRunners$FreeRunnerMode$Type): void
public "getMode"(itemStack: $ItemStack$Type): $ItemFreeRunners$FreeRunnerMode
public "addItems"(tabOutput: $CreativeModeTab$Output$Type): void
public "initializeClient"(consumer: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "canWalkOnPowderedSnow"(stack: $ItemStack$Type, wearer: $LivingEntity$Type): boolean
public "getDefaultTooltipHideFlags"(stack: $ItemStack$Type): integer
public "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public "isBarVisible"(stack: $ItemStack$Type): boolean
public "getBarWidth"(stack: $ItemStack$Type): integer
public "getBarColor"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "addHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): void
public "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
public "addCurioHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type): void
public static "displayModeChange"(player: $Player$Type): void
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
public "getScrollTextComponent"(stack: $ItemStack$Type): $Component
public "addDefault"(): boolean
public static "get"(arg0: $ItemStack$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFreeRunners$Type = ($ItemFreeRunners);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFreeRunners_ = $ItemFreeRunners$Type;
}}
declare module "packages/mekanism/common/tile/laser/$TileEntityBasicLaser" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$LaserEnergyContainer, $LaserEnergyContainer$Type} from "packages/mekanism/common/capabilities/energy/$LaserEnergyContainer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export class $TileEntityBasicLaser extends $TileEntityMekanism {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "getEnergyContainer"(): $LaserEnergyContainer
public "load"(nbt: $CompoundTag$Type): void
public "m_183515_"(nbtTags: $CompoundTag$Type): void
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "getReducedUpdateTag"(): $CompoundTag
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "energyContainer"(): $LaserEnergyContainer
get "reducedUpdateTag"(): $CompoundTag
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityBasicLaser$Type = ($TileEntityBasicLaser);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityBasicLaser_ = $TileEntityBasicLaser$Type;
}}
declare module "packages/mekanism/common/content/gear/$ModuleConfigItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ModuleConfigData, $ModuleConfigData$Type} from "packages/mekanism/api/gear/config/$ModuleConfigData"
import {$Module, $Module$Type} from "packages/mekanism/common/content/gear/$Module"
import {$IModuleDataProvider, $IModuleDataProvider$Type} from "packages/mekanism/api/providers/$IModuleDataProvider"
import {$ILangEntry, $ILangEntry$Type} from "packages/mekanism/api/text/$ILangEntry"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$IModuleConfigItem, $IModuleConfigItem$Type} from "packages/mekanism/api/gear/config/$IModuleConfigItem"

export class $ModuleConfigItem<TYPE> implements $IModuleConfigItem<(TYPE)> {

constructor(module: $Module$Type<(any)>, name: string, description: $ILangEntry$Type, data: $ModuleConfigData$Type<(TYPE)>)

public "getName"(): string
public "get"(): TYPE
public "matches"(moduleType: $IModuleDataProvider$Type<(any)>, name: string): boolean
public "set"(val: TYPE, callback: $Runnable$Type): void
public "set"(val: TYPE): void
public "write"(tag: $CompoundTag$Type): void
public "read"(tag: $CompoundTag$Type): void
public "getData"(): $ModuleConfigData<(TYPE)>
public "getDescription"(): $Component
get "name"(): string
get "data"(): $ModuleConfigData<(TYPE)>
get "description"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModuleConfigItem$Type<TYPE> = ($ModuleConfigItem<(TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModuleConfigItem_<TYPE> = $ModuleConfigItem$Type<(TYPE)>;
}}
declare module "packages/mekanism/common/tile/$TileEntityPersonalBarrel" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$TileEntityPersonalStorage, $TileEntityPersonalStorage$Type} from "packages/mekanism/common/tile/$TileEntityPersonalStorage"

export class $TileEntityPersonalBarrel extends $TileEntityPersonalStorage {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityPersonalBarrel$Type = ($TileEntityPersonalBarrel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityPersonalBarrel_ = $TileEntityPersonalBarrel$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$IInputRecipeCache" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IInputRecipeCache {

 "clear"(): void

(): void
}

export namespace $IInputRecipeCache {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInputRecipeCache$Type = ($IInputRecipeCache);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInputRecipeCache_ = $IInputRecipeCache$Type;
}}
declare module "packages/mekanism/common/lib/$SidedBlockPos" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$TransporterPathfinder$Destination, $TransporterPathfinder$Destination$Type} from "packages/mekanism/common/content/transporter/$TransporterPathfinder$Destination"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $SidedBlockPos extends $Record {

constructor(pos: $BlockPos$Type, side: $Direction$Type)

public static "get"(destination: $TransporterPathfinder$Destination$Type): $SidedBlockPos
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "pos"(): $BlockPos
public "side"(): $Direction
public static "deserialize"(tag: $CompoundTag$Type): $SidedBlockPos
public "serialize"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SidedBlockPos$Type = ($SidedBlockPos);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SidedBlockPos_ = $SidedBlockPos$Type;
}}
declare module "packages/mekanism/common/item/$ItemPortableQIODashboard" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$Type} from "packages/mekanism/common/lib/frequency/$Frequency$FrequencyIdentity"
import {$ListTag, $ListTag$Type} from "packages/net/minecraft/nbt/$ListTag"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$IGuiItem, $IGuiItem$Type} from "packages/mekanism/common/item/interfaces/$IGuiItem"
import {$IColoredItem, $IColoredItem$Type} from "packages/mekanism/common/item/interfaces/$IColoredItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$FrequencyType, $FrequencyType$Type} from "packages/mekanism/common/lib/frequency/$FrequencyType"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ContainerTypeRegistryObject, $ContainerTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$ContainerTypeRegistryObject"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IFrequencyItem, $IFrequencyItem$Type} from "packages/mekanism/common/lib/frequency/$IFrequencyItem"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$CapabilityItem, $CapabilityItem$Type} from "packages/mekanism/common/item/$CapabilityItem"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$IItemSustainedInventory, $IItemSustainedInventory$Type} from "packages/mekanism/common/item/interfaces/$IItemSustainedInventory"
import {$PortableQIODashboardContainer, $PortableQIODashboardContainer$Type} from "packages/mekanism/common/inventory/container/item/$PortableQIODashboardContainer"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemPortableQIODashboard extends $CapabilityItem implements $IFrequencyItem, $IGuiItem, $IItemSustainedInventory, $IColoredItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "setFrequency"(stack: $ItemStack$Type, frequency: $Frequency$Type): void
public "onDestroyed"(item: $ItemEntity$Type, damageSource: $DamageSource$Type): void
public "inventoryTick"(stack: $ItemStack$Type, level: $Level$Type, entity: $Entity$Type, slotId: integer, isSelected: boolean): void
public "use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "getFrequencyType"(): $FrequencyType<(any)>
public "getContainerType"(): $ContainerTypeRegistryObject<($PortableQIODashboardContainer)>
public "getFrequency"(stack: $ItemStack$Type): $Frequency
public "getFrequencyIdentity"(stack: $ItemStack$Type): $Frequency$FrequencyIdentity
public "hasFrequency"(stack: $ItemStack$Type): boolean
public "getSustainedInventory"(stack: $ItemStack$Type): $ListTag
public "getSustainedInventory"(): $ListTag
public "setSustainedInventory"(nbtTags: $ListTag$Type): void
public "setSustainedInventory"(nbtTags: $ListTag$Type, stack: $ItemStack$Type): void
public "getDroppedSlots"(stack: $ItemStack$Type): $List<($IInventorySlot)>
public "hasSustainedInventory"(stack: $ItemStack$Type): boolean
public "setColor"(stack: $ItemStack$Type, color: $EnumColor$Type): void
public "getColor"(stack: $ItemStack$Type): $EnumColor
public "hasSustainedInventory"(): boolean
public "canContentsDrop"(stack: $ItemStack$Type): boolean
get "frequencyType"(): $FrequencyType<(any)>
get "containerType"(): $ContainerTypeRegistryObject<($PortableQIODashboardContainer)>
get "sustainedInventory"(): $ListTag
set "sustainedInventory"(value: $ListTag$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPortableQIODashboard$Type = ($ItemPortableQIODashboard);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPortableQIODashboard_ = $ItemPortableQIODashboard$Type;
}}
declare module "packages/mekanism/common/tile/$TileEntityChemicalTank$GasMode" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IIncrementalEnum, $IIncrementalEnum$Type} from "packages/mekanism/api/$IIncrementalEnum"
import {$IHasTextComponent, $IHasTextComponent$Type} from "packages/mekanism/api/text/$IHasTextComponent"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export class $TileEntityChemicalTank$GasMode extends $Enum<($TileEntityChemicalTank$GasMode)> implements $IIncrementalEnum<($TileEntityChemicalTank$GasMode)>, $IHasTextComponent {
static readonly "IDLE": $TileEntityChemicalTank$GasMode
static readonly "DUMPING_EXCESS": $TileEntityChemicalTank$GasMode
static readonly "DUMPING": $TileEntityChemicalTank$GasMode


public static "values"(): ($TileEntityChemicalTank$GasMode)[]
public static "valueOf"(name: string): $TileEntityChemicalTank$GasMode
public "byIndex"(index: integer): $TileEntityChemicalTank$GasMode
public "getTextComponent"(): $Component
public static "byIndexStatic"(index: integer): $TileEntityChemicalTank$GasMode
public "ordinal"(): integer
public "adjust"(arg0: integer): $TileEntityChemicalTank$GasMode
public "adjust"(arg0: integer, arg1: $Predicate$Type<($TileEntityChemicalTank$GasMode$Type)>): $TileEntityChemicalTank$GasMode
public "getNext"(arg0: $Predicate$Type<($TileEntityChemicalTank$GasMode$Type)>): $TileEntityChemicalTank$GasMode
public "getNext"(): $TileEntityChemicalTank$GasMode
public "getPrevious"(): $TileEntityChemicalTank$GasMode
public "getPrevious"(arg0: $Predicate$Type<($TileEntityChemicalTank$GasMode$Type)>): $TileEntityChemicalTank$GasMode
get "textComponent"(): $Component
get "next"(): $TileEntityChemicalTank$GasMode
get "previous"(): $TileEntityChemicalTank$GasMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityChemicalTank$GasMode$Type = (("dumping") | ("idle") | ("dumping_excess")) | ($TileEntityChemicalTank$GasMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityChemicalTank$GasMode_ = $TileEntityChemicalTank$GasMode$Type;
}}
declare module "packages/mekanism/common/block/transmitter/$BlockSmallTransmitter" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$ConnectionType, $ConnectionType$Type} from "packages/mekanism/common/lib/transmitter/$ConnectionType"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockTransmitter, $BlockTransmitter$Type} from "packages/mekanism/common/block/transmitter/$BlockTransmitter"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"

export class $BlockSmallTransmitter extends $BlockTransmitter {
static readonly "CENTER": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties


public static "getSideForType"(type: $ConnectionType$Type, side: $Direction$Type): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockSmallTransmitter$Type = ($BlockSmallTransmitter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockSmallTransmitter_ = $BlockSmallTransmitter$Type;
}}
declare module "packages/mekanism/common/upgrade/$IUpgradeData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IUpgradeData {

}

export namespace $IUpgradeData {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IUpgradeData$Type = ($IUpgradeData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IUpgradeData_ = $IUpgradeData$Type;
}}
declare module "packages/mekanism/common/inventory/slot/chemical/$MergedChemicalInventorySlot" {
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$BasicInventorySlot, $BasicInventorySlot$Type} from "packages/mekanism/common/inventory/slot/$BasicInventorySlot"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$MergedChemicalTank, $MergedChemicalTank$Type} from "packages/mekanism/api/chemical/merged/$MergedChemicalTank"
import {$MergedTank$CurrentType, $MergedTank$CurrentType$Type} from "packages/mekanism/common/capabilities/merged/$MergedTank$CurrentType"

export class $MergedChemicalInventorySlot<MERGED extends $MergedChemicalTank> extends $BasicInventorySlot {
static readonly "alwaysTrue": $Predicate<($ItemStack)>
static readonly "alwaysFalse": $Predicate<($ItemStack)>
static readonly "alwaysTrueBi": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "DEFAULT_LIMIT": integer


public static "fill"(chemicalTank: $MergedChemicalTank$Type, listener: $IContentsListener$Type, x: integer, y: integer): $MergedChemicalInventorySlot<($MergedChemicalTank)>
public static "drain"(chemicalTank: $MergedChemicalTank$Type, listener: $IContentsListener$Type, x: integer, y: integer): $MergedChemicalInventorySlot<($MergedChemicalTank)>
public "drainChemicalTanks"(): void
public "fillChemicalTank"(type: $MergedTank$CurrentType$Type): void
public "drainChemicalTank"(type: $MergedTank$CurrentType$Type): void
public "fillChemicalTanks"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MergedChemicalInventorySlot$Type<MERGED> = ($MergedChemicalInventorySlot<(MERGED)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MergedChemicalInventorySlot_<MERGED> = $MergedChemicalInventorySlot$Type<(MERGED)>;
}}
declare module "packages/mekanism/common/item/block/$ItemBlockInductionCell" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemBlockTooltip, $ItemBlockTooltip$Type} from "packages/mekanism/common/item/block/$ItemBlockTooltip"
import {$InductionCellTier, $InductionCellTier$Type} from "packages/mekanism/common/tier/$InductionCellTier"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$BlockTile, $BlockTile$Type} from "packages/mekanism/common/block/prefab/$BlockTile"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$TileEntityInductionCell, $TileEntityInductionCell$Type} from "packages/mekanism/common/tile/multiblock/$TileEntityInductionCell"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockInductionCell extends $ItemBlockTooltip<($BlockTile<($TileEntityInductionCell), ($BlockTypeTile<($TileEntityInductionCell)>)>)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockTile$Type<($TileEntityInductionCell$Type), ($BlockTypeTile$Type<($TileEntityInductionCell$Type)>)>)

public "getTier"(): $InductionCellTier
get "tier"(): $InductionCellTier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockInductionCell$Type = ($ItemBlockInductionCell);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockInductionCell_ = $ItemBlockInductionCell$Type;
}}
declare module "packages/mekanism/common/lib/inventory/$TransitRequest" {
import {$TransitRequest$SimpleTransitRequest, $TransitRequest$SimpleTransitRequest$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest$SimpleTransitRequest"
import {$TransitRequest$ItemData, $TransitRequest$ItemData$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest$ItemData"
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest$TransitResponse"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Finder, $Finder$Type} from "packages/mekanism/common/lib/inventory/$Finder"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TransitRequest {

constructor()

public "isEmpty"(): boolean
public "addToInventory"(tile: $BlockEntity$Type, side: $Direction$Type, min: integer, force: boolean): $TransitRequest$TransitResponse
public static "definedItem"(tile: $BlockEntity$Type, side: $Direction$Type, amount: integer, finder: $Finder$Type): $TransitRequest
public static "definedItem"(tile: $BlockEntity$Type, side: $Direction$Type, min: integer, max: integer, finder: $Finder$Type): $TransitRequest
public static "simple"(stack: $ItemStack$Type): $TransitRequest$SimpleTransitRequest
public "getItemData"(): $Collection<(any)>
public static "anyItem"(tile: $BlockEntity$Type, side: $Direction$Type, amount: integer): $TransitRequest
public "getEmptyResponse"(): $TransitRequest$TransitResponse
public "createResponse"(inserted: $ItemStack$Type, data: $TransitRequest$ItemData$Type): $TransitRequest$TransitResponse
public "createSimpleResponse"(): $TransitRequest$TransitResponse
get "empty"(): boolean
get "itemData"(): $Collection<(any)>
get "emptyResponse"(): $TransitRequest$TransitResponse
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransitRequest$Type = ($TransitRequest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransitRequest_ = $TransitRequest$Type;
}}
declare module "packages/mekanism/common/lib/transmitter/$DynamicNetwork" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IHasTextComponent, $IHasTextComponent$Type} from "packages/mekanism/api/text/$IHasTextComponent"
import {$CompatibleTransmitterValidator, $CompatibleTransmitterValidator$Type} from "packages/mekanism/common/lib/transmitter/$CompatibleTransmitterValidator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$INetworkDataHandler, $INetworkDataHandler$Type} from "packages/mekanism/common/lib/transmitter/$INetworkDataHandler"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Transmitter, $Transmitter$Type} from "packages/mekanism/common/content/network/transmitter/$Transmitter"

export class $DynamicNetwork<ACCEPTOR, NETWORK extends $DynamicNetwork<(ACCEPTOR), (NETWORK), (TRANSMITTER)>, TRANSMITTER extends $Transmitter<(ACCEPTOR), (NETWORK), (TRANSMITTER)>> implements $INetworkDataHandler, $IHasTextComponent {


public "equals"(o: any): boolean
public "hashCode"(): integer
public "isEmpty"(): boolean
public "register"(): void
public "commit"(): void
public "invalidate"(triggerTransmitter: TRANSMITTER): void
public "adoptTransmittersAndAcceptorsFrom"(net: NETWORK): $List<(TRANSMITTER)>
public "getAcceptorDirections"(pos: $BlockPos$Type): $Set<($Direction)>
public "getTransmitterValidator"(): $CompatibleTransmitterValidator<(ACCEPTOR), (NETWORK), (TRANSMITTER)>
public "isRemote"(): boolean
public "onUpdate"(): void
public "getWorld"(): $Level
public "getTransmitters"(): $Set<(TRANSMITTER)>
public "deregister"(): void
public "addTransmitter"(transmitter: TRANSMITTER): void
public "transmittersSize"(): integer
public "removeTransmitter"(transmitter: TRANSMITTER): void
public "hasAcceptor"(acceptorPos: $BlockPos$Type): boolean
public "acceptorChanged"(transmitter: TRANSMITTER, side: $Direction$Type): void
public "addNewTransmitters"(newTransmitters: $Collection$Type<(TRANSMITTER)>, transmitterValidator: $CompatibleTransmitterValidator$Type<(ACCEPTOR), (NETWORK), (TRANSMITTER)>): void
public "getAcceptorCount"(): integer
public "getUUID"(): $UUID
public "getNetworkReaderCapacity"(): any
public "getFlowInfo"(): $Component
public "getStoredInfo"(): $Component
public "getNeededInfo"(): $Component
public "getTextComponent"(): $Component
get "empty"(): boolean
get "transmitterValidator"(): $CompatibleTransmitterValidator<(ACCEPTOR), (NETWORK), (TRANSMITTER)>
get "remote"(): boolean
get "world"(): $Level
get "transmitters"(): $Set<(TRANSMITTER)>
get "acceptorCount"(): integer
get "uUID"(): $UUID
get "networkReaderCapacity"(): any
get "flowInfo"(): $Component
get "storedInfo"(): $Component
get "neededInfo"(): $Component
get "textComponent"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicNetwork$Type<ACCEPTOR, NETWORK, TRANSMITTER> = ($DynamicNetwork<(ACCEPTOR), (NETWORK), (TRANSMITTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DynamicNetwork_<ACCEPTOR, NETWORK, TRANSMITTER> = $DynamicNetwork$Type<(ACCEPTOR), (NETWORK), (TRANSMITTER)>;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$EitherSideInputRecipeCache" {
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$AbstractInputRecipeCache, $AbstractInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$AbstractInputRecipeCache"
import {$InputIngredient, $InputIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$InputIngredient"
import {$IInputCache, $IInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$IInputCache"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"

export class $EitherSideInputRecipeCache<INPUT, INGREDIENT extends $InputIngredient<(INPUT)>, RECIPE extends ($MekanismRecipe) & ($BiPredicate<(INPUT), (INPUT)>), CACHE extends $IInputCache<(INPUT), (INGREDIENT), (RECIPE)>> extends $AbstractInputRecipeCache<(RECIPE)> {


public "clear"(): void
public "findFirstRecipe"(world: $Level$Type, inputA: INPUT, inputB: INPUT): RECIPE
public "containsInput"(world: $Level$Type, input: INPUT): boolean
public "containsInput"(world: $Level$Type, inputA: INPUT, inputB: INPUT): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EitherSideInputRecipeCache$Type<INPUT, INGREDIENT, RECIPE, CACHE> = ($EitherSideInputRecipeCache<(INPUT), (INGREDIENT), (RECIPE), (CACHE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EitherSideInputRecipeCache_<INPUT, INGREDIENT, RECIPE, CACHE> = $EitherSideInputRecipeCache$Type<(INPUT), (INGREDIENT), (RECIPE), (CACHE)>;
}}
declare module "packages/mekanism/common/inventory/container/slot/$ContainerSlotType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ContainerSlotType extends $Enum<($ContainerSlotType)> {
static readonly "IGNORED": $ContainerSlotType
static readonly "NORMAL": $ContainerSlotType
static readonly "POWER": $ContainerSlotType
static readonly "INPUT": $ContainerSlotType
static readonly "EXTRA": $ContainerSlotType
static readonly "OUTPUT": $ContainerSlotType
static readonly "VALIDITY": $ContainerSlotType


public static "values"(): ($ContainerSlotType)[]
public static "valueOf"(name: string): $ContainerSlotType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerSlotType$Type = (("output") | ("ignored") | ("normal") | ("input") | ("extra") | ("power") | ("validity")) | ($ContainerSlotType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContainerSlotType_ = $ContainerSlotType$Type;
}}
declare module "packages/mekanism/common/registration/impl/$FluidDeferredRegister$MekanismFluidType" {
import {$FluidDeferredRegister$FluidTypeRenderProperties, $FluidDeferredRegister$FluidTypeRenderProperties$Type} from "packages/mekanism/common/registration/impl/$FluidDeferredRegister$FluidTypeRenderProperties"
import {$Lazy, $Lazy$Type} from "packages/net/minecraftforge/common/util/$Lazy"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FluidType$Properties, $FluidType$Properties$Type} from "packages/net/minecraftforge/fluids/$FluidType$Properties"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IClientFluidTypeExtensions, $IClientFluidTypeExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientFluidTypeExtensions"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FluidType, $FluidType$Type} from "packages/net/minecraftforge/fluids/$FluidType"

export class $FluidDeferredRegister$MekanismFluidType extends $FluidType {
readonly "stillTexture": $ResourceLocation
readonly "flowingTexture": $ResourceLocation
readonly "overlayTexture": $ResourceLocation
readonly "renderOverlayTexture": $ResourceLocation
static readonly "BUCKET_VOLUME": integer
static readonly "SIZE": $Lazy<(integer)>

constructor(properties: $FluidType$Properties$Type, renderProperties: $FluidDeferredRegister$FluidTypeRenderProperties$Type)

public "initializeClient"(consumer: $Consumer$Type<($IClientFluidTypeExtensions$Type)>): void
public "isVaporizedOnPlacement"(level: $Level$Type, pos: $BlockPos$Type, stack: $FluidStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidDeferredRegister$MekanismFluidType$Type = ($FluidDeferredRegister$MekanismFluidType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidDeferredRegister$MekanismFluidType_ = $FluidDeferredRegister$MekanismFluidType$Type;
}}
declare module "packages/mekanism/common/block/transmitter/$BlockLogisticalTransporter" {
import {$TileEntityLogisticalTransporterBase, $TileEntityLogisticalTransporterBase$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityLogisticalTransporterBase"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$ITypeBlock, $ITypeBlock$Type} from "packages/mekanism/common/block/interfaces/$ITypeBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockType, $BlockType$Type} from "packages/mekanism/common/content/blocktype/$BlockType"
import {$IHasTileEntity, $IHasTileEntity$Type} from "packages/mekanism/common/block/interfaces/$IHasTileEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$TileEntityLogisticalTransporter, $TileEntityLogisticalTransporter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityLogisticalTransporter"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockLargeTransmitter, $BlockLargeTransmitter$Type} from "packages/mekanism/common/block/transmitter/$BlockLargeTransmitter"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$TransporterTier, $TransporterTier$Type} from "packages/mekanism/common/tier/$TransporterTier"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export class $BlockLogisticalTransporter extends $BlockLargeTransmitter implements $IHasTileEntity<($TileEntityLogisticalTransporterBase)>, $ITypeBlock {
static readonly "CENTER": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(tier: $TransporterTier$Type)

public "getType"(): $BlockType
public "getTileType"(): $TileEntityTypeRegistryObject<($TileEntityLogisticalTransporter)>
public "createDummyBlockEntity"(state: $BlockState$Type): $TileEntityLogisticalTransporterBase
public "createDummyBlockEntity"(): $TileEntityLogisticalTransporterBase
public "triggerBlockEntityEvent"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, id: integer, param: integer): boolean
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $TileEntityLogisticalTransporterBase
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
get "type"(): $BlockType
get "tileType"(): $TileEntityTypeRegistryObject<($TileEntityLogisticalTransporter)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockLogisticalTransporter$Type = ($BlockLogisticalTransporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockLogisticalTransporter_ = $BlockLogisticalTransporter$Type;
}}
declare module "packages/mekanism/common/lib/security/$SecurityFrequency" {
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$SecurityMode, $SecurityMode$Type} from "packages/mekanism/api/security/$SecurityMode"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"

export class $SecurityFrequency extends $Frequency {
static readonly "SECURITY": string

constructor(uuid: $UUID$Type)
constructor()

public "write"(buffer: $FriendlyByteBuf$Type): void
public "write"(nbtTags: $CompoundTag$Type): void
public "isOverridden"(): boolean
public "setSecurityMode"(securityMode: $SecurityMode$Type): void
public "getSecurityMode"(): $SecurityMode
public "getTrustedUsernameCache"(): $List<(string)>
public "removeTrusted"(index: integer): $UUID
public "setOverridden"(override: boolean): void
public "addTrusted"(uuid: $UUID$Type, name: string): void
public "getSyncHash"(): integer
public "getTrustedUUIDs"(): $List<($UUID)>
get "overridden"(): boolean
set "securityMode"(value: $SecurityMode$Type)
get "securityMode"(): $SecurityMode
get "trustedUsernameCache"(): $List<(string)>
set "overridden"(value: boolean)
get "syncHash"(): integer
get "trustedUUIDs"(): $List<($UUID)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SecurityFrequency$Type = ($SecurityFrequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SecurityFrequency_ = $SecurityFrequency$Type;
}}
declare module "packages/mekanism/common/inventory/container/$QIOItemViewerContainer" {
import {$QIOItemViewerContainer$SortDirection, $QIOItemViewerContainer$SortDirection$Type} from "packages/mekanism/common/inventory/container/$QIOItemViewerContainer$SortDirection"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$QIOItemViewerContainer$ListSortType, $QIOItemViewerContainer$ListSortType$Type} from "packages/mekanism/common/inventory/container/$QIOItemViewerContainer$ListSortType"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ContainerListener, $ContainerListener$Type} from "packages/net/minecraft/world/inventory/$ContainerListener"
import {$QIOFrequency, $QIOFrequency$Type} from "packages/mekanism/common/content/qio/$QIOFrequency"
import {$VirtualInventoryContainerSlot, $VirtualInventoryContainerSlot$Type} from "packages/mekanism/common/inventory/container/slot/$VirtualInventoryContainerSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$QIOCraftingWindow, $QIOCraftingWindow$Type} from "packages/mekanism/common/content/qio/$QIOCraftingWindow"
import {$QIOCraftingTransferHelper, $QIOCraftingTransferHelper$Type} from "packages/mekanism/common/content/qio/$QIOCraftingTransferHelper"
import {$ISlotClickHandler$IScrollableSlot, $ISlotClickHandler$IScrollableSlot$Type} from "packages/mekanism/common/inventory/$ISlotClickHandler$IScrollableSlot"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$HashedItem$UUIDAwareHashedItem, $HashedItem$UUIDAwareHashedItem$Type} from "packages/mekanism/common/lib/inventory/$HashedItem$UUIDAwareHashedItem"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Object2LongMap, $Object2LongMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongMap"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ISlotClickHandler, $ISlotClickHandler$Type} from "packages/mekanism/common/inventory/$ISlotClickHandler"

export class $QIOItemViewerContainer extends $MekanismContainer implements $ISlotClickHandler {
static readonly "SLOTS_X_MIN": integer
static readonly "SLOTS_X_MAX": integer
static readonly "SLOTS_Y_MIN": integer
static readonly "SLOTS_Y_MAX": integer
static readonly "SLOTS_START_Y": integer
static readonly "BASE_Y_OFFSET": integer
static readonly "TRANSPORTER_CONFIG_WINDOW": integer
static readonly "SIDE_CONFIG_WINDOW": integer
static readonly "UPGRADE_WINDOW": integer
static readonly "SKIN_SELECT_WINDOW": integer
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
 "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
 "remoteSlots": $NonNullList<($ItemStack)>
 "stateId": integer
 "containerId": integer
readonly "containerListeners": $List<($ContainerListener)>


public "quickMoveStack"(player: $Player$Type, slotID: integer): $ItemStack
public "recreate"(): $QIOItemViewerContainer
public "getFrequency"(): $QIOFrequency
public "getSelectedCraftingGrid"(player: $UUID$Type): byte
public "getSelectedCraftingGrid"(): byte
public "getCraftingWindowSlot"(tableIndex: byte, slotIndex: integer): $VirtualInventoryContainerSlot
public "insertIntoPlayerInventory"(player: $UUID$Type, stack: $ItemStack$Type): $ItemStack
public "simulateInsertIntoPlayerInventory"(player: $UUID$Type, stack: $ItemStack$Type): $ItemStack
public "onClick"(slotProvider: $Supplier$Type<($ISlotClickHandler$IScrollableSlot$Type)>, button: integer, hasShiftDown: boolean, heldItem: $ItemStack$Type): void
public "getTotalTypes"(): integer
public "broadcastChanges"(): void
public static "getSlotsYMax"(): integer
public "handleBatchUpdate"(itemMap: $Object2LongMap$Type<($HashedItem$UUIDAwareHashedItem$Type)>, countCapacity: long, typeCapacity: integer): void
public "setSortDirection"(sortDirection: $QIOItemViewerContainer$SortDirection$Type): void
public "getSortType"(): $QIOItemViewerContainer$ListSortType
public "handleUpdate"(itemMap: $Object2LongMap$Type<($HashedItem$UUIDAwareHashedItem$Type)>, countCapacity: long, typeCapacity: integer): void
public "updateSearch"(queryText: string): void
public "getCountCapacity"(): long
public "setSortType"(sortType: $QIOItemViewerContainer$ListSortType$Type): void
public "handleKill"(): void
public "getQIOItemList"(): $List<($ISlotClickHandler$IScrollableSlot)>
public "getTypeCapacity"(): integer
public "getTotalItems"(): long
public "getSortDirection"(): $QIOItemViewerContainer$SortDirection
public "getTransferHelper"(player: $Player$Type, craftingWindow: $QIOCraftingWindow$Type): $QIOCraftingTransferHelper
public "getCraftingWindow"(selectedCraftingGrid: integer): $QIOCraftingWindow
get "frequency"(): $QIOFrequency
get "selectedCraftingGrid"(): byte
get "totalTypes"(): integer
get "slotsYMax"(): integer
set "sortDirection"(value: $QIOItemViewerContainer$SortDirection$Type)
get "sortType"(): $QIOItemViewerContainer$ListSortType
get "countCapacity"(): long
set "sortType"(value: $QIOItemViewerContainer$ListSortType$Type)
get "qIOItemList"(): $List<($ISlotClickHandler$IScrollableSlot)>
get "typeCapacity"(): integer
get "totalItems"(): long
get "sortDirection"(): $QIOItemViewerContainer$SortDirection
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOItemViewerContainer$Type = ($QIOItemViewerContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOItemViewerContainer_ = $QIOItemViewerContainer$Type;
}}
declare module "packages/mekanism/common/block/prefab/$BlockTile$BlockTileModel" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IStateFluidLoggable, $IStateFluidLoggable$Type} from "packages/mekanism/common/block/states/$IStateFluidLoggable"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockTile, $BlockTile$Type} from "packages/mekanism/common/block/prefab/$BlockTile"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockTile$BlockTileModel<TILE extends $TileEntityMekanism, BLOCK extends $BlockTypeTile<(TILE)>> extends $BlockTile<(TILE), (BLOCK)> implements $IStateFluidLoggable {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(type: BLOCK, propertiesModifier: $UnaryOperator$Type<($BlockBehaviour$Properties$Type)>)
constructor(type: BLOCK, properties: $BlockBehaviour$Properties$Type)

public "setState"(state: $BlockState$Type, fluid: $Fluid$Type): $BlockState
public "getFluidLightLevel"(state: $BlockState$Type): integer
public "getFluid"(state: $BlockState$Type): $FluidState
public "canPlaceLiquid"(world: $BlockGetter$Type, pos: $BlockPos$Type, state: $BlockState$Type, fluid: $Fluid$Type): boolean
public "pickupBlock"(world: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type): $ItemStack
public "getPickupSound"(state: $BlockState$Type): $Optional<($SoundEvent)>
public "placeLiquid"(world: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type, fluidState: $FluidState$Type): boolean
public "getPickupSound"(): $Optional<($SoundEvent)>
public "getFluidLoggedProperty"(): $EnumProperty<(any)>
public "isValidFluid"(fluid: $Fluid$Type): boolean
public "updateFluids"(state: $BlockState$Type, world: $LevelAccessor$Type, currentPos: $BlockPos$Type): void
get "pickupSound"(): $Optional<($SoundEvent)>
get "fluidLoggedProperty"(): $EnumProperty<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTile$BlockTileModel$Type<TILE, BLOCK> = ($BlockTile$BlockTileModel<(TILE), (BLOCK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTile$BlockTileModel_<TILE, BLOCK> = $BlockTile$BlockTileModel$Type<(TILE), (BLOCK)>;
}}
declare module "packages/mekanism/common/inventory/container/$SelectedWindowData$WindowType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$List, $List$Type} from "packages/java/util/$List"

export class $SelectedWindowData$WindowType extends $Enum<($SelectedWindowData$WindowType)> {
static readonly "COLOR": $SelectedWindowData$WindowType
static readonly "CONFIRMATION": $SelectedWindowData$WindowType
static readonly "CRAFTING": $SelectedWindowData$WindowType
static readonly "MEKA_SUIT_HELMET": $SelectedWindowData$WindowType
static readonly "RENAME": $SelectedWindowData$WindowType
static readonly "SKIN_SELECT": $SelectedWindowData$WindowType
static readonly "SIDE_CONFIG": $SelectedWindowData$WindowType
static readonly "TRANSPORTER_CONFIG": $SelectedWindowData$WindowType
static readonly "UPGRADE": $SelectedWindowData$WindowType
static readonly "UNSPECIFIED": $SelectedWindowData$WindowType


public static "values"(): ($SelectedWindowData$WindowType)[]
public static "valueOf"(name: string): $SelectedWindowData$WindowType
public "isValid"(extraData: byte): boolean
public "getSavePaths"(): $List<(string)>
get "savePaths"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SelectedWindowData$WindowType$Type = (("transporter_config") | ("color") | ("upgrade") | ("rename") | ("unspecified") | ("crafting") | ("side_config") | ("confirmation") | ("meka_suit_helmet") | ("skin_select")) | ($SelectedWindowData$WindowType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SelectedWindowData$WindowType_ = $SelectedWindowData$WindowType$Type;
}}
declare module "packages/mekanism/common/capabilities/resolver/$BasicSidedCapabilityResolver$BasicProxyCreator" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BasicSidedCapabilityResolver$ProxyCreator, $BasicSidedCapabilityResolver$ProxyCreator$Type} from "packages/mekanism/common/capabilities/resolver/$BasicSidedCapabilityResolver$ProxyCreator"
import {$IHolder, $IHolder$Type} from "packages/mekanism/common/capabilities/holder/$IHolder"

export interface $BasicSidedCapabilityResolver$BasicProxyCreator<HANDLER, SIDED_HANDLER extends HANDLER> extends $BasicSidedCapabilityResolver$ProxyCreator<(HANDLER), (SIDED_HANDLER)> {

 "create"(handler: SIDED_HANDLER, side: $Direction$Type): HANDLER
 "create"(handler: SIDED_HANDLER, side: $Direction$Type, holder: $IHolder$Type): HANDLER

(handler: SIDED_HANDLER, side: $Direction$Type): HANDLER
}

export namespace $BasicSidedCapabilityResolver$BasicProxyCreator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicSidedCapabilityResolver$BasicProxyCreator$Type<HANDLER, SIDED_HANDLER> = ($BasicSidedCapabilityResolver$BasicProxyCreator<(HANDLER), (SIDED_HANDLER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicSidedCapabilityResolver$BasicProxyCreator_<HANDLER, SIDED_HANDLER> = $BasicSidedCapabilityResolver$BasicProxyCreator$Type<(HANDLER), (SIDED_HANDLER)>;
}}
declare module "packages/mekanism/common/inventory/container/type/$BaseMekanismContainerType" {
import {$LecternMenu, $LecternMenu$Type} from "packages/net/minecraft/world/inventory/$LecternMenu"
import {$SmokerMenu, $SmokerMenu$Type} from "packages/net/minecraft/world/inventory/$SmokerMenu"
import {$DispenserMenu, $DispenserMenu$Type} from "packages/net/minecraft/world/inventory/$DispenserMenu"
import {$FurnaceMenu, $FurnaceMenu$Type} from "packages/net/minecraft/world/inventory/$FurnaceMenu"
import {$SmithingMenu, $SmithingMenu$Type} from "packages/net/minecraft/world/inventory/$SmithingMenu"
import {$AnvilMenu, $AnvilMenu$Type} from "packages/net/minecraft/world/inventory/$AnvilMenu"
import {$CraftingMenu, $CraftingMenu$Type} from "packages/net/minecraft/world/inventory/$CraftingMenu"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$CartographyTableMenu, $CartographyTableMenu$Type} from "packages/net/minecraft/world/inventory/$CartographyTableMenu"
import {$IContainerFactory, $IContainerFactory$Type} from "packages/net/minecraftforge/network/$IContainerFactory"
import {$GrindstoneMenu, $GrindstoneMenu$Type} from "packages/net/minecraft/world/inventory/$GrindstoneMenu"
import {$LoomMenu, $LoomMenu$Type} from "packages/net/minecraft/world/inventory/$LoomMenu"
import {$MerchantMenu, $MerchantMenu$Type} from "packages/net/minecraft/world/inventory/$MerchantMenu"
import {$ShulkerBoxMenu, $ShulkerBoxMenu$Type} from "packages/net/minecraft/world/inventory/$ShulkerBoxMenu"
import {$BeaconMenu, $BeaconMenu$Type} from "packages/net/minecraft/world/inventory/$BeaconMenu"
import {$EnchantmentMenu, $EnchantmentMenu$Type} from "packages/net/minecraft/world/inventory/$EnchantmentMenu"
import {$HopperMenu, $HopperMenu$Type} from "packages/net/minecraft/world/inventory/$HopperMenu"
import {$BrewingStandMenu, $BrewingStandMenu$Type} from "packages/net/minecraft/world/inventory/$BrewingStandMenu"
import {$StonecutterMenu, $StonecutterMenu$Type} from "packages/net/minecraft/world/inventory/$StonecutterMenu"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$BlastFurnaceMenu, $BlastFurnaceMenu$Type} from "packages/net/minecraft/world/inventory/$BlastFurnaceMenu"
import {$ChestMenu, $ChestMenu$Type} from "packages/net/minecraft/world/inventory/$ChestMenu"

export class $BaseMekanismContainerType<T, CONTAINER extends $AbstractContainerMenu, FACTORY> extends $MenuType<(CONTAINER)> {
static readonly "GENERIC_9x1": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x2": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x3": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x4": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x5": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x6": $MenuType<($ChestMenu)>
static readonly "GENERIC_3x3": $MenuType<($DispenserMenu)>
static readonly "ANVIL": $MenuType<($AnvilMenu)>
static readonly "BEACON": $MenuType<($BeaconMenu)>
static readonly "BLAST_FURNACE": $MenuType<($BlastFurnaceMenu)>
static readonly "BREWING_STAND": $MenuType<($BrewingStandMenu)>
static readonly "CRAFTING": $MenuType<($CraftingMenu)>
static readonly "ENCHANTMENT": $MenuType<($EnchantmentMenu)>
static readonly "FURNACE": $MenuType<($FurnaceMenu)>
static readonly "GRINDSTONE": $MenuType<($GrindstoneMenu)>
static readonly "HOPPER": $MenuType<($HopperMenu)>
static readonly "LECTERN": $MenuType<($LecternMenu)>
static readonly "LOOM": $MenuType<($LoomMenu)>
static readonly "MERCHANT": $MenuType<($MerchantMenu)>
static readonly "SHULKER_BOX": $MenuType<($ShulkerBoxMenu)>
static readonly "SMITHING": $MenuType<($SmithingMenu)>
static readonly "SMOKER": $MenuType<($SmokerMenu)>
static readonly "CARTOGRAPHY_TABLE": $MenuType<($CartographyTableMenu)>
static readonly "STONECUTTER": $MenuType<($StonecutterMenu)>


public static "create"<T extends $AbstractContainerMenu>(arg0: $IContainerFactory$Type<(T)>): $MenuType<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseMekanismContainerType$Type<T, CONTAINER, FACTORY> = ($BaseMekanismContainerType<(T), (CONTAINER), (FACTORY)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseMekanismContainerType_<T, CONTAINER, FACTORY> = $BaseMekanismContainerType$Type<(T), (CONTAINER), (FACTORY)>;
}}
declare module "packages/mekanism/common/tile/laser/$TileEntityLaserReceptor" {
import {$ILaserReceptor, $ILaserReceptor$Type} from "packages/mekanism/api/lasers/$ILaserReceptor"
import {$TileEntityBasicLaser, $TileEntityBasicLaser$Type} from "packages/mekanism/common/tile/laser/$TileEntityBasicLaser"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export class $TileEntityLaserReceptor extends $TileEntityBasicLaser implements $ILaserReceptor {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "canLasersDig"(): boolean
public "receiveLaserEnergy"(energy: $FloatingLong$Type): void
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityLaserReceptor$Type = ($TileEntityLaserReceptor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityLaserReceptor_ = $TileEntityLaserReceptor$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemArmoredJetpack" {
import {$ImmutableMultimap$Builder, $ImmutableMultimap$Builder$Type} from "packages/com/google/common/collect/$ImmutableMultimap$Builder"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$IJetpackItem$JetpackMode, $IJetpackItem$JetpackMode$Type} from "packages/mekanism/common/item/interfaces/$IJetpackItem$JetpackMode"
import {$BooleanSupplier, $BooleanSupplier$Type} from "packages/java/util/function/$BooleanSupplier"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$ItemJetpack, $ItemJetpack$Type} from "packages/mekanism/common/item/gear/$ItemJetpack"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$IAttributeRefresher, $IAttributeRefresher$Type} from "packages/mekanism/common/lib/attribute/$IAttributeRefresher"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$DispenseItemBehavior, $DispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DispenseItemBehavior"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemArmoredJetpack extends $ItemJetpack implements $IAttributeRefresher {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "initializeClient"(consumer: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "addToBuilder"(builder: $ImmutableMultimap$Builder$Type<($Attribute$Type), ($AttributeModifier$Type)>): void
public "getAttributeModifiers"(slot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getDefense"(): integer
public "getToughness"(): float
public static "displayModeChange"(player: $Player$Type): void
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
public static "getPlayerJetpackMode"(player: $Player$Type, mode: $IJetpackItem$JetpackMode$Type, ascendingSupplier: $BooleanSupplier$Type): $IJetpackItem$JetpackMode
public static "getActiveJetpack"(entity: $LivingEntity$Type): $ItemStack
public static "getPrimaryJetpack"(entity: $LivingEntity$Type): $ItemStack
public static "handleJetpackMotion"(player: $Player$Type, mode: $IJetpackItem$JetpackMode$Type, ascendingSupplier: $BooleanSupplier$Type): boolean
public static "get"(arg0: $ItemStack$Type): $Equipable
get "defense"(): integer
get "toughness"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemArmoredJetpack$Type = ($ItemArmoredJetpack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemArmoredJetpack_ = $ItemArmoredJetpack$Type;
}}
declare module "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $IModeItem$DisplayChange extends $Enum<($IModeItem$DisplayChange)> {
static readonly "NONE": $IModeItem$DisplayChange
static readonly "MAIN_HAND": $IModeItem$DisplayChange
static readonly "OTHER": $IModeItem$DisplayChange


public static "values"(): ($IModeItem$DisplayChange)[]
public static "valueOf"(name: string): $IModeItem$DisplayChange
public "sendMessage"(player: $Player$Type, message: $Supplier$Type<($Component$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModeItem$DisplayChange$Type = (("main_hand") | ("other") | ("none")) | ($IModeItem$DisplayChange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModeItem$DisplayChange_ = $IModeItem$DisplayChange$Type;
}}
declare module "packages/mekanism/common/lib/math/voxel/$VoxelPlane" {
import {$Structure$Axis, $Structure$Axis$Type} from "packages/mekanism/common/lib/multiblock/$Structure$Axis"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $VoxelPlane {

constructor(axis: $Structure$Axis$Type, pos: $BlockPos$Type, frame: boolean)

public "equals"(obj: any): boolean
public "length"(): integer
public "toString"(): string
public "hashCode"(): integer
public "size"(): integer
public "merge"(other: $VoxelPlane$Type): void
public "height"(): integer
public "isFull"(): boolean
public "getAxis"(): $Structure$Axis
public "hasFrame"(): boolean
public "getMinRow"(): integer
public "getMinCol"(): integer
public "getMaxCol"(): integer
public "getMaxRow"(): integer
public "getMissing"(): integer
public "isOutside"(pos: $BlockPos$Type): boolean
get "full"(): boolean
get "axis"(): $Structure$Axis
get "minRow"(): integer
get "minCol"(): integer
get "maxCol"(): integer
get "maxRow"(): integer
get "missing"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VoxelPlane$Type = ($VoxelPlane);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VoxelPlane_ = $VoxelPlane$Type;
}}
declare module "packages/mekanism/common/item/interfaces/$IDroppableContents" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"

export interface $IDroppableContents {

 "getDroppedSlots"(stack: $ItemStack$Type): $List<($IInventorySlot)>
 "canContentsDrop"(stack: $ItemStack$Type): boolean

(stack: $ItemStack$Type): $List<($IInventorySlot)>
}

export namespace $IDroppableContents {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDroppableContents$Type = ($IDroppableContents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDroppableContents_ = $IDroppableContents$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$IHasGasMode" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IHasGasMode {

 "nextMode"(tank: integer): void

(tank: integer): void
}

export namespace $IHasGasMode {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHasGasMode$Type = ($IHasGasMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHasGasMode_ = $IHasGasMode$Type;
}}
declare module "packages/mekanism/common/inventory/warning/$WarningTracker$WarningType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $WarningTracker$WarningType extends $Enum<($WarningTracker$WarningType)> {
static readonly "INPUT_DOESNT_PRODUCE_OUTPUT": $WarningTracker$WarningType
static readonly "NO_MATCHING_RECIPE": $WarningTracker$WarningType
static readonly "NO_SPACE_IN_OUTPUT": $WarningTracker$WarningType
static readonly "NO_SPACE_IN_OUTPUT_OVERFLOW": $WarningTracker$WarningType
static readonly "NOT_ENOUGH_ENERGY": $WarningTracker$WarningType
static readonly "NOT_ENOUGH_ENERGY_REDUCED_RATE": $WarningTracker$WarningType
static readonly "INVALID_OREDICTIONIFICATOR_FILTER": $WarningTracker$WarningType
static readonly "FILTER_HAS_BLACKLISTED_ELEMENT": $WarningTracker$WarningType


public static "values"(): ($WarningTracker$WarningType)[]
public static "valueOf"(name: string): $WarningTracker$WarningType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WarningTracker$WarningType$Type = (("input_doesnt_produce_output") | ("no_space_in_output_overflow") | ("not_enough_energy_reduced_rate") | ("filter_has_blacklisted_element") | ("invalid_oredictionificator_filter") | ("not_enough_energy") | ("no_matching_recipe") | ("no_space_in_output")) | ($WarningTracker$WarningType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WarningTracker$WarningType_ = $WarningTracker$WarningType$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$GasToGasRecipeSerializer$IFactory" {
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$GasToGasRecipe, $GasToGasRecipe$Type} from "packages/mekanism/api/recipes/$GasToGasRecipe"
import {$ChemicalStackIngredient$GasStackIngredient, $ChemicalStackIngredient$GasStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient$GasStackIngredient"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $GasToGasRecipeSerializer$IFactory<RECIPE extends $GasToGasRecipe> {

 "create"(id: $ResourceLocation$Type, input: $ChemicalStackIngredient$GasStackIngredient$Type, output: $GasStack$Type): RECIPE

(id: $ResourceLocation$Type, input: $ChemicalStackIngredient$GasStackIngredient$Type, output: $GasStack$Type): RECIPE
}

export namespace $GasToGasRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GasToGasRecipeSerializer$IFactory$Type<RECIPE> = ($GasToGasRecipeSerializer$IFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GasToGasRecipeSerializer$IFactory_<RECIPE> = $GasToGasRecipeSerializer$IFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/lib/inventory/$Finder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $Finder {

 "modifies"(stack: $ItemStack$Type): boolean

(itemType: $ItemStack$Type): $Finder
}

export namespace $Finder {
const ANY: $Finder
function strict(itemType: $ItemStack$Type): $Finder
function tag(tagName: string): $Finder
function item(itemType: $Item$Type): $Finder
function item(itemType: $ItemStack$Type): $Finder
function modID(modID: string): $Finder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Finder$Type = ($Finder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Finder_ = $Finder$Type;
}}
declare module "packages/mekanism/common/item/block/machine/$ItemBlockLaserTractorBeam" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$BlockTile, $BlockTile$Type} from "packages/mekanism/common/block/prefab/$BlockTile"
import {$ItemBlockMachine, $ItemBlockMachine$Type} from "packages/mekanism/common/item/block/machine/$ItemBlockMachine"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockLaserTractorBeam extends $ItemBlockMachine {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockTile$Type<(any), (any)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockLaserTractorBeam$Type = ($ItemBlockLaserTractorBeam);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockLaserTractorBeam_ = $ItemBlockLaserTractorBeam$Type;
}}
declare module "packages/mekanism/common/tile/laser/$TileEntityLaserAmplifier$RedstoneOutput" {
import {$IHasTranslationKey, $IHasTranslationKey$Type} from "packages/mekanism/api/text/$IHasTranslationKey"
import {$IIncrementalEnum, $IIncrementalEnum$Type} from "packages/mekanism/api/$IIncrementalEnum"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export class $TileEntityLaserAmplifier$RedstoneOutput extends $Enum<($TileEntityLaserAmplifier$RedstoneOutput)> implements $IIncrementalEnum<($TileEntityLaserAmplifier$RedstoneOutput)>, $IHasTranslationKey {
static readonly "OFF": $TileEntityLaserAmplifier$RedstoneOutput
static readonly "ENTITY_DETECTION": $TileEntityLaserAmplifier$RedstoneOutput
static readonly "ENERGY_CONTENTS": $TileEntityLaserAmplifier$RedstoneOutput


public static "values"(): ($TileEntityLaserAmplifier$RedstoneOutput)[]
public static "valueOf"(name: string): $TileEntityLaserAmplifier$RedstoneOutput
public "getTranslationKey"(): string
public "byIndex"(index: integer): $TileEntityLaserAmplifier$RedstoneOutput
public static "byIndexStatic"(index: integer): $TileEntityLaserAmplifier$RedstoneOutput
public "ordinal"(): integer
public "adjust"(arg0: integer): $TileEntityLaserAmplifier$RedstoneOutput
public "adjust"(arg0: integer, arg1: $Predicate$Type<($TileEntityLaserAmplifier$RedstoneOutput$Type)>): $TileEntityLaserAmplifier$RedstoneOutput
public "getNext"(arg0: $Predicate$Type<($TileEntityLaserAmplifier$RedstoneOutput$Type)>): $TileEntityLaserAmplifier$RedstoneOutput
public "getNext"(): $TileEntityLaserAmplifier$RedstoneOutput
public "getPrevious"(): $TileEntityLaserAmplifier$RedstoneOutput
public "getPrevious"(arg0: $Predicate$Type<($TileEntityLaserAmplifier$RedstoneOutput$Type)>): $TileEntityLaserAmplifier$RedstoneOutput
get "translationKey"(): string
get "next"(): $TileEntityLaserAmplifier$RedstoneOutput
get "previous"(): $TileEntityLaserAmplifier$RedstoneOutput
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityLaserAmplifier$RedstoneOutput$Type = (("entity_detection") | ("energy_contents") | ("off")) | ($TileEntityLaserAmplifier$RedstoneOutput);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityLaserAmplifier$RedstoneOutput_ = $TileEntityLaserAmplifier$RedstoneOutput$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ElectrolysisRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ElectrolysisRecipeSerializer$IFactory, $ElectrolysisRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$ElectrolysisRecipeSerializer$IFactory"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ElectrolysisRecipe, $ElectrolysisRecipe$Type} from "packages/mekanism/api/recipes/$ElectrolysisRecipe"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ElectrolysisRecipeSerializer<RECIPE extends $ElectrolysisRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(factory: $ElectrolysisRecipeSerializer$IFactory$Type<(RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ElectrolysisRecipeSerializer$Type<RECIPE> = ($ElectrolysisRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ElectrolysisRecipeSerializer_<RECIPE> = $ElectrolysisRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/recipe/serializer/$ChemicalCrystallizerRecipeSerializer$IFactory" {
import {$ChemicalStackIngredient, $ChemicalStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient"
import {$ChemicalCrystallizerRecipe, $ChemicalCrystallizerRecipe$Type} from "packages/mekanism/api/recipes/$ChemicalCrystallizerRecipe"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $ChemicalCrystallizerRecipeSerializer$IFactory<RECIPE extends $ChemicalCrystallizerRecipe> {

 "create"(id: $ResourceLocation$Type, input: $ChemicalStackIngredient$Type<(any), (any)>, output: $ItemStack$Type): RECIPE

(id: $ResourceLocation$Type, input: $ChemicalStackIngredient$Type<(any), (any)>, output: $ItemStack$Type): RECIPE
}

export namespace $ChemicalCrystallizerRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalCrystallizerRecipeSerializer$IFactory$Type<RECIPE> = ($ChemicalCrystallizerRecipeSerializer$IFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalCrystallizerRecipeSerializer$IFactory_<RECIPE> = $ChemicalCrystallizerRecipeSerializer$IFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/lib/frequency/$IColorableFrequency" {
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"

export interface $IColorableFrequency {

 "setColor"(color: $EnumColor$Type): void
 "getColor"(): $EnumColor
}

export namespace $IColorableFrequency {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IColorableFrequency$Type = ($IColorableFrequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IColorableFrequency_ = $IColorableFrequency$Type;
}}
declare module "packages/mekanism/common/capabilities/chemical/dynamic/$ISlurryTracker" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$ISlurryTank, $ISlurryTank$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryTank"

export interface $ISlurryTracker extends $IContentsListener {

 "getSlurryTanks"(side: $Direction$Type): $List<($ISlurryTank)>
 "onContentsChanged"(): void
}

export namespace $ISlurryTracker {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISlurryTracker$Type = ($ISlurryTracker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISlurryTracker_ = $ISlurryTracker$Type;
}}
declare module "packages/mekanism/common/inventory/container/item/$PortableQIODashboardContainer" {
import {$ClickType, $ClickType$Type} from "packages/net/minecraft/world/inventory/$ClickType"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ContainerListener, $ContainerListener$Type} from "packages/net/minecraft/world/inventory/$ContainerListener"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$QIOItemViewerContainer, $QIOItemViewerContainer$Type} from "packages/mekanism/common/inventory/container/$QIOItemViewerContainer"

export class $PortableQIODashboardContainer extends $QIOItemViewerContainer {
static readonly "SLOTS_X_MIN": integer
static readonly "SLOTS_X_MAX": integer
static readonly "SLOTS_Y_MIN": integer
static readonly "SLOTS_Y_MAX": integer
static readonly "SLOTS_START_Y": integer
static readonly "BASE_Y_OFFSET": integer
static readonly "TRANSPORTER_CONFIG_WINDOW": integer
static readonly "SIDE_CONFIG_WINDOW": integer
static readonly "UPGRADE_WINDOW": integer
static readonly "SKIN_SELECT_WINDOW": integer
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
 "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
 "remoteSlots": $NonNullList<($ItemStack)>
 "stateId": integer
 "containerId": integer
readonly "containerListeners": $List<($ContainerListener)>

constructor(id: integer, inv: $Inventory$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type, remote: boolean)

public "getStack"(): $ItemStack
public "clicked"(slotId: integer, dragType: integer, clickType: $ClickType$Type, player: $Player$Type): void
public "getHand"(): $InteractionHand
public "stillValid"(player: $Player$Type): boolean
public "getSecurityObject"(): $ICapabilityProvider
get "stack"(): $ItemStack
get "hand"(): $InteractionHand
get "securityObject"(): $ICapabilityProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PortableQIODashboardContainer$Type = ($PortableQIODashboardContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PortableQIODashboardContainer_ = $PortableQIODashboardContainer$Type;
}}
declare module "packages/mekanism/common/upgrade/transmitter/$UniversalCableUpgradeData" {
import {$IEnergyContainer, $IEnergyContainer$Type} from "packages/mekanism/api/energy/$IEnergyContainer"
import {$TransmitterUpgradeData, $TransmitterUpgradeData$Type} from "packages/mekanism/common/upgrade/transmitter/$TransmitterUpgradeData"
import {$ConnectionType, $ConnectionType$Type} from "packages/mekanism/common/lib/transmitter/$ConnectionType"

export class $UniversalCableUpgradeData extends $TransmitterUpgradeData {
readonly "buffer": $IEnergyContainer
readonly "redstoneReactive": boolean
readonly "connectionTypes": ($ConnectionType)[]

constructor(redstoneReactive: boolean, connectionTypes: ($ConnectionType$Type)[], buffer: $IEnergyContainer$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UniversalCableUpgradeData$Type = ($UniversalCableUpgradeData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UniversalCableUpgradeData_ = $UniversalCableUpgradeData$Type;
}}
declare module "packages/mekanism/common/item/block/$ItemBlockChemicalTank" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$Type} from "packages/mekanism/common/block/prefab/$BlockTile$BlockTileModel"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ListTag, $ListTag$Type} from "packages/net/minecraft/nbt/$ListTag"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemBlockTooltip, $ItemBlockTooltip$Type} from "packages/mekanism/common/item/block/$ItemBlockTooltip"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Machine, $Machine$Type} from "packages/mekanism/common/content/blocktype/$Machine"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IItemSustainedInventory, $IItemSustainedInventory$Type} from "packages/mekanism/common/item/interfaces/$IItemSustainedInventory"
import {$TileEntityChemicalTank, $TileEntityChemicalTank$Type} from "packages/mekanism/common/tile/$TileEntityChemicalTank"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockChemicalTank extends $ItemBlockTooltip<($BlockTile$BlockTileModel<($TileEntityChemicalTank), ($Machine<($TileEntityChemicalTank)>)>)> implements $IItemSustainedInventory {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockTile$BlockTileModel$Type<($TileEntityChemicalTank$Type), ($Machine$Type<($TileEntityChemicalTank$Type)>)>)

public "isBarVisible"(stack: $ItemStack$Type): boolean
public "getBarWidth"(stack: $ItemStack$Type): integer
public "getBarColor"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "getSustainedInventory"(stack: $ItemStack$Type): $ListTag
public "getSustainedInventory"(): $ListTag
public "setSustainedInventory"(nbtTags: $ListTag$Type): void
public "setSustainedInventory"(nbtTags: $ListTag$Type, stack: $ItemStack$Type): void
public "getDroppedSlots"(stack: $ItemStack$Type): $List<($IInventorySlot)>
public "hasSustainedInventory"(stack: $ItemStack$Type): boolean
public "hasSustainedInventory"(): boolean
public "canContentsDrop"(stack: $ItemStack$Type): boolean
get "sustainedInventory"(): $ListTag
set "sustainedInventory"(value: $ListTag$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockChemicalTank$Type = ($ItemBlockChemicalTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockChemicalTank_ = $ItemBlockChemicalTank$Type;
}}
declare module "packages/mekanism/common/integration/computer/$TableType$Builder" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$TableType, $TableType$Type} from "packages/mekanism/common/integration/computer/$TableType"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TableType$Builder {


public "extendedFrom"(c: $Class$Type<(any)>): $TableType$Builder
public "addField"(name: string, javaType: $Class$Type<(any)>, description: string, ...javaExtra: ($Class$Type<(any)>)[]): $TableType$Builder
public "build"(destination: $Map$Type<($Class$Type<(any)>), ($TableType$Type)>): $TableType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TableType$Builder$Type = ($TableType$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TableType$Builder_ = $TableType$Builder$Type;
}}
declare module "packages/mekanism/common/lib/transmitter/$INetworkDataHandler" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"

export interface $INetworkDataHandler {

 "getNetworkReaderCapacity"(): any
 "getFlowInfo"(): $Component
 "getStoredInfo"(): $Component
 "getNeededInfo"(): $Component
}

export namespace $INetworkDataHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $INetworkDataHandler$Type = ($INetworkDataHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $INetworkDataHandler_ = $INetworkDataHandler$Type;
}}
declare module "packages/mekanism/common/content/qio/$QIOFrequency" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ObjLongConsumer, $ObjLongConsumer$Type} from "packages/java/util/function/$ObjLongConsumer"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IHashedItem, $IHashedItem$Type} from "packages/mekanism/api/inventory/$IHashedItem"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$QIODriveData, $QIODriveData$Type} from "packages/mekanism/common/content/qio/$QIODriveData"
import {$IColorableFrequency, $IColorableFrequency$Type} from "packages/mekanism/common/lib/frequency/$IColorableFrequency"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$QIODriveData$QIODriveKey, $QIODriveData$QIODriveKey$Type} from "packages/mekanism/common/content/qio/$QIODriveData$QIODriveKey"
import {$QIOFrequency$QIOItemTypeData, $QIOFrequency$QIOItemTypeData$Type} from "packages/mekanism/common/content/qio/$QIOFrequency$QIOItemTypeData"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$HashedItem, $HashedItem$Type} from "packages/mekanism/common/lib/inventory/$HashedItem"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$Object2LongMap, $Object2LongMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongMap"
import {$IQIOFrequency, $IQIOFrequency$Type} from "packages/mekanism/api/inventory/qio/$IQIOFrequency"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $QIOFrequency extends $Frequency implements $IColorableFrequency, $IQIOFrequency {

constructor(n: string, uuid: $UUID$Type)
constructor()

public "update"(tile: $BlockEntity$Type): boolean
public "write"(nbtTags: $CompoundTag$Type): void
public "write"(buf: $FriendlyByteBuf$Type): void
public "read"(buf: $FriendlyByteBuf$Type): void
public "setColor"(color: $EnumColor$Type): void
public "removeItem"(stack: $ItemStack$Type, amount: integer): $ItemStack
public "removeItem"(amount: integer): $ItemStack
public "onRemove"(): void
public "removeByType"(itemType: $HashedItem$Type, amount: integer): $ItemStack
public "addItem"(stack: $ItemStack$Type): $ItemStack
public "tick"(): boolean
public "saveAll"(): void
public "getTotalItemCountCapacity"(): long
public "getTotalItemTypeCapacity"(): integer
public "getStacksByTagWildcard"(wildcard: string): $Object2LongMap<($HashedItem)>
public "getStacksByModIDWildcard"(wildcard: string): $Object2LongMap<($HashedItem)>
public "getColor"(): $EnumColor
public "getTotalItemTypes"(remote: boolean): integer
public "closeItemViewer"(player: $ServerPlayer$Type): void
public "getStored"(itemType: $HashedItem$Type): long
public "getStored"(type: $ItemStack$Type): long
public "getTypesForItem"(item: $Item$Type): $Set<($HashedItem)>
public "massExtract"(stack: $ItemStack$Type, amount: long, action: $Action$Type): long
public "forAllHashedStored"(consumer: $ObjLongConsumer$Type<($IHashedItem$Type)>): void
public "massInsert"(stack: $ItemStack$Type, amount: long, action: $Action$Type): long
public "forAllStored"(consumer: $ObjLongConsumer$Type<($ItemStack$Type)>): void
public "openItemViewer"(player: $ServerPlayer$Type): void
public "onDeactivate"(tile: $BlockEntity$Type): boolean
public "getDriveData"(key: $QIODriveData$QIODriveKey$Type): $QIODriveData
public "getTotalItemCount"(): long
public "getStacksByItem"(item: $Item$Type): $Object2LongMap<($HashedItem)>
public "getItemDataMap"(): $Map<($HashedItem), ($QIOFrequency$QIOItemTypeData)>
public "getSyncHash"(): integer
public "isStoring"(itemType: $HashedItem$Type): boolean
public "getAllDrives"(): $Collection<($QIODriveData)>
public "getStacksByTag"(tag: string): $Object2LongMap<($HashedItem)>
public "getStacksByModID"(modID: string): $Object2LongMap<($HashedItem)>
public "addDrive"(key: $QIODriveData$QIODriveKey$Type): void
public "removeDrive"(key: $QIODriveData$QIODriveKey$Type, updateItemMap: boolean): void
set "color"(value: $EnumColor$Type)
get "totalItemCountCapacity"(): long
get "totalItemTypeCapacity"(): integer
get "color"(): $EnumColor
get "totalItemCount"(): long
get "itemDataMap"(): $Map<($HashedItem), ($QIOFrequency$QIOItemTypeData)>
get "syncHash"(): integer
get "allDrives"(): $Collection<($QIODriveData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOFrequency$Type = ($QIOFrequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOFrequency_ = $QIOFrequency$Type;
}}
declare module "packages/mekanism/common/integration/computer/$MethodRestriction" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export class $MethodRestriction extends $Enum<($MethodRestriction)> implements $Predicate<(any)> {
static readonly "NONE": $MethodRestriction
static readonly "DIRECTIONAL": $MethodRestriction
static readonly "ENERGY": $MethodRestriction
static readonly "MULTIBLOCK": $MethodRestriction
static readonly "REDSTONE_CONTROL": $MethodRestriction
static readonly "COMPARATOR": $MethodRestriction


public static "values"(): ($MethodRestriction)[]
public "test"(handler: any): boolean
public static "valueOf"(name: string): $MethodRestriction
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<(any)>
public "negate"(): $Predicate<(any)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<(any)>
public static "isEqual"<T>(arg0: any): $Predicate<(any)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodRestriction$Type = (("redstone_control") | ("comparator") | ("directional") | ("multiblock") | ("none") | ("energy")) | ($MethodRestriction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodRestriction_ = $MethodRestriction$Type;
}}
declare module "packages/mekanism/common/inventory/container/$MekanismContainer" {
import {$IInsertableSlot, $IInsertableSlot$Type} from "packages/mekanism/common/inventory/container/slot/$IInsertableSlot"
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$ISecurityContainer, $ISecurityContainer$Type} from "packages/mekanism/common/inventory/container/$ISecurityContainer"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ContainerListener, $ContainerListener$Type} from "packages/net/minecraft/world/inventory/$ContainerListener"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$SelectedWindowData, $SelectedWindowData$Type} from "packages/mekanism/common/inventory/container/$SelectedWindowData"
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$InventoryContainerSlot, $InventoryContainerSlot$Type} from "packages/mekanism/common/inventory/container/slot/$InventoryContainerSlot"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$ISyncableData, $ISyncableData$Type} from "packages/mekanism/common/inventory/container/sync/$ISyncableData"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$MekanismContainer$ISpecificContainerTracker, $MekanismContainer$ISpecificContainerTracker$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer$ISpecificContainerTracker"
import {$MainInventorySlot, $MainInventorySlot$Type} from "packages/mekanism/common/inventory/container/slot/$MainInventorySlot"
import {$HotBarSlot, $HotBarSlot$Type} from "packages/mekanism/common/inventory/container/slot/$HotBarSlot"

export class $MekanismContainer extends $AbstractContainerMenu implements $ISecurityContainer {
static readonly "BASE_Y_OFFSET": integer
static readonly "TRANSPORTER_CONFIG_WINDOW": integer
static readonly "SIDE_CONFIG_WINDOW": integer
static readonly "UPGRADE_WINDOW": integer
static readonly "SKIN_SELECT_WINDOW": integer
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
 "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
 "remoteSlots": $NonNullList<($ItemStack)>
 "stateId": integer
 "containerId": integer
readonly "containerListeners": $List<($ContainerListener)>


public "sendAllDataToRemote"(): void
public "quickMoveStack"(player: $Player$Type, slotID: integer): $ItemStack
public "canTakeItemForPickAll"(stack: $ItemStack$Type, slot: $Slot$Type): boolean
public "track"(data: $ISyncableData$Type): void
public "isRemote"(): boolean
public "startTracking"(key: any, tracker: $MekanismContainer$ISpecificContainerTracker$Type): $List<($ISyncableData)>
public "stopTracking"(key: any): void
public "getPlayerUUID"(): $UUID
public "setSelectedWindow"(player: $UUID$Type, selectedWindow: $SelectedWindowData$Type): void
public "setSelectedWindow"(selectedWindow: $SelectedWindowData$Type): void
public static "insertItemCheckAll"<SLOT extends ($Slot) & ($IInsertableSlot)>(slots: $List$Type<(SLOT)>, stack: $ItemStack$Type, selectedWindow: $SelectedWindowData$Type, action: $Action$Type): $ItemStack
public "getHotBarSlots"(): $List<($HotBarSlot)>
public "getSelectedWindow"(): $SelectedWindowData
public "getSelectedWindow"(player: $UUID$Type): $SelectedWindowData
public "trackArray"(arrayIn: (double)[]): void
public "trackArray"(arrayIn: (byte)[]): void
public "trackArray"(arrayIn: (boolean)[]): void
public "trackArray"(arrayIn: (long)[]): void
public "trackArray"(arrayIn: (float)[]): void
public "trackArray"(arrayIn: (short)[]): void
public "trackArray"(arrayIn: ((boolean)[])[]): void
public "trackArray"(arrayIn: (integer)[]): void
public "removed"(player: $Player$Type): void
public "broadcastChanges"(): void
public "startTrackingServer"(key: any, tracker: $MekanismContainer$ISpecificContainerTracker$Type): void
public "getInventoryContainerSlots"(): $List<($InventoryContainerSlot)>
public "handleWindowProperty"(property: short, value: $FluidStack$Type): void
public "handleWindowProperty"<V>(property: short, value: V): void
public "handleWindowProperty"(property: short, value: $BlockPos$Type): void
public "handleWindowProperty"(property: short, value: long): void
public "handleWindowProperty"(property: short, value: double): void
public "handleWindowProperty"<TYPE>(property: short, value: $List$Type<(TYPE)>): void
public "handleWindowProperty"(property: short, value: $FloatingLong$Type): void
public "handleWindowProperty"<FREQUENCY extends $Frequency>(property: short, value: FREQUENCY): void
public "handleWindowProperty"<STACK extends $ChemicalStack<(any)>>(property: short, value: STACK): void
public "handleWindowProperty"(property: short, value: boolean): void
public "handleWindowProperty"(property: short, value: byte): void
public "handleWindowProperty"(property: short, value: short): void
public "handleWindowProperty"(property: short, value: float): void
public "handleWindowProperty"(property: short, value: $ItemStack$Type): void
public "handleWindowProperty"(property: short, value: integer): void
public "getMainInventorySlots"(): $List<($MainInventorySlot)>
public static "insertItem"<SLOT extends ($Slot) & ($IInsertableSlot)>(slots: $List$Type<(SLOT)>, stack: $ItemStack$Type, ignoreEmpty: boolean, selectedWindow: $SelectedWindowData$Type, action: $Action$Type): $ItemStack
public static "insertItem"<SLOT extends ($Slot) & ($IInsertableSlot)>(slots: $List$Type<(SLOT)>, stack: $ItemStack$Type, ignoreEmpty: boolean, checkAll: boolean, selectedWindow: $SelectedWindowData$Type, action: $Action$Type): $ItemStack
public static "insertItem"<SLOT extends ($Slot) & ($IInsertableSlot)>(slots: $List$Type<(SLOT)>, stack: $ItemStack$Type, ignoreEmpty: boolean, selectedWindow: $SelectedWindowData$Type): $ItemStack
public static "insertItem"<SLOT extends ($Slot) & ($IInsertableSlot)>(slots: $List$Type<(SLOT)>, stack: $ItemStack$Type, selectedWindow: $SelectedWindowData$Type): $ItemStack
public "getSecurityObject"(): $ICapabilityProvider
get "remote"(): boolean
get "playerUUID"(): $UUID
set "selectedWindow"(value: $SelectedWindowData$Type)
get "hotBarSlots"(): $List<($HotBarSlot)>
get "selectedWindow"(): $SelectedWindowData
get "inventoryContainerSlots"(): $List<($InventoryContainerSlot)>
get "mainInventorySlots"(): $List<($MainInventorySlot)>
get "securityObject"(): $ICapabilityProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismContainer$Type = ($MekanismContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismContainer_ = $MekanismContainer$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$DoubleItem" {
import {$ItemInputCache, $ItemInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$ItemInputCache"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$MekanismRecipeType, $MekanismRecipeType$Type} from "packages/mekanism/common/recipe/$MekanismRecipeType"
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$DoubleInputRecipeCache$DoubleSameInputRecipeCache, $DoubleInputRecipeCache$DoubleSameInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$DoubleInputRecipeCache$DoubleSameInputRecipeCache"

export class $InputRecipeCache$DoubleItem<RECIPE extends ($MekanismRecipe) & ($BiPredicate<($ItemStack), ($ItemStack)>)> extends $DoubleInputRecipeCache$DoubleSameInputRecipeCache<($ItemStack), ($ItemStackIngredient), (RECIPE), ($ItemInputCache<(RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$Type<(RECIPE), (any)>, inputAExtractor: $Function$Type<(RECIPE), ($ItemStackIngredient$Type)>, inputBExtractor: $Function$Type<(RECIPE), ($ItemStackIngredient$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$DoubleItem$Type<RECIPE> = ($InputRecipeCache$DoubleItem<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$DoubleItem_<RECIPE> = $InputRecipeCache$DoubleItem$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$DoubleInputRecipeCache" {
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$AbstractInputRecipeCache, $AbstractInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$AbstractInputRecipeCache"
import {$InputIngredient, $InputIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$InputIngredient"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IInputCache, $IInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$IInputCache"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"

export class $DoubleInputRecipeCache<INPUT_A, INGREDIENT_A extends $InputIngredient<(INPUT_A)>, INPUT_B, INGREDIENT_B extends $InputIngredient<(INPUT_B)>, RECIPE extends ($MekanismRecipe) & ($BiPredicate<(INPUT_A), (INPUT_B)>), CACHE_A extends $IInputCache<(INPUT_A), (INGREDIENT_A), (RECIPE)>, CACHE_B extends $IInputCache<(INPUT_B), (INGREDIENT_B), (RECIPE)>> extends $AbstractInputRecipeCache<(RECIPE)> {


public "clear"(): void
public "findTypeBasedRecipe"(world: $Level$Type, inputA: INPUT_A, inputB: INPUT_B, matchCriteria: $Predicate$Type<(RECIPE)>): RECIPE
public "findFirstRecipe"(world: $Level$Type, inputA: INPUT_A, inputB: INPUT_B, useCacheA: boolean): RECIPE
public "findFirstRecipe"(world: $Level$Type, inputA: INPUT_A, inputB: INPUT_B): RECIPE
public "containsInputAB"(world: $Level$Type, inputA: INPUT_A, inputB: INPUT_B): boolean
public "containsInputB"(world: $Level$Type, input: INPUT_B): boolean
public "containsInputBA"(world: $Level$Type, inputA: INPUT_A, inputB: INPUT_B): boolean
public "containsInputA"(world: $Level$Type, input: INPUT_A): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleInputRecipeCache$Type<INPUT_A, INGREDIENT_A, INPUT_B, INGREDIENT_B, RECIPE, CACHE_A, CACHE_B> = ($DoubleInputRecipeCache<(INPUT_A), (INGREDIENT_A), (INPUT_B), (INGREDIENT_B), (RECIPE), (CACHE_A), (CACHE_B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleInputRecipeCache_<INPUT_A, INGREDIENT_A, INPUT_B, INGREDIENT_B, RECIPE, CACHE_A, CACHE_B> = $DoubleInputRecipeCache$Type<(INPUT_A), (INGREDIENT_A), (INPUT_B), (INGREDIENT_B), (RECIPE), (CACHE_A), (CACHE_B)>;
}}
declare module "packages/mekanism/common/item/block/$ItemBlockMekanism" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$BlockItem, $BlockItem$Type} from "packages/net/minecraft/world/item/$BlockItem"
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$TextColor, $TextColor$Type} from "packages/net/minecraft/network/chat/$TextColor"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockMekanism<BLOCK extends $Block> extends $BlockItem {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: BLOCK, properties: $Item$Properties$Type)

public "getBlock"(): BLOCK
public "getTextColor"(stack: $ItemStack$Type): $TextColor
public "getTier"(): $ITier
public "initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "getName"(stack: $ItemStack$Type): $Component
get "block"(): BLOCK
get "tier"(): $ITier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockMekanism$Type<BLOCK> = ($ItemBlockMekanism<(BLOCK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockMekanism_<BLOCK> = $ItemBlockMekanism$Type<(BLOCK)>;
}}
declare module "packages/mekanism/common/inventory/warning/$ISupportsWarning" {
import {$BooleanSupplier, $BooleanSupplier$Type} from "packages/java/util/function/$BooleanSupplier"
import {$WarningTracker$WarningType, $WarningTracker$WarningType$Type} from "packages/mekanism/common/inventory/warning/$WarningTracker$WarningType"

export interface $ISupportsWarning<TYPE extends $ISupportsWarning<(TYPE)>> {

 "warning"(type: $WarningTracker$WarningType$Type, warningSupplier: $BooleanSupplier$Type): TYPE

(type: $WarningTracker$WarningType$Type, warningSupplier: $BooleanSupplier$Type): TYPE
}

export namespace $ISupportsWarning {
function compound(existing: $BooleanSupplier$Type, newSupplier: $BooleanSupplier$Type): $BooleanSupplier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISupportsWarning$Type<TYPE> = ($ISupportsWarning<(TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISupportsWarning_<TYPE> = $ISupportsWarning$Type<(TYPE)>;
}}
declare module "packages/mekanism/common/inventory/container/slot/$IInsertableSlot" {
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$SelectedWindowData, $SelectedWindowData$Type} from "packages/mekanism/common/inventory/container/$SelectedWindowData"

export interface $IInsertableSlot {

 "exists"(windowData: $SelectedWindowData$Type): boolean
 "canMergeWith"(stack: $ItemStack$Type): boolean
 "insertItem"(stack: $ItemStack$Type, action: $Action$Type): $ItemStack

(windowData: $SelectedWindowData$Type): boolean
}

export namespace $IInsertableSlot {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInsertableSlot$Type = ($IInsertableSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInsertableSlot_ = $IInsertableSlot$Type;
}}
declare module "packages/mekanism/common/content/qio/$QIOCraftingTransferHelper" {
import {$HashedItem$UUIDAwareHashedItem, $HashedItem$UUIDAwareHashedItem$Type} from "packages/mekanism/common/lib/inventory/$HashedItem$UUIDAwareHashedItem"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$HashedItem, $HashedItem$Type} from "packages/mekanism/common/lib/inventory/$HashedItem"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Object2LongMap, $Object2LongMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongMap"
import {$MainInventorySlot, $MainInventorySlot$Type} from "packages/mekanism/common/inventory/container/slot/$MainInventorySlot"
import {$QIOCraftingTransferHelper$HashedItemSource, $QIOCraftingTransferHelper$HashedItemSource$Type} from "packages/mekanism/common/content/qio/$QIOCraftingTransferHelper$HashedItemSource"
import {$HotBarSlot, $HotBarSlot$Type} from "packages/mekanism/common/inventory/container/slot/$HotBarSlot"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$QIOCraftingWindow, $QIOCraftingWindow$Type} from "packages/mekanism/common/content/qio/$QIOCraftingWindow"

export class $QIOCraftingTransferHelper {
readonly "reverseLookup": $Map<($HashedItem), ($QIOCraftingTransferHelper$HashedItemSource)>

constructor(cachedInventory: $Object2LongMap$Type<($HashedItem$UUIDAwareHashedItem$Type)>, hotBarSlots: $List$Type<($HotBarSlot$Type)>, mainInventorySlots: $List$Type<($MainInventorySlot$Type)>, craftingWindow: $QIOCraftingWindow$Type, player: $Player$Type)

public "isInvalid"(): boolean
public "getSource"(item: $HashedItem$Type): $QIOCraftingTransferHelper$HashedItemSource
public "getEmptyInventorySlots"(): byte
get "invalid"(): boolean
get "emptyInventorySlots"(): byte
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOCraftingTransferHelper$Type = ($QIOCraftingTransferHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOCraftingTransferHelper_ = $QIOCraftingTransferHelper$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/chemical/$ISlurryTile" {
import {$SlurryStack, $SlurryStack$Type} from "packages/mekanism/api/chemical/slurry/$SlurryStack"
import {$ISlurryTracker, $ISlurryTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$ISlurryTracker"
import {$Slurry, $Slurry$Type} from "packages/mekanism/api/chemical/slurry/$Slurry"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ChemicalHandlerManager$SlurryHandlerManager, $ChemicalHandlerManager$SlurryHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager$SlurryHandlerManager"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$IChemicalTankHolder, $IChemicalTankHolder$Type} from "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder"
import {$ISlurryTank, $ISlurryTank$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryTank"

export interface $ISlurryTile extends $ISlurryTracker {

 "getInitialSlurryManager"(listener: $IContentsListener$Type): $ChemicalHandlerManager$SlurryHandlerManager
 "getInitialSlurryTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($Slurry), ($SlurryStack), ($ISlurryTank)>
 "extractSlurryCheck"(tank: integer, side: $Direction$Type): boolean
 "insertSlurryCheck"(tank: integer, side: $Direction$Type): boolean
 "getSlurryManager"(): $ChemicalHandlerManager$SlurryHandlerManager
 "getSlurryTanks"(side: $Direction$Type): $List<($ISlurryTank)>
 "canHandleSlurry"(): boolean
 "onContentsChanged"(): void
}

export namespace $ISlurryTile {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISlurryTile$Type = ($ISlurryTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISlurryTile_ = $ISlurryTile$Type;
}}
declare module "packages/mekanism/common/block/basic/$BlockBin" {
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockTile, $BlockTile$Type} from "packages/mekanism/common/block/prefab/$BlockTile"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$TileEntityBin, $TileEntityBin$Type} from "packages/mekanism/common/tile/$TileEntityBin"

export class $BlockBin extends $BlockTile<($TileEntityBin), ($BlockTypeTile<($TileEntityBin)>)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(type: $BlockTypeTile$Type<($TileEntityBin$Type)>, propertiesModifier: $UnaryOperator$Type<($BlockBehaviour$Properties$Type)>)

/**
 * 
 * @deprecated
 */
public "use"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
/**
 * 
 * @deprecated
 */
public "attack"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBin$Type = ($BlockBin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBin_ = $BlockBin$Type;
}}
declare module "packages/mekanism/common/item/$ItemConfigurator" {
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Lazy, $Lazy$Type} from "packages/net/minecraftforge/common/util/$Lazy"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$ItemEnergized, $ItemEnergized$Type} from "packages/mekanism/common/item/$ItemEnergized"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$IRadialEnumModeItem, $IRadialEnumModeItem$Type} from "packages/mekanism/common/lib/radial/$IRadialEnumModeItem"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$ItemConfigurator$ConfiguratorMode, $ItemConfigurator$ConfiguratorMode$Type} from "packages/mekanism/common/item/$ItemConfigurator$ConfiguratorMode"
import {$IRadialMode, $IRadialMode$Type} from "packages/mekanism/api/radial/mode/$IRadialMode"
import {$RadialData, $RadialData$Type} from "packages/mekanism/api/radial/$RadialData"
import {$IItemHUDProvider, $IItemHUDProvider$Type} from "packages/mekanism/common/item/interfaces/$IItemHUDProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemConfigurator extends $ItemEnergized implements $IRadialEnumModeItem<($ItemConfigurator$ConfiguratorMode)>, $IItemHUDProvider {
static readonly "LAZY_RADIAL_DATA": $Lazy<($RadialData<($ItemConfigurator$ConfiguratorMode)>)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "getName"(stack: $ItemStack$Type): $Component
public "doesSneakBypassUse"(stack: $ItemStack$Type, world: $LevelReader$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "getScrollTextComponent"(stack: $ItemStack$Type): $Component
public "getModeSaveKey"(): string
public "getRadialData"(stack: $ItemStack$Type): $RadialData<($ItemConfigurator$ConfiguratorMode)>
public "addHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): void
public "getModeByIndex"(ordinal: integer): $ItemConfigurator$ConfiguratorMode
public "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
public "setMode"(stack: $ItemStack$Type, player: $Player$Type, mode: $ItemConfigurator$ConfiguratorMode$Type): void
public "addCurioHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type): void
public "setMode"<M extends $IRadialMode>(stack: $ItemStack$Type, player: $Player$Type, radialData: $RadialData$Type<(M)>, mode: M): void
public "getMode"<M extends $IRadialMode>(stack: $ItemStack$Type, radialData: $RadialData$Type<(M)>): M
public "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "displayModeChange"(player: $Player$Type): void
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
get "modeSaveKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemConfigurator$Type = ($ItemConfigurator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemConfigurator_ = $ItemConfigurator$Type;
}}
declare module "packages/mekanism/common/inventory/slot/$CraftingWindowOutputInventorySlot" {
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingWindowInventorySlot, $CraftingWindowInventorySlot$Type} from "packages/mekanism/common/inventory/slot/$CraftingWindowInventorySlot"
import {$QIOCraftingWindow, $QIOCraftingWindow$Type} from "packages/mekanism/common/content/qio/$QIOCraftingWindow"

export class $CraftingWindowOutputInventorySlot extends $CraftingWindowInventorySlot {
static readonly "alwaysTrue": $Predicate<($ItemStack)>
static readonly "alwaysFalse": $Predicate<($ItemStack)>
static readonly "alwaysTrueBi": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "DEFAULT_LIMIT": integer


public static "create"(window: $QIOCraftingWindow$Type): $CraftingWindowOutputInventorySlot
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingWindowOutputInventorySlot$Type = ($CraftingWindowOutputInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingWindowOutputInventorySlot_ = $CraftingWindowOutputInventorySlot$Type;
}}
declare module "packages/mekanism/common/tile/$TileEntityLogisticalSorter" {
import {$SidedBlockPos, $SidedBlockPos$Type} from "packages/mekanism/common/lib/$SidedBlockPos"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ITileFilterHolder, $ITileFilterHolder$Type} from "packages/mekanism/common/tile/interfaces/$ITileFilterHolder"
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest$TransitResponse"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$TransitRequest, $TransitRequest$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$SorterFilter, $SorterFilter$Type} from "packages/mekanism/common/content/transporter/$SorterFilter"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ISustainedData, $ISustainedData$Type} from "packages/mekanism/common/tile/interfaces/$ISustainedData"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TileEntityLogisticalSorter extends $TileEntityMekanism implements $ISustainedData, $ITileFilterHolder<($SorterFilter<(any)>)> {
 "color": $EnumColor
 "rrTarget": $SidedBlockPos
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "load"(nbt: $CompoundTag$Type): void
public "m_183515_"(nbtTags: $CompoundTag$Type): void
public "addContainerTrackers"(container: $MekanismContainer$Type): void
public "toggleAutoEject"(): void
public "getAutoEject"(): boolean
public "changeColor"(color: $EnumColor$Type): void
public "getRedstoneLevel"(): integer
public "getCurrentRedstoneLevel"(): integer
public "readSustainedData"(dataMap: $CompoundTag$Type): void
public "writeSustainedData"(dataMap: $CompoundTag$Type): void
public "canPulse"(): boolean
public "getTileDataRemap"(): $Map<(string), (string)>
public "hasConnectedInventory"(): boolean
public "sendHome"(request: $TransitRequest$Type): $TransitRequest$TransitResponse
public "canSendHome"(stack: $ItemStack$Type): boolean
public "toggleSingleItem"(): void
public "toggleRoundRobin"(): void
public "getSingleItem"(): boolean
public "getRoundRobin"(): boolean
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "autoEject"(): boolean
get "redstoneLevel"(): integer
get "currentRedstoneLevel"(): integer
get "tileDataRemap"(): $Map<(string), (string)>
get "singleItem"(): boolean
get "roundRobin"(): boolean
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityLogisticalSorter$Type = ($TileEntityLogisticalSorter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityLogisticalSorter_ = $TileEntityLogisticalSorter$Type;
}}
declare module "packages/mekanism/common/integration/computer/$BoundMethodHolder" {
import {$BaseComputerHelper, $BaseComputerHelper$Type} from "packages/mekanism/common/integration/computer/$BaseComputerHelper"
import {$BoundMethodHolder$BoundMethodData, $BoundMethodHolder$BoundMethodData$Type} from "packages/mekanism/common/integration/computer/$BoundMethodHolder$BoundMethodData"
import {$MethodData, $MethodData$Type} from "packages/mekanism/common/integration/computer/$MethodData"
import {$ListMultimap, $ListMultimap$Type} from "packages/com/google/common/collect/$ListMultimap"
import {$WeakReference, $WeakReference$Type} from "packages/java/lang/ref/$WeakReference"

export class $BoundMethodHolder {


public "register"<T>(method: $MethodData$Type<(T)>, subject: $WeakReference$Type<(T)>, isHelpMethod: boolean): void
public static "generateHelp"(methods: $ListMultimap$Type<(string), ($BoundMethodHolder$BoundMethodData$Type<(any)>)>, helper: $BaseComputerHelper$Type): any
public static "generateHelpSpecific"(methods: $ListMultimap$Type<(string), ($BoundMethodHolder$BoundMethodData$Type<(any)>)>, helper: $BaseComputerHelper$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoundMethodHolder$Type = ($BoundMethodHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoundMethodHolder_ = $BoundMethodHolder$Type;
}}
declare module "packages/mekanism/common/integration/computer/$MethodData$Builder" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MethodData, $MethodData$Type} from "packages/mekanism/common/integration/computer/$MethodData"
import {$MethodRestriction, $MethodRestriction$Type} from "packages/mekanism/common/integration/computer/$MethodRestriction"

export class $MethodData$Builder<T> {


public "returnType"(returnType: $Class$Type<(any)>): $MethodData$Builder<(T)>
public "arguments"(argumentNames: (string)[], argClasses: ($Class$Type<(any)>)[]): $MethodData$Builder<(T)>
public "methodDescription"(methodDescription: string): $MethodData$Builder<(T)>
public "restriction"(restriction: $MethodRestriction$Type): $MethodData$Builder<(T)>
public "requiresPublicSecurity"(): $MethodData$Builder<(T)>
public "requiredMods"(...requiredMods: (string)[]): $MethodData$Builder<(T)>
public "threadSafe"(): $MethodData$Builder<(T)>
public "returnExtra"(...returnExtra: ($Class$Type<(any)>)[]): $MethodData$Builder<(T)>
public "build"(): $MethodData<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodData$Builder$Type<T> = ($MethodData$Builder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodData$Builder_<T> = $MethodData$Builder$Type<(T)>;
}}
declare module "packages/mekanism/common/$MekanismLang" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ILangEntry, $ILangEntry$Type} from "packages/mekanism/api/text/$ILangEntry"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"
import {$TextColor, $TextColor$Type} from "packages/net/minecraft/network/chat/$TextColor"

export class $MekanismLang extends $Enum<($MekanismLang)> implements $ILangEntry {
static readonly "REPAIR_COST": $MekanismLang
static readonly "REPAIR_EXPENSIVE": $MekanismLang
static readonly "MEKANISM": $MekanismLang
static readonly "DEBUG_TITLE": $MekanismLang
static readonly "LOG_FORMAT": $MekanismLang
static readonly "PACK_DESCRIPTION": $MekanismLang
static readonly "FORGE": $MekanismLang
static readonly "IC2": $MekanismLang
static readonly "ERROR": $MekanismLang
static readonly "ALPHA_WARNING": $MekanismLang
static readonly "ALPHA_WARNING_HERE": $MekanismLang
static readonly "HEAD": $MekanismLang
static readonly "BODY": $MekanismLang
static readonly "LEGS": $MekanismLang
static readonly "FEET": $MekanismLang
static readonly "MAINHAND": $MekanismLang
static readonly "OFFHAND": $MekanismLang
static readonly "NORTH_SHORT": $MekanismLang
static readonly "SOUTH_SHORT": $MekanismLang
static readonly "WEST_SHORT": $MekanismLang
static readonly "EAST_SHORT": $MekanismLang
static readonly "MULTIBLOCK_INVALID_FRAME": $MekanismLang
static readonly "MULTIBLOCK_INVALID_INNER": $MekanismLang
static readonly "MULTIBLOCK_INVALID_CONTROLLER_CONFLICT": $MekanismLang
static readonly "MULTIBLOCK_INVALID_NO_CONTROLLER": $MekanismLang
static readonly "SPS": $MekanismLang
static readonly "SPS_INVALID_DISCONNECTED_COIL": $MekanismLang
static readonly "SPS_PORT_MODE": $MekanismLang
static readonly "SPS_ENERGY_INPUT": $MekanismLang
static readonly "BOILER_INVALID_AIR_POCKETS": $MekanismLang
static readonly "BOILER_INVALID_EXTRA_DISPERSER": $MekanismLang
static readonly "BOILER_INVALID_MISSING_DISPERSER": $MekanismLang
static readonly "BOILER_INVALID_NO_DISPERSER": $MekanismLang
static readonly "BOILER_INVALID_SUPERHEATING": $MekanismLang
static readonly "CONVERSION_ENERGY": $MekanismLang
static readonly "CONVERSION_GAS": $MekanismLang
static readonly "CONVERSION_INFUSION": $MekanismLang
static readonly "SET_FREQUENCY": $MekanismLang
static readonly "QIO_FREQUENCY_SELECT": $MekanismLang
static readonly "QIO_ITEMS_DETAIL": $MekanismLang
static readonly "QIO_TYPES_DETAIL": $MekanismLang
static readonly "QIO_ITEMS": $MekanismLang
static readonly "QIO_TYPES": $MekanismLang
static readonly "QIO_TRIGGER_COUNT": $MekanismLang
static readonly "QIO_STORED_COUNT": $MekanismLang
static readonly "QIO_FUZZY_MODE": $MekanismLang
static readonly "QIO_ITEM_TYPE_UNDEFINED": $MekanismLang
static readonly "QIO_IMPORT_WITHOUT_FILTER": $MekanismLang
static readonly "QIO_EXPORT_WITHOUT_FILTER": $MekanismLang
static readonly "QIO_COMPENSATE_TOOLTIP": $MekanismLang
static readonly "LIST_SORT_COUNT": $MekanismLang
static readonly "LIST_SORT_NAME": $MekanismLang
static readonly "LIST_SORT_MOD": $MekanismLang
static readonly "LIST_SORT_NAME_DESC": $MekanismLang
static readonly "LIST_SORT_COUNT_DESC": $MekanismLang
static readonly "LIST_SORT_MOD_DESC": $MekanismLang
static readonly "LIST_SORT_ASCENDING_DESC": $MekanismLang
static readonly "LIST_SORT_DESCENDING_DESC": $MekanismLang
static readonly "LIST_SEARCH": $MekanismLang
static readonly "LIST_SORT": $MekanismLang
static readonly "JEI_AMOUNT_WITH_CAPACITY": $MekanismLang
static readonly "JEI_INFO_HEAVY_WATER": $MekanismLang
static readonly "JEI_INFO_MODULE_INSTALLATION": $MekanismLang
static readonly "JEI_MISSING_ITEMS": $MekanismLang
static readonly "JEI_INVENTORY_FULL": $MekanismLang
static readonly "JEI_RECIPE_ID": $MekanismLang
static readonly "KEY_HAND_MODE": $MekanismLang
static readonly "KEY_HEAD_MODE": $MekanismLang
static readonly "KEY_CHEST_MODE": $MekanismLang
static readonly "KEY_LEGS_MODE": $MekanismLang
static readonly "KEY_FEET_MODE": $MekanismLang
static readonly "KEY_DETAILS_MODE": $MekanismLang
static readonly "KEY_DESCRIPTION_MODE": $MekanismLang
static readonly "KEY_MODULE_TWEAKER": $MekanismLang
static readonly "KEY_BOOST": $MekanismLang
static readonly "KEY_HUD": $MekanismLang
static readonly "HOLIDAY_BORDER": $MekanismLang
static readonly "HOLIDAY_SIGNATURE": $MekanismLang
static readonly "CHRISTMAS_LINE_ONE": $MekanismLang
static readonly "CHRISTMAS_LINE_TWO": $MekanismLang
static readonly "CHRISTMAS_LINE_THREE": $MekanismLang
static readonly "CHRISTMAS_LINE_FOUR": $MekanismLang
static readonly "NEW_YEAR_LINE_ONE": $MekanismLang
static readonly "NEW_YEAR_LINE_TWO": $MekanismLang
static readonly "NEW_YEAR_LINE_THREE": $MekanismLang
static readonly "MAY_4_LINE_ONE": $MekanismLang
static readonly "GENERIC_PERCENT": $MekanismLang
static readonly "GENERIC_WITH_COMMA": $MekanismLang
static readonly "GENERIC_STORED": $MekanismLang
static readonly "GENERIC_STORED_MB": $MekanismLang
static readonly "GENERIC_MB": $MekanismLang
static readonly "GENERIC_PRE_COLON": $MekanismLang
static readonly "GENERIC_SQUARE_BRACKET": $MekanismLang
static readonly "GENERIC_PARENTHESIS": $MekanismLang
static readonly "GENERIC_WITH_PARENTHESIS": $MekanismLang
static readonly "GENERIC_FRACTION": $MekanismLang
static readonly "GENERIC_TRANSFER": $MekanismLang
static readonly "GENERIC_PER_TICK": $MekanismLang
static readonly "GENERIC_PER_MB": $MekanismLang
static readonly "GENERIC_PRE_STORED": $MekanismLang
static readonly "GENERIC_BLOCK_POS": $MekanismLang
static readonly "GENERIC_HEX": $MekanismLang
static readonly "GENERIC_LIST": $MekanismLang
static readonly "GENERIC_MINUTES": $MekanismLang
static readonly "GENERIC_HOURS_MINUTES": $MekanismLang
static readonly "HOLD_FOR_DETAILS": $MekanismLang
static readonly "HOLD_FOR_DESCRIPTION": $MekanismLang
static readonly "HOLD_FOR_MODULES": $MekanismLang
static readonly "HOLD_FOR_SUPPORTED_ITEMS": $MekanismLang
static readonly "COMMAND_CHUNK_WATCH": $MekanismLang
static readonly "COMMAND_CHUNK_UNWATCH": $MekanismLang
static readonly "COMMAND_CHUNK_CLEAR": $MekanismLang
static readonly "COMMAND_CHUNK_FLUSH": $MekanismLang
static readonly "COMMAND_CHUNK_LOADED": $MekanismLang
static readonly "COMMAND_CHUNK_UNLOADED": $MekanismLang
static readonly "COMMAND_DEBUG": $MekanismLang
static readonly "COMMAND_TEST_RULES": $MekanismLang
static readonly "COMMAND_TP": $MekanismLang
static readonly "COMMAND_TPOP": $MekanismLang
static readonly "COMMAND_ERROR_TPOP_EMPTY": $MekanismLang
static readonly "COMMAND_BUILD_REMOVED": $MekanismLang
static readonly "COMMAND_BUILD_BUILT": $MekanismLang
static readonly "COMMAND_BUILD_BUILT_EMPTY": $MekanismLang
static readonly "COMMAND_ERROR_BUILD_MISS": $MekanismLang
static readonly "COMMAND_RADIATION_ADD": $MekanismLang
static readonly "COMMAND_RADIATION_ADD_ENTITY": $MekanismLang
static readonly "COMMAND_RADIATION_ADD_ENTITY_TARGET": $MekanismLang
static readonly "COMMAND_RADIATION_GET": $MekanismLang
static readonly "COMMAND_RADIATION_CLEAR": $MekanismLang
static readonly "COMMAND_RADIATION_CLEAR_ENTITY": $MekanismLang
static readonly "COMMAND_RADIATION_REDUCE": $MekanismLang
static readonly "COMMAND_RADIATION_REDUCE_TARGET": $MekanismLang
static readonly "COMMAND_RADIATION_REMOVE_ALL": $MekanismLang
static readonly "COMMAND_RETROGEN_CHUNK_QUEUED": $MekanismLang
static readonly "COMMAND_ERROR_RETROGEN_DISABLED": $MekanismLang
static readonly "COMMAND_ERROR_RETROGEN_FAILURE": $MekanismLang
static readonly "TRANSMISSION_TYPE_ENERGY": $MekanismLang
static readonly "TRANSMISSION_TYPE_FLUID": $MekanismLang
static readonly "TRANSMISSION_TYPE_GAS": $MekanismLang
static readonly "TRANSMISSION_TYPE_INFUSION": $MekanismLang
static readonly "TRANSMISSION_TYPE_PIGMENT": $MekanismLang
static readonly "TRANSMISSION_TYPE_SLURRY": $MekanismLang
static readonly "TRANSMISSION_TYPE_ITEM": $MekanismLang
static readonly "TRANSMISSION_TYPE_HEAT": $MekanismLang
static readonly "MODE": $MekanismLang
static readonly "FIRE_MODE": $MekanismLang
static readonly "BUCKET_MODE": $MekanismLang
static readonly "STORED_ENERGY": $MekanismLang
static readonly "STORED": $MekanismLang
static readonly "STORED_MB_PERCENTAGE": $MekanismLang
static readonly "ITEM_AMOUNT": $MekanismLang
static readonly "LOCKED": $MekanismLang
static readonly "FLOWING": $MekanismLang
static readonly "INVALID": $MekanismLang
static readonly "HAS_INVENTORY": $MekanismLang
static readonly "NO_GAS": $MekanismLang
static readonly "NO_FLUID_TOOLTIP": $MekanismLang
static readonly "FREE_RUNNERS_MODE": $MekanismLang
static readonly "JETPACK_MODE": $MekanismLang
static readonly "SCUBA_TANK_MODE": $MekanismLang
static readonly "FREE_RUNNERS_STORED": $MekanismLang
static readonly "FLAMETHROWER_STORED": $MekanismLang
static readonly "JETPACK_STORED": $MekanismLang
static readonly "DECAY_IMMUNE": $MekanismLang
static readonly "HEIGHT": $MekanismLang
static readonly "WIDTH": $MekanismLang
static readonly "BACK": $MekanismLang
static readonly "CRAFTING_TAB": $MekanismLang
static readonly "CRAFTING_WINDOW": $MekanismLang
static readonly "CRAFTING_WINDOW_CLEAR": $MekanismLang
static readonly "PROGRESS": $MekanismLang
static readonly "PROCESS_RATE": $MekanismLang
static readonly "PROCESS_RATE_MB": $MekanismLang
static readonly "TICKS_REQUIRED": $MekanismLang
static readonly "MIN": $MekanismLang
static readonly "MAX": $MekanismLang
static readonly "INFINITE": $MekanismLang
static readonly "NONE": $MekanismLang
static readonly "EMPTY": $MekanismLang
static readonly "MAX_OUTPUT": $MekanismLang
static readonly "STORING": $MekanismLang
static readonly "DISSIPATED_RATE": $MekanismLang
static readonly "TRANSFERRED_RATE": $MekanismLang
static readonly "FUEL": $MekanismLang
static readonly "VOLUME": $MekanismLang
static readonly "NO_FLUID": $MekanismLang
static readonly "CHEMICAL": $MekanismLang
static readonly "GAS": $MekanismLang
static readonly "INFUSE_TYPE": $MekanismLang
static readonly "PIGMENT": $MekanismLang
static readonly "SLURRY": $MekanismLang
static readonly "LIQUID": $MekanismLang
static readonly "UNIT": $MekanismLang
static readonly "USING": $MekanismLang
static readonly "NEEDED": $MekanismLang
static readonly "NEEDED_PER_TICK": $MekanismLang
static readonly "FINISHED": $MekanismLang
static readonly "NO_RECIPE": $MekanismLang
static readonly "EJECT": $MekanismLang
static readonly "NO_DELAY": $MekanismLang
static readonly "DELAY": $MekanismLang
static readonly "ENERGY": $MekanismLang
static readonly "RESISTIVE_HEATER_USAGE": $MekanismLang
static readonly "DYNAMIC_TANK": $MekanismLang
static readonly "MOVE_UP": $MekanismLang
static readonly "MOVE_DOWN": $MekanismLang
static readonly "MOVE_TO_TOP": $MekanismLang
static readonly "MOVE_TO_BOTTOM": $MekanismLang
static readonly "SET": $MekanismLang
static readonly "TRUE": $MekanismLang
static readonly "FALSE": $MekanismLang
static readonly "CLOSE": $MekanismLang
static readonly "RADIATION_DOSE": $MekanismLang
static readonly "RADIATION_EXPOSURE": $MekanismLang
static readonly "RADIATION_EXPOSURE_ENTITY": $MekanismLang
static readonly "RADIATION_DECAY_TIME": $MekanismLang
static readonly "COLOR_PICKER": $MekanismLang
static readonly "RGB": $MekanismLang
static readonly "RGBA": $MekanismLang
static readonly "HELMET_OPTIONS": $MekanismLang
static readonly "HUD_OVERLAY": $MekanismLang
static readonly "OPACITY": $MekanismLang
static readonly "DEFAULT": $MekanismLang
static readonly "WARNING": $MekanismLang
static readonly "DANGER": $MekanismLang
static readonly "COMPASS": $MekanismLang
static readonly "RADIAL_SCREEN": $MekanismLang
static readonly "VISUALS": $MekanismLang
static readonly "VISUALS_TOO_BIG": $MekanismLang
static readonly "ISSUES": $MekanismLang
static readonly "ISSUE_NOT_ENOUGH_ENERGY": $MekanismLang
static readonly "ISSUE_NOT_ENOUGH_ENERGY_REDUCED_RATE": $MekanismLang
static readonly "ISSUE_NO_SPACE_IN_OUTPUT": $MekanismLang
static readonly "ISSUE_NO_SPACE_IN_OUTPUT_OVERFLOW": $MekanismLang
static readonly "ISSUE_NO_MATCHING_RECIPE": $MekanismLang
static readonly "ISSUE_INPUT_DOESNT_PRODUCE_OUTPUT": $MekanismLang
static readonly "ISSUE_INVALID_OREDICTIONIFICATOR_FILTER": $MekanismLang
static readonly "ISSUE_FILTER_HAS_BLACKLISTED_ELEMENT": $MekanismLang
static readonly "ENTITY_DETECTION": $MekanismLang
static readonly "ENERGY_CONTENTS": $MekanismLang
static readonly "REDSTONE_OUTPUT": $MekanismLang
static readonly "FREQUENCY": $MekanismLang
static readonly "NO_FREQUENCY": $MekanismLang
static readonly "FREQUENCY_DELETE_CONFIRM": $MekanismLang
static readonly "NOW_OWN": $MekanismLang
static readonly "OWNER": $MekanismLang
static readonly "NO_OWNER": $MekanismLang
static readonly "MAIN_TAB": $MekanismLang
static readonly "EVAPORATION_HEIGHT": $MekanismLang
static readonly "FLUID_PRODUCTION": $MekanismLang
static readonly "EVAPORATION_PLANT": $MekanismLang
static readonly "TRANSPORTER_CONFIG": $MekanismLang
static readonly "SIDE_CONFIG": $MekanismLang
static readonly "SIDE_CONFIG_CLEAR": $MekanismLang
static readonly "STRICT_INPUT": $MekanismLang
static readonly "STRICT_INPUT_ENABLED": $MekanismLang
static readonly "CONFIG_TYPE": $MekanismLang
static readonly "NO_EJECT": $MekanismLang
static readonly "CANT_EJECT_TOOLTIP": $MekanismLang
static readonly "SLOTS": $MekanismLang
static readonly "AUTO_PULL": $MekanismLang
static readonly "AUTO_EJECT": $MekanismLang
static readonly "AUTO_SORT": $MekanismLang
static readonly "IDLE": $MekanismLang
static readonly "DUMPING_EXCESS": $MekanismLang
static readonly "DUMPING": $MekanismLang
static readonly "DICTIONARY_KEY": $MekanismLang
static readonly "DICTIONARY_NO_KEY": $MekanismLang
static readonly "DICTIONARY_BLOCK_TAGS_FOUND": $MekanismLang
static readonly "DICTIONARY_FLUID_TAGS_FOUND": $MekanismLang
static readonly "DICTIONARY_ENTITY_TYPE_TAGS_FOUND": $MekanismLang
static readonly "DICTIONARY_BLOCK_ENTITY_TYPE_TAGS_FOUND": $MekanismLang
static readonly "DICTIONARY_TAG_TYPE": $MekanismLang
static readonly "DICTIONARY_ITEM": $MekanismLang
static readonly "DICTIONARY_ITEM_DESC": $MekanismLang
static readonly "DICTIONARY_BLOCK": $MekanismLang
static readonly "DICTIONARY_BLOCK_DESC": $MekanismLang
static readonly "DICTIONARY_FLUID": $MekanismLang
static readonly "DICTIONARY_FLUID_DESC": $MekanismLang
static readonly "DICTIONARY_ENTITY_TYPE": $MekanismLang
static readonly "DICTIONARY_ENTITY_TYPE_DESC": $MekanismLang
static readonly "DICTIONARY_ATTRIBUTE": $MekanismLang
static readonly "DICTIONARY_ATTRIBUTE_DESC": $MekanismLang
static readonly "DICTIONARY_POTION": $MekanismLang
static readonly "DICTIONARY_POTION_DESC": $MekanismLang
static readonly "DICTIONARY_MOB_EFFECT": $MekanismLang
static readonly "DICTIONARY_MOB_EFFECT_DESC": $MekanismLang
static readonly "DICTIONARY_ENCHANTMENT": $MekanismLang
static readonly "DICTIONARY_ENCHANTMENT_DESC": $MekanismLang
static readonly "DICTIONARY_BLOCK_ENTITY_TYPE": $MekanismLang
static readonly "DICTIONARY_BLOCK_ENTITY_TYPE_DESC": $MekanismLang
static readonly "DICTIONARY_GAS": $MekanismLang
static readonly "DICTIONARY_GAS_DESC": $MekanismLang
static readonly "DICTIONARY_INFUSE_TYPE": $MekanismLang
static readonly "DICTIONARY_INFUSE_TYPE_DESC": $MekanismLang
static readonly "DICTIONARY_PIGMENT": $MekanismLang
static readonly "DICTIONARY_PIGMENT_DESC": $MekanismLang
static readonly "DICTIONARY_SLURRY": $MekanismLang
static readonly "DICTIONARY_SLURRY_DESC": $MekanismLang
static readonly "LAST_ITEM": $MekanismLang
static readonly "NEXT_ITEM": $MekanismLang
static readonly "STABILIZER_CENTER": $MekanismLang
static readonly "STABILIZER_ENABLE_RADIUS": $MekanismLang
static readonly "STABILIZER_DISABLE_RADIUS": $MekanismLang
static readonly "STABILIZER_TOGGLE_LOADING": $MekanismLang
static readonly "STATUS": $MekanismLang
static readonly "STATUS_OK": $MekanismLang
static readonly "FLUID_CONTAINER_BOTH": $MekanismLang
static readonly "FLUID_CONTAINER_FILL": $MekanismLang
static readonly "FLUID_CONTAINER_EMPTY": $MekanismLang
static readonly "YES": $MekanismLang
static readonly "NO": $MekanismLang
static readonly "ON": $MekanismLang
static readonly "OFF": $MekanismLang
static readonly "INPUT": $MekanismLang
static readonly "OUTPUT": $MekanismLang
static readonly "ACTIVE": $MekanismLang
static readonly "DISABLED": $MekanismLang
static readonly "ON_CAPS": $MekanismLang
static readonly "OFF_CAPS": $MekanismLang
static readonly "CAPACITY": $MekanismLang
static readonly "CAPACITY_ITEMS": $MekanismLang
static readonly "CAPACITY_MB": $MekanismLang
static readonly "CAPACITY_PER_TICK": $MekanismLang
static readonly "CAPACITY_MB_PER_TICK": $MekanismLang
static readonly "BLOCK_DATA": $MekanismLang
static readonly "BLOCK": $MekanismLang
static readonly "BLOCK_ENTITY": $MekanismLang
static readonly "INGREDIENTS": $MekanismLang
static readonly "ENCODED": $MekanismLang
static readonly "MULTIBLOCK_INCOMPLETE": $MekanismLang
static readonly "MULTIBLOCK_FORMED": $MekanismLang
static readonly "MULTIBLOCK_CONFLICT": $MekanismLang
static readonly "MULTIBLOCK_FORMED_CHAT": $MekanismLang
static readonly "UNIVERSAL": $MekanismLang
static readonly "ITEMS": $MekanismLang
static readonly "BLOCKS": $MekanismLang
static readonly "FLUIDS": $MekanismLang
static readonly "GASES": $MekanismLang
static readonly "INFUSE_TYPES": $MekanismLang
static readonly "PIGMENTS": $MekanismLang
static readonly "SLURRIES": $MekanismLang
static readonly "HEAT": $MekanismLang
static readonly "CONDUCTION": $MekanismLang
static readonly "INSULATION": $MekanismLang
static readonly "HEAT_CAPACITY": $MekanismLang
static readonly "CAPABLE_OF_TRANSFERRING": $MekanismLang
static readonly "DIVERSION_CONTROL_DISABLED": $MekanismLang
static readonly "DIVERSION_CONTROL_HIGH": $MekanismLang
static readonly "DIVERSION_CONTROL_LOW": $MekanismLang
static readonly "TOGGLE_DIVERTER": $MekanismLang
static readonly "PUMP_RATE": $MekanismLang
static readonly "PUMP_RATE_MB": $MekanismLang
static readonly "SPEED": $MekanismLang
static readonly "CONDENSENTRATOR_TOGGLE": $MekanismLang
static readonly "CONDENSENTRATING": $MekanismLang
static readonly "DECONDENSENTRATING": $MekanismLang
static readonly "UPGRADE_DISPLAY_LEVEL": $MekanismLang
static readonly "UPGRADES_EFFECT": $MekanismLang
static readonly "UPGRADES": $MekanismLang
static readonly "UPGRADE_NO_SELECTION": $MekanismLang
static readonly "UPGRADES_SUPPORTED": $MekanismLang
static readonly "UPGRADE_COUNT": $MekanismLang
static readonly "UPGRADE_TYPE": $MekanismLang
static readonly "UPGRADE_NOT_SUPPORTED": $MekanismLang
static readonly "UPGRADE_UNINSTALL": $MekanismLang
static readonly "UPGRADE_UNINSTALL_TOOLTIP": $MekanismLang
static readonly "CREATE_FILTER_TITLE": $MekanismLang
static readonly "FILTERS": $MekanismLang
static readonly "FILTER_COUNT": $MekanismLang
static readonly "FILTER_ALLOW_DEFAULT": $MekanismLang
static readonly "FILTER": $MekanismLang
static readonly "FILTER_NEW": $MekanismLang
static readonly "FILTER_EDIT": $MekanismLang
static readonly "FILTER_STATE": $MekanismLang
static readonly "TEXT_FILTER_NO_MATCHES": $MekanismLang
static readonly "TAG_FILTER": $MekanismLang
static readonly "TAG_FILTER_NO_TAG": $MekanismLang
static readonly "TAG_FILTER_SAME_TAG": $MekanismLang
static readonly "TAG_FILTER_TAG": $MekanismLang
static readonly "MODID_FILTER": $MekanismLang
static readonly "MODID_FILTER_NO_ID": $MekanismLang
static readonly "MODID_FILTER_SAME_ID": $MekanismLang
static readonly "MODID_FILTER_ID": $MekanismLang
static readonly "ITEM_FILTER": $MekanismLang
static readonly "ITEM_FILTER_NO_ITEM": $MekanismLang
static readonly "FUZZY_MODE": $MekanismLang
static readonly "SORTER_SIZE_MODE": $MekanismLang
static readonly "SORTER_SIZE_MODE_CONFLICT": $MekanismLang
static readonly "SORTER_FILTER_SIZE_MODE": $MekanismLang
static readonly "SORTER_FILTER_MAX_LESS_THAN_MIN": $MekanismLang
static readonly "SORTER_FILTER_OVER_SIZED": $MekanismLang
static readonly "SORTER_FILTER_SIZE_MISSING": $MekanismLang
static readonly "OREDICTIONIFICATOR_FILTER": $MekanismLang
static readonly "OREDICTIONIFICATOR_FILTER_INVALID_NAMESPACE": $MekanismLang
static readonly "OREDICTIONIFICATOR_FILTER_INVALID_PATH": $MekanismLang
static readonly "OREDICTIONIFICATOR_FILTER_UNSUPPORTED_TAG": $MekanismLang
static readonly "WASTE_BARREL_DECAY_RATE": $MekanismLang
static readonly "WASTE_BARREL_DECAY_RATE_ACTUAL": $MekanismLang
static readonly "CHUNK": $MekanismLang
static readonly "VIBRATING": $MekanismLang
static readonly "NEEDS_ENERGY": $MekanismLang
static readonly "NO_VIBRATIONS": $MekanismLang
static readonly "ABUNDANCY": $MekanismLang
static readonly "REDSTONE_CONTROL_DISABLED": $MekanismLang
static readonly "REDSTONE_CONTROL_HIGH": $MekanismLang
static readonly "REDSTONE_CONTROL_LOW": $MekanismLang
static readonly "REDSTONE_CONTROL_PULSE": $MekanismLang
static readonly "SECURITY": $MekanismLang
static readonly "SECURITY_OVERRIDDEN": $MekanismLang
static readonly "SECURITY_OFFLINE": $MekanismLang
static readonly "SECURITY_ADD": $MekanismLang
static readonly "SECURITY_OVERRIDE": $MekanismLang
static readonly "NO_ACCESS": $MekanismLang
static readonly "TRUSTED_PLAYERS": $MekanismLang
static readonly "PUBLIC_MODE": $MekanismLang
static readonly "TRUSTED_MODE": $MekanismLang
static readonly "PRIVATE_MODE": $MekanismLang
static readonly "ENCODE_FORMULA": $MekanismLang
static readonly "CRAFT_SINGLE": $MekanismLang
static readonly "CRAFT_AVAILABLE": $MekanismLang
static readonly "EMPTY_ASSEMBLICATOR": $MekanismLang
static readonly "FILL_ASSEMBLICATOR": $MekanismLang
static readonly "STOCK_CONTROL": $MekanismLang
static readonly "AUTO_MODE": $MekanismLang
static readonly "FACTORY_TYPE": $MekanismLang
static readonly "NETWORK_DESCRIPTION": $MekanismLang
static readonly "INVENTORY_NETWORK": $MekanismLang
static readonly "FLUID_NETWORK": $MekanismLang
static readonly "CHEMICAL_NETWORK": $MekanismLang
static readonly "HEAT_NETWORK": $MekanismLang
static readonly "ENERGY_NETWORK": $MekanismLang
static readonly "NO_NETWORK": $MekanismLang
static readonly "HEAT_NETWORK_STORED": $MekanismLang
static readonly "HEAT_NETWORK_FLOW": $MekanismLang
static readonly "HEAT_NETWORK_FLOW_EFFICIENCY": $MekanismLang
static readonly "FLUID_NETWORK_NEEDED": $MekanismLang
static readonly "NETWORK_MB_PER_TICK": $MekanismLang
static readonly "NETWORK_MB_STORED": $MekanismLang
static readonly "BUTTON_CONFIRM": $MekanismLang
static readonly "BUTTON_START": $MekanismLang
static readonly "BUTTON_STOP": $MekanismLang
static readonly "BUTTON_CONFIG": $MekanismLang
static readonly "BUTTON_REMOVE": $MekanismLang
static readonly "BUTTON_CANCEL": $MekanismLang
static readonly "BUTTON_SAVE": $MekanismLang
static readonly "BUTTON_SET": $MekanismLang
static readonly "BUTTON_DELETE": $MekanismLang
static readonly "BUTTON_OPTIONS": $MekanismLang
static readonly "BUTTON_TELEPORT": $MekanismLang
static readonly "BUTTON_NEW_FILTER": $MekanismLang
static readonly "BUTTON_ITEMSTACK_FILTER": $MekanismLang
static readonly "BUTTON_TAG_FILTER": $MekanismLang
static readonly "BUTTON_MODID_FILTER": $MekanismLang
static readonly "CONFIG_CARD_GOT": $MekanismLang
static readonly "CONFIG_CARD_SET": $MekanismLang
static readonly "CONFIG_CARD_UNEQUAL": $MekanismLang
static readonly "CONFIG_CARD_HAS_DATA": $MekanismLang
static readonly "CONNECTION_NORMAL": $MekanismLang
static readonly "CONNECTION_PUSH": $MekanismLang
static readonly "CONNECTION_PULL": $MekanismLang
static readonly "CONNECTION_NONE": $MekanismLang
static readonly "TELEPORTER_READY": $MekanismLang
static readonly "TELEPORTER_NO_FRAME": $MekanismLang
static readonly "TELEPORTER_NO_LINK": $MekanismLang
static readonly "TELEPORTER_NEEDS_ENERGY": $MekanismLang
static readonly "MATRIX": $MekanismLang
static readonly "MATRIX_RECEIVING_RATE": $MekanismLang
static readonly "MATRIX_OUTPUT_AMOUNT": $MekanismLang
static readonly "MATRIX_OUTPUT_RATE": $MekanismLang
static readonly "MATRIX_OUTPUTTING_RATE": $MekanismLang
static readonly "MATRIX_INPUT_AMOUNT": $MekanismLang
static readonly "MATRIX_INPUT_RATE": $MekanismLang
static readonly "MATRIX_CONSTITUENTS": $MekanismLang
static readonly "MATRIX_DIMENSIONS": $MekanismLang
static readonly "MATRIX_DIMENSION_REPRESENTATION": $MekanismLang
static readonly "MATRIX_STATS": $MekanismLang
static readonly "MATRIX_CELLS": $MekanismLang
static readonly "MATRIX_PROVIDERS": $MekanismLang
static readonly "INDUCTION_PORT_MODE": $MekanismLang
static readonly "INDUCTION_PORT_OUTPUT_RATE": $MekanismLang
static readonly "MINER_INSUFFICIENT_BUFFER": $MekanismLang
static readonly "MINER_BUFFER_FREE": $MekanismLang
static readonly "MINER_TO_MINE": $MekanismLang
static readonly "MINER_SILK_ENABLED": $MekanismLang
static readonly "MINER_AUTO_PULL": $MekanismLang
static readonly "MINER_RUNNING": $MekanismLang
static readonly "MINER_LOW_POWER": $MekanismLang
static readonly "MINER_ENERGY_CAPACITY": $MekanismLang
static readonly "MINER_MISSING_BLOCK": $MekanismLang
static readonly "MINER_WELL": $MekanismLang
static readonly "MINER_CONFIG": $MekanismLang
static readonly "MINER_SILK": $MekanismLang
static readonly "MINER_RESET": $MekanismLang
static readonly "MINER_INVERSE": $MekanismLang
static readonly "MINER_REQUIRE_REPLACE": $MekanismLang
static readonly "MINER_REQUIRE_REPLACE_INVERSE": $MekanismLang
static readonly "MINER_RADIUS": $MekanismLang
static readonly "MINER_IDLE": $MekanismLang
static readonly "MINER_SEARCHING": $MekanismLang
static readonly "MINER_PAUSED": $MekanismLang
static readonly "MINER_READY": $MekanismLang
static readonly "BOILER": $MekanismLang
static readonly "BOILER_STATS": $MekanismLang
static readonly "BOILER_MAX_WATER": $MekanismLang
static readonly "BOILER_MAX_STEAM": $MekanismLang
static readonly "BOILER_HEAT_TRANSFER": $MekanismLang
static readonly "BOILER_HEATERS": $MekanismLang
static readonly "BOILER_CAPACITY": $MekanismLang
static readonly "BOIL_RATE": $MekanismLang
static readonly "MAX_BOIL_RATE": $MekanismLang
static readonly "BOILER_VALVE_MODE_CHANGE": $MekanismLang
static readonly "BOILER_VALVE_MODE_INPUT": $MekanismLang
static readonly "BOILER_VALVE_MODE_OUTPUT_STEAM": $MekanismLang
static readonly "BOILER_VALVE_MODE_OUTPUT_COOLANT": $MekanismLang
static readonly "BOILER_WATER_TANK": $MekanismLang
static readonly "BOILER_COOLANT_TANK": $MekanismLang
static readonly "BOILER_STEAM_TANK": $MekanismLang
static readonly "BOILER_HEATED_COOLANT_TANK": $MekanismLang
static readonly "TEMPERATURE": $MekanismLang
static readonly "TEMPERATURE_LONG": $MekanismLang
static readonly "TEMPERATURE_KELVIN": $MekanismLang
static readonly "TEMPERATURE_KELVIN_SHORT": $MekanismLang
static readonly "TEMPERATURE_CELSIUS": $MekanismLang
static readonly "TEMPERATURE_CELSIUS_SHORT": $MekanismLang
static readonly "TEMPERATURE_RANKINE": $MekanismLang
static readonly "TEMPERATURE_RANKINE_SHORT": $MekanismLang
static readonly "TEMPERATURE_FAHRENHEIT": $MekanismLang
static readonly "TEMPERATURE_FAHRENHEIT_SHORT": $MekanismLang
static readonly "TEMPERATURE_AMBIENT": $MekanismLang
static readonly "TEMPERATURE_AMBIENT_SHORT": $MekanismLang
static readonly "ENERGY_JOULES": $MekanismLang
static readonly "ENERGY_JOULES_PLURAL": $MekanismLang
static readonly "ENERGY_JOULES_SHORT": $MekanismLang
static readonly "ENERGY_FORGE": $MekanismLang
static readonly "ENERGY_FORGE_SHORT": $MekanismLang
static readonly "ENERGY_EU": $MekanismLang
static readonly "ENERGY_EU_PLURAL": $MekanismLang
static readonly "ENERGY_EU_SHORT": $MekanismLang
static readonly "NETWORK_READER_BORDER": $MekanismLang
static readonly "NETWORK_READER_TEMPERATURE": $MekanismLang
static readonly "NETWORK_READER_TRANSMITTERS": $MekanismLang
static readonly "NETWORK_READER_ACCEPTORS": $MekanismLang
static readonly "NETWORK_READER_NEEDED": $MekanismLang
static readonly "NETWORK_READER_BUFFER": $MekanismLang
static readonly "NETWORK_READER_THROUGHPUT": $MekanismLang
static readonly "NETWORK_READER_CAPACITY": $MekanismLang
static readonly "NETWORK_READER_CONNECTED_SIDES": $MekanismLang
static readonly "SORTER_DEFAULT": $MekanismLang
static readonly "SORTER_SINGLE_ITEM": $MekanismLang
static readonly "SORTER_ROUND_ROBIN": $MekanismLang
static readonly "SORTER_AUTO_EJECT": $MekanismLang
static readonly "SORTER_SINGLE_ITEM_DESCRIPTION": $MekanismLang
static readonly "SORTER_ROUND_ROBIN_DESCRIPTION": $MekanismLang
static readonly "SORTER_AUTO_EJECT_DESCRIPTION": $MekanismLang
static readonly "SIDE_DATA_NONE": $MekanismLang
static readonly "SIDE_DATA_INPUT": $MekanismLang
static readonly "SIDE_DATA_INPUT_1": $MekanismLang
static readonly "SIDE_DATA_INPUT_2": $MekanismLang
static readonly "SIDE_DATA_OUTPUT": $MekanismLang
static readonly "SIDE_DATA_OUTPUT_1": $MekanismLang
static readonly "SIDE_DATA_OUTPUT_2": $MekanismLang
static readonly "SIDE_DATA_INPUT_OUTPUT": $MekanismLang
static readonly "SIDE_DATA_ENERGY": $MekanismLang
static readonly "SIDE_DATA_EXTRA": $MekanismLang
static readonly "FREE_RUNNER_MODE_CHANGE": $MekanismLang
static readonly "FREE_RUNNER_NORMAL": $MekanismLang
static readonly "FREE_RUNNER_SAFETY": $MekanismLang
static readonly "FREE_RUNNER_DISABLED": $MekanismLang
static readonly "JETPACK_MODE_CHANGE": $MekanismLang
static readonly "JETPACK_NORMAL": $MekanismLang
static readonly "JETPACK_HOVER": $MekanismLang
static readonly "JETPACK_DISABLED": $MekanismLang
static readonly "DISASSEMBLER_MODE_CHANGE": $MekanismLang
static readonly "DISASSEMBLER_EFFICIENCY": $MekanismLang
static readonly "FLAMETHROWER_MODE_CHANGE": $MekanismLang
static readonly "FLAMETHROWER_COMBAT": $MekanismLang
static readonly "FLAMETHROWER_HEAT": $MekanismLang
static readonly "FLAMETHROWER_INFERNO": $MekanismLang
static readonly "CONFIGURE_STATE": $MekanismLang
static readonly "STATE": $MekanismLang
static readonly "TOGGLE_COLOR": $MekanismLang
static readonly "CURRENT_COLOR": $MekanismLang
static readonly "PUMP_RESET": $MekanismLang
static readonly "PLENISHER_RESET": $MekanismLang
static readonly "REDSTONE_SENSITIVITY": $MekanismLang
static readonly "CONNECTION_TYPE": $MekanismLang
static readonly "CONFIGURATOR_VIEW_MODE": $MekanismLang
static readonly "CONFIGURATOR_TOGGLE_MODE": $MekanismLang
static readonly "CONFIGURATOR_CONFIGURATE": $MekanismLang
static readonly "CONFIGURATOR_EMPTY": $MekanismLang
static readonly "CONFIGURATOR_ROTATE": $MekanismLang
static readonly "CONFIGURATOR_WRENCH": $MekanismLang
static readonly "ROBIT": $MekanismLang
static readonly "ROBIT_NAME": $MekanismLang
static readonly "ROBIT_SMELTING": $MekanismLang
static readonly "ROBIT_CRAFTING": $MekanismLang
static readonly "ROBIT_INVENTORY": $MekanismLang
static readonly "ROBIT_REPAIR": $MekanismLang
static readonly "ROBIT_TELEPORT": $MekanismLang
static readonly "ROBIT_TOGGLE_PICKUP": $MekanismLang
static readonly "ROBIT_RENAME": $MekanismLang
static readonly "ROBIT_SKIN": $MekanismLang
static readonly "ROBIT_SKIN_SELECT": $MekanismLang
static readonly "ROBIT_TOGGLE_FOLLOW": $MekanismLang
static readonly "ROBIT_GREETING": $MekanismLang
static readonly "ROBIT_OWNER": $MekanismLang
static readonly "ROBIT_FOLLOWING": $MekanismLang
static readonly "ROBIT_DROP_PICKUP": $MekanismLang
static readonly "DESCRIPTION_DICTIONARY": $MekanismLang
static readonly "DESCRIPTION_SEISMIC_READER": $MekanismLang
static readonly "DESCRIPTION_BIN": $MekanismLang
static readonly "DESCRIPTION_TELEPORTER_FRAME": $MekanismLang
static readonly "DESCRIPTION_STEEL_CASING": $MekanismLang
static readonly "DESCRIPTION_DYNAMIC_TANK": $MekanismLang
static readonly "DESCRIPTION_STRUCTURAL_GLASS": $MekanismLang
static readonly "DESCRIPTION_DYNAMIC_VALVE": $MekanismLang
static readonly "DESCRIPTION_THERMAL_EVAPORATION_CONTROLLER": $MekanismLang
static readonly "DESCRIPTION_THERMAL_EVAPORATION_VALVE": $MekanismLang
static readonly "DESCRIPTION_THERMAL_EVAPORATION_BLOCK": $MekanismLang
static readonly "DESCRIPTION_INDUCTION_CASING": $MekanismLang
static readonly "DESCRIPTION_INDUCTION_PORT": $MekanismLang
static readonly "DESCRIPTION_INDUCTION_CELL": $MekanismLang
static readonly "DESCRIPTION_INDUCTION_PROVIDER": $MekanismLang
static readonly "DESCRIPTION_SUPERHEATING_ELEMENT": $MekanismLang
static readonly "DESCRIPTION_PRESSURE_DISPERSER": $MekanismLang
static readonly "DESCRIPTION_BOILER_CASING": $MekanismLang
static readonly "DESCRIPTION_BOILER_VALVE": $MekanismLang
static readonly "DESCRIPTION_SECURITY_DESK": $MekanismLang
static readonly "DESCRIPTION_ENRICHMENT_CHAMBER": $MekanismLang
static readonly "DESCRIPTION_OSMIUM_COMPRESSOR": $MekanismLang
static readonly "DESCRIPTION_COMBINER": $MekanismLang
static readonly "DESCRIPTION_CRUSHER": $MekanismLang
static readonly "DESCRIPTION_DIGITAL_MINER": $MekanismLang
static readonly "DESCRIPTION_METALLURGIC_INFUSER": $MekanismLang
static readonly "DESCRIPTION_PURIFICATION_CHAMBER": $MekanismLang
static readonly "DESCRIPTION_ENERGIZED_SMELTER": $MekanismLang
static readonly "DESCRIPTION_TELEPORTER": $MekanismLang
static readonly "DESCRIPTION_ELECTRIC_PUMP": $MekanismLang
static readonly "DESCRIPTION_PERSONAL_BARREL": $MekanismLang
static readonly "DESCRIPTION_PERSONAL_CHEST": $MekanismLang
static readonly "DESCRIPTION_CHARGEPAD": $MekanismLang
static readonly "DESCRIPTION_LOGISTICAL_SORTER": $MekanismLang
static readonly "DESCRIPTION_ROTARY_CONDENSENTRATOR": $MekanismLang
static readonly "DESCRIPTION_CHEMICAL_INJECTION_CHAMBER": $MekanismLang
static readonly "DESCRIPTION_ELECTROLYTIC_SEPARATOR": $MekanismLang
static readonly "DESCRIPTION_PRECISION_SAWMILL": $MekanismLang
static readonly "DESCRIPTION_CHEMICAL_DISSOLUTION_CHAMBER": $MekanismLang
static readonly "DESCRIPTION_CHEMICAL_WASHER": $MekanismLang
static readonly "DESCRIPTION_CHEMICAL_CRYSTALLIZER": $MekanismLang
static readonly "DESCRIPTION_CHEMICAL_OXIDIZER": $MekanismLang
static readonly "DESCRIPTION_CHEMICAL_INFUSER": $MekanismLang
static readonly "DESCRIPTION_SEISMIC_VIBRATOR": $MekanismLang
static readonly "DESCRIPTION_PRESSURIZED_REACTION_CHAMBER": $MekanismLang
static readonly "DESCRIPTION_FLUID_TANK": $MekanismLang
static readonly "DESCRIPTION_FLUIDIC_PLENISHER": $MekanismLang
static readonly "DESCRIPTION_LASER": $MekanismLang
static readonly "DESCRIPTION_LASER_AMPLIFIER": $MekanismLang
static readonly "DESCRIPTION_LASER_TRACTOR_BEAM": $MekanismLang
static readonly "DESCRIPTION_SOLAR_NEUTRON_ACTIVATOR": $MekanismLang
static readonly "DESCRIPTION_OREDICTIONIFICATOR": $MekanismLang
static readonly "DESCRIPTION_FACTORY": $MekanismLang
static readonly "DESCRIPTION_RESISTIVE_HEATER": $MekanismLang
static readonly "DESCRIPTION_FORMULAIC_ASSEMBLICATOR": $MekanismLang
static readonly "DESCRIPTION_FUELWOOD_HEATER": $MekanismLang
static readonly "DESCRIPTION_MODIFICATION_STATION": $MekanismLang
static readonly "DESCRIPTION_ISOTOPIC_CENTRIFUGE": $MekanismLang
static readonly "DESCRIPTION_QUANTUM_ENTANGLOPORTER": $MekanismLang
static readonly "DESCRIPTION_NUTRITIONAL_LIQUIFIER": $MekanismLang
static readonly "DESCRIPTION_ANTIPROTONIC_NUCLEOSYNTHESIZER": $MekanismLang
static readonly "DESCRIPTION_PIGMENT_EXTRACTOR": $MekanismLang
static readonly "DESCRIPTION_PIGMENT_MIXER": $MekanismLang
static readonly "DESCRIPTION_PAINTING_MACHINE": $MekanismLang
static readonly "DESCRIPTION_QIO_DRIVE_ARRAY": $MekanismLang
static readonly "DESCRIPTION_QIO_DASHBOARD": $MekanismLang
static readonly "DESCRIPTION_QIO_IMPORTER": $MekanismLang
static readonly "DESCRIPTION_QIO_EXPORTER": $MekanismLang
static readonly "DESCRIPTION_QIO_REDSTONE_ADAPTER": $MekanismLang
static readonly "DESCRIPTION_RADIOACTIVE_WASTE_BARREL": $MekanismLang
static readonly "DESCRIPTION_INDUSTRIAL_ALARM": $MekanismLang
static readonly "DESCRIPTION_ENERGY_CUBE": $MekanismLang
static readonly "DESCRIPTION_CHEMICAL_TANK": $MekanismLang
static readonly "DESCRIPTION_DIVERSION": $MekanismLang
static readonly "DESCRIPTION_RESTRICTIVE": $MekanismLang
static readonly "DESCRIPTION_SPS_CASING": $MekanismLang
static readonly "DESCRIPTION_SPS_PORT": $MekanismLang
static readonly "DESCRIPTION_SUPERCHARGED_COIL": $MekanismLang
static readonly "DESCRIPTION_DIMENSIONAL_STABILIZER": $MekanismLang
static readonly "SMELTING": $MekanismLang
static readonly "ENRICHING": $MekanismLang
static readonly "CRUSHING": $MekanismLang
static readonly "COMPRESSING": $MekanismLang
static readonly "COMBINING": $MekanismLang
static readonly "PURIFYING": $MekanismLang
static readonly "INJECTING": $MekanismLang
static readonly "INFUSING": $MekanismLang
static readonly "SAWING": $MekanismLang
static readonly "RADIAL_VEIN": $MekanismLang
static readonly "RADIAL_VEIN_NORMAL": $MekanismLang
static readonly "RADIAL_VEIN_EXTENDED": $MekanismLang
static readonly "RADIAL_EXCAVATION_SPEED": $MekanismLang
static readonly "RADIAL_EXCAVATION_SPEED_OFF": $MekanismLang
static readonly "RADIAL_EXCAVATION_SPEED_SLOW": $MekanismLang
static readonly "RADIAL_EXCAVATION_SPEED_NORMAL": $MekanismLang
static readonly "RADIAL_EXCAVATION_SPEED_FAST": $MekanismLang
static readonly "RADIAL_EXCAVATION_SPEED_SUPER": $MekanismLang
static readonly "RADIAL_EXCAVATION_SPEED_EXTREME": $MekanismLang
static readonly "RADIAL_BLASTING_POWER": $MekanismLang
static readonly "RADIAL_BLASTING_POWER_OFF": $MekanismLang
static readonly "RADIAL_BLASTING_POWER_LOW": $MekanismLang
static readonly "RADIAL_BLASTING_POWER_MED": $MekanismLang
static readonly "RADIAL_BLASTING_POWER_HIGH": $MekanismLang
static readonly "RADIAL_BLASTING_POWER_EXTREME": $MekanismLang
static readonly "MODULE_ENABLED": $MekanismLang
static readonly "MODULE_ENABLED_LOWER": $MekanismLang
static readonly "MODULE_DISABLED_LOWER": $MekanismLang
static readonly "MODULE_DAMAGE": $MekanismLang
static readonly "MODULE_TWEAKER": $MekanismLang
static readonly "MODULE_INSTALLED": $MekanismLang
static readonly "MODULE_SUPPORTED": $MekanismLang
static readonly "MODULE_CONFLICTING": $MekanismLang
static readonly "MODULE_STACKABLE": $MekanismLang
static readonly "MODULE_EXCLUSIVE": $MekanismLang
static readonly "MODULE_HANDLE_MODE_CHANGE": $MekanismLang
static readonly "MODULE_RENDER_HUD": $MekanismLang
static readonly "MODULE_MODE": $MekanismLang
static readonly "MODULE_COLOR": $MekanismLang
static readonly "MODULE_BONUS_ATTACK_DAMAGE": $MekanismLang
static readonly "MODULE_FARMING_RADIUS": $MekanismLang
static readonly "MODULE_JUMP_BOOST": $MekanismLang
static readonly "MODULE_STEP_ASSIST": $MekanismLang
static readonly "MODULE_RANGE": $MekanismLang
static readonly "MODULE_SPRINT_BOOST": $MekanismLang
static readonly "MODULE_SWIM_BOOST": $MekanismLang
static readonly "MODULE_EXTENDED_MODE": $MekanismLang
static readonly "MODULE_EXTENDED_ENABLED": $MekanismLang
static readonly "MODULE_EXCAVATION_RANGE": $MekanismLang
static readonly "MODULE_BLAST_RADIUS": $MekanismLang
static readonly "MODULE_BLASTING_ENABLED": $MekanismLang
static readonly "MODULE_BLAST_AREA": $MekanismLang
static readonly "MODULE_EFFICIENCY": $MekanismLang
static readonly "MODULE_BREATHING_HELD": $MekanismLang
static readonly "MODULE_JETPACK_MODE": $MekanismLang
static readonly "MODULE_GRAVITATIONAL_MODULATION": $MekanismLang
static readonly "MODULE_MAGNETIC_ATTRACTION": $MekanismLang
static readonly "MODULE_MODE_CHANGE": $MekanismLang
static readonly "MODULE_CHARGE_SUIT": $MekanismLang
static readonly "MODULE_CHARGE_INVENTORY": $MekanismLang
static readonly "MODULE_SPEED_BOOST": $MekanismLang
static readonly "MODULE_VISION_ENHANCEMENT": $MekanismLang
static readonly "MODULE_PURIFICATION_BENEFICIAL": $MekanismLang
static readonly "MODULE_PURIFICATION_NEUTRAL": $MekanismLang
static readonly "MODULE_PURIFICATION_HARMFUL": $MekanismLang
static readonly "MODULE_TELEPORT_REQUIRES_BLOCK": $MekanismLang


public static "get"(type: $EquipmentSlot$Type): $MekanismLang
public static "values"(): ($MekanismLang)[]
public static "valueOf"(name: string): $MekanismLang
public "getTranslationKey"(): string
public "translate"(...arg0: (any)[]): $MutableComponent
public "translateColored"(arg0: $EnumColor$Type, ...arg1: (any)[]): $MutableComponent
public "translateColored"(arg0: $TextColor$Type, ...arg1: (any)[]): $MutableComponent
get "translationKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismLang$Type = (("dictionary_mob_effect_desc") | ("temperature_long") | ("configurator_rotate") | ("module_purification_beneficial") | ("radial_excavation_speed_slow") | ("boiler_max_water") | ("description_logistical_sorter") | ("text_filter_no_matches") | ("radial_blasting_power") | ("north_short") | ("filter_allow_default") | ("no_recipe") | ("button_tag_filter") | ("transmission_type_fluid") | ("dictionary_no_key") | ("command_build_removed") | ("button_start") | ("generic_with_parenthesis") | ("legs") | ("needs_energy") | ("compressing") | ("flamethrower_combat") | ("description_factory") | ("generic_transfer") | ("energy") | ("robit_smelting") | ("description_qio_drive_array") | ("robit_teleport") | ("block_entity") | ("current_color") | ("matrix_input_rate") | ("heat_network_stored") | ("description_pressure_disperser") | ("active") | ("free_runner_safety") | ("command_chunk_flush") | ("temperature_ambient") | ("delay") | ("chemical") | ("miner_ready") | ("transmission_type_slurry") | ("matrix_output_amount") | ("description_antiprotonic_nucleosynthesizer") | ("fluid_container_empty") | ("sorter_size_mode") | ("robit_skin_select") | ("description_restrictive") | ("button_itemstack_filter") | ("module_mode_change") | ("boiler_heated_coolant_tank") | ("matrix_dimension_representation") | ("description_crusher") | ("alpha_warning") | ("infinite") | ("connection_push") | ("stabilizer_center") | ("condensentrating") | ("item_filter") | ("command_radiation_reduce_target") | ("matrix") | ("disassembler_efficiency") | ("qio_import_without_filter") | ("module_extended_enabled") | ("description_formulaic_assemblicator") | ("radiation_decay_time") | ("sps_port_mode") | ("christmas_line_one") | ("next_item") | ("conduction") | ("miner_reset") | ("radial_excavation_speed_off") | ("module_vision_enhancement") | ("close") | ("qio_items_detail") | ("smelting") | ("diversion_control_high") | ("module_jetpack_mode") | ("command_error_retrogen_disabled") | ("description_thermal_evaporation_controller") | ("set") | ("dictionary_slurry") | ("connection_type") | ("connection_none") | ("radial_vein_normal") | ("security_offline") | ("command_chunk_clear") | ("description_laser") | ("multiblock_incomplete") | ("module_enabled_lower") | ("christmas_line_two") | ("description_laser_tractor_beam") | ("boiler_coolant_tank") | ("may_4_line_one") | ("description_superheating_element") | ("radial_blasting_power_low") | ("side_data_input") | ("flamethrower_inferno") | ("opacity") | ("key_hud") | ("max_output") | ("dictionary_enchantment_desc") | ("trusted_mode") | ("fluid_container_both") | ("empty_assemblicator") | ("description_bin") | ("description_chargepad") | ("miner_insufficient_buffer") | ("side_data_output") | ("module_color") | ("empty") | ("generic_stored") | ("miner_radius") | ("stabilizer_enable_radius") | ("command_radiation_get") | ("dictionary_pigment_desc") | ("key_module_tweaker") | ("warning") | ("boiler_heat_transfer") | ("robit_rename") | ("multiblock_invalid_no_controller") | ("connection_pull") | ("injecting") | ("upgrade_uninstall_tooltip") | ("filter_edit") | ("sorter_auto_eject_description") | ("gases") | ("robit_toggle_pickup") | ("dictionary_gas_desc") | ("dictionary_block_tags_found") | ("alpha_warning_here") | ("multiblock_invalid_frame") | ("volume") | ("button_config") | ("button_set") | ("slots") | ("module_disabled_lower") | ("command_radiation_clear_entity") | ("module_bonus_attack_damage") | ("dictionary_slurry_desc") | ("configurator_view_mode") | ("description_nutritional_liquifier") | ("temperature_kelvin_short") | ("upgrade_no_selection") | ("description_supercharged_coil") | ("block_data") | ("module_blast_radius") | ("boiler_max_steam") | ("temperature_fahrenheit") | ("hold_for_description") | ("list_sort_ascending_desc") | ("description_chemical_infuser") | ("miner_missing_block") | ("dissipated_rate") | ("robit_repair") | ("upgrade_uninstall") | ("fill_assemblicator") | ("energy_eu") | ("upgrades_supported") | ("dictionary_block") | ("toggle_diverter") | ("back") | ("rgb") | ("no_frequency") | ("induction_port_output_rate") | ("radial_excavation_speed") | ("boiler_valve_mode_change") | ("module_jump_boost") | ("pump_rate_mb") | ("temperature_celsius_short") | ("has_inventory") | ("owner") | ("fire_mode") | ("pigments") | ("blocks") | ("last_item") | ("false") | ("toggle_color") | ("flamethrower_mode_change") | ("jei_amount_with_capacity") | ("oredictionificator_filter") | ("miner_silk") | ("conversion_infusion") | ("miner_config") | ("tag_filter_tag") | ("module_stackable") | ("list_sort_mod") | ("issue_input_doesnt_produce_output") | ("rgba") | ("side_data_input_1") | ("no_access") | ("transmission_type_item") | ("generic_fraction") | ("description_pigment_mixer") | ("generic_parenthesis") | ("command_error_tpop_empty") | ("matrix_constituents") | ("description_enrichment_chamber") | ("upgrades") | ("holiday_signature") | ("network_mb_per_tick") | ("description_resistive_heater") | ("output") | ("eject") | ("description_dictionary") | ("dictionary_entity_type_tags_found") | ("dictionary_tag_type") | ("set_frequency") | ("sorter_filter_size_missing") | ("item_amount") | ("block") | ("miner_energy_capacity") | ("slurry") | ("description_qio_exporter") | ("side_data_input_2") | ("description_rotary_condensentrator") | ("description_dynamic_valve") | ("auto_sort") | ("issue_not_enough_energy_reduced_rate") | ("jetpack_disabled") | ("qio_stored_count") | ("sorter_single_item") | ("auto_mode") | ("abundancy") | ("key_feet_mode") | ("radiation_exposure_entity") | ("energy_joules_short") | ("invalid") | ("issue_no_space_in_output") | ("key_boost") | ("matrix_input_amount") | ("generic_stored_mb") | ("generic_hex") | ("dictionary_fluid_desc") | ("status") | ("encoded") | ("energy_joules_plural") | ("temperature_celsius") | ("conversion_energy") | ("matrix_cells") | ("holiday_border") | ("boiler_invalid_superheating") | ("button_modid_filter") | ("chemical_network") | ("network_reader_throughput") | ("needed_per_tick") | ("command_tpop") | ("button_save") | ("generic_hours_minutes") | ("command_tp") | ("side_data_extra") | ("description_structural_glass") | ("list_sort_name_desc") | ("qio_types_detail") | ("sorter_round_robin_description") | ("radial_excavation_speed_super") | ("boiler_invalid_no_disperser") | ("description_personal_chest") | ("evaporation_plant") | ("infuse_types") | ("max") | ("flamethrower_stored") | ("teleporter_no_frame") | ("jetpack_normal") | ("description_chemical_tank") | ("diversion_control_low") | ("dictionary_gas") | ("description_induction_provider") | ("off") | ("energy_joules") | ("boil_rate") | ("vibrating") | ("evaporation_height") | ("heat_network") | ("miner_idle") | ("stored") | ("transmission_type_infusion") | ("energy_eu_short") | ("private_mode") | ("module_charge_suit") | ("transmission_type_gas") | ("miner_low_power") | ("transmission_type_pigment") | ("feet") | ("module_range") | ("configure_state") | ("description_digital_miner") | ("fuel") | ("description_pigment_extractor") | ("south_short") | ("description_chemical_washer") | ("side_data_input_output") | ("qio_types") | ("description_isotopic_centrifuge") | ("body") | ("now_own") | ("miner_paused") | ("mode") | ("jetpack_stored") | ("modid_filter_id") | ("module_render_hud") | ("module_purification_harmful") | ("visuals_too_big") | ("cant_eject_tooltip") | ("locked") | ("module_excavation_range") | ("command_debug") | ("side_config_clear") | ("enriching") | ("command_retrogen_chunk_queued") | ("modid_filter") | ("matrix_outputting_rate") | ("miner_searching") | ("jei_missing_items") | ("module_damage") | ("flowing") | ("capacity_mb_per_tick") | ("hud_overlay") | ("no_owner") | ("on_caps") | ("slurries") | ("unit") | ("heat_capacity") | ("compass") | ("encode_formula") | ("module_breathing_held") | ("sps") | ("true") | ("network_reader_capacity") | ("jei_recipe_id") | ("move_to_bottom") | ("dictionary_item") | ("heat") | ("description_induction_port") | ("key_hand_mode") | ("no") | ("fuzzy_mode") | ("description_quantum_entangloporter") | ("radial_excavation_speed_normal") | ("module_teleport_requires_block") | ("sps_invalid_disconnected_coil") | ("radial_blasting_power_high") | ("config_card_unequal") | ("miner_inverse") | ("head") | ("no_fluid_tooltip") | ("network_mb_stored") | ("issue_not_enough_energy") | ("sorter_round_robin") | ("module_blast_area") | ("status_ok") | ("free_runner_mode_change") | ("west_short") | ("repair_expensive") | ("generic_minutes") | ("strict_input_enabled") | ("auto_pull") | ("energy_forge") | ("button_confirm") | ("universal") | ("energy_eu_plural") | ("boiler_water_tank") | ("command_radiation_add") | ("on") | ("dictionary_pigment") | ("upgrade_count") | ("free_runner_disabled") | ("radiation_exposure") | ("dictionary_key") | ("description_diversion") | ("description_personal_barrel") | ("process_rate_mb") | ("offhand") | ("capacity_per_tick") | ("command_chunk_watch") | ("flamethrower_heat") | ("dictionary_entity_type") | ("description_teleporter_frame") | ("dictionary_enchantment") | ("modid_filter_same_id") | ("energy_forge_short") | ("free_runner_normal") | ("redstone_sensitivity") | ("danger") | ("boiler_valve_mode_input") | ("description_precision_sawmill") | ("key_chest_mode") | ("tag_filter_same_tag") | ("infuse_type") | ("scuba_tank_mode") | ("no_network") | ("state") | ("radial_blasting_power_off") | ("height") | ("temperature_rankine") | ("mainhand") | ("using") | ("configurator_wrench") | ("description_seismic_vibrator") | ("public_mode") | ("pump_rate") | ("upgrade_not_supported") | ("pigment") | ("sps_energy_input") | ("description_security_desk") | ("input") | ("qio_frequency_select") | ("module_exclusive") | ("items") | ("generic_pre_colon") | ("command_radiation_reduce") | ("bucket_mode") | ("dynamic_tank") | ("command_error_build_miss") | ("item_filter_no_item") | ("description_boiler_valve") | ("oredictionificator_filter_invalid_namespace") | ("repair_cost") | ("description_energy_cube") | ("fluid_network") | ("network_reader_connected_sides") | ("side_data_none") | ("default") | ("min") | ("dictionary_block_entity_type") | ("generic_list") | ("matrix_dimensions") | ("temperature") | ("ic2") | ("ingredients") | ("disabled") | ("description_dimensional_stabilizer") | ("matrix_stats") | ("generic_mb") | ("description_industrial_alarm") | ("qio_trigger_count") | ("boiler_valve_mode_output_coolant") | ("transmission_type_heat") | ("matrix_providers") | ("capacity_mb") | ("off_caps") | ("description_chemical_dissolution_chamber") | ("create_filter_title") | ("miner_well") | ("sorter_filter_max_less_than_min") | ("combining") | ("description_qio_redstone_adapter") | ("generic_percent") | ("multiblock_formed_chat") | ("list_sort_name") | ("heat_network_flow_efficiency") | ("description_qio_dashboard") | ("module_magnetic_attraction") | ("crafting_window_clear") | ("button_new_filter") | ("progress") | ("module_gravitational_modulation") | ("modid_filter_no_id") | ("command_error_retrogen_failure") | ("dictionary_block_desc") | ("process_rate") | ("fluid_container_fill") | ("matrix_receiving_rate") | ("new_year_line_one") | ("tag_filter_no_tag") | ("description_thermal_evaporation_block") | ("jei_info_module_installation") | ("multiblock_invalid_controller_conflict") | ("sorter_default") | ("command_build_built") | ("multiblock_formed") | ("module_installed") | ("frequency") | ("radial_vein") | ("induction_port_mode") | ("stored_energy") | ("dictionary_attribute") | ("auto_eject") | ("matrix_output_rate") | ("sawing") | ("radial_blasting_power_extreme") | ("mekanism") | ("description_seismic_reader") | ("decay_immune") | ("frequency_delete_confirm") | ("capable_of_transferring") | ("filter_state") | ("new_year_line_two") | ("side_data_energy") | ("generic_block_pos") | ("generic_per_tick") | ("no_eject") | ("list_search") | ("factory_type") | ("dumping") | ("no_gas") | ("color_picker") | ("hold_for_details") | ("list_sort_count") | ("hold_for_modules") | ("module_enabled") | ("no_vibrations") | ("button_options") | ("command_radiation_add_entity") | ("description_sps_casing") | ("jetpack_mode_change") | ("boiler_invalid_missing_disperser") | ("temperature_rankine_short") | ("forge") | ("module_charge_inventory") | ("description_induction_casing") | ("dictionary_mob_effect") | ("upgrades_effect") | ("radial_blasting_power_med") | ("issue_no_space_in_output_overflow") | ("configurator_toggle_mode") | ("radial_vein_extended") | ("needed") | ("oredictionificator_filter_invalid_path") | ("module_blasting_enabled") | ("description_electrolytic_separator") | ("boiler_valve_mode_output_steam") | ("robit_skin") | ("generic_square_bracket") | ("waste_barrel_decay_rate") | ("speed") | ("miner_to_mine") | ("debug_title") | ("list_sort_descending_desc") | ("module_step_assist") | ("gas") | ("dictionary_infuse_type") | ("robit_inventory") | ("button_teleport") | ("dictionary_block_entity_type_tags_found") | ("module_sprint_boost") | ("button_delete") | ("temperature_ambient_short") | ("description_induction_cell") | ("dictionary_entity_type_desc") | ("list_sort_count_desc") | ("helmet_options") | ("key_head_mode") | ("visuals") | ("yes") | ("module_conflicting") | ("filters") | ("radial_screen") | ("configurator_configurate") | ("storing") | ("qio_export_without_filter") | ("command_test_rules") | ("generic_per_mb") | ("miner_auto_pull") | ("key_description_mode") | ("network_reader_transmitters") | ("entity_detection") | ("hold_for_supported_items") | ("stored_mb_percentage") | ("description_thermal_evaporation_valve") | ("boiler_invalid_air_pockets") | ("description_dynamic_tank") | ("issue_no_matching_recipe") | ("configurator_empty") | ("teleporter_no_link") | ("christmas_line_three") | ("energy_contents") | ("transferred_rate") | ("description_fluidic_plenisher") | ("none") | ("issues") | ("description_qio_importer") | ("description_osmium_compressor") | ("temperature_fahrenheit_short") | ("command_radiation_clear") | ("module_tweaker") | ("security_add") | ("generic_with_comma") | ("diversion_control_disabled") | ("craft_single") | ("side_data_output_2") | ("side_data_output_1") | ("sorter_size_mode_conflict") | ("temperature_kelvin") | ("description_steel_casing") | ("module_swim_boost") | ("config_type") | ("boiler_steam_tank") | ("resistive_heater_usage") | ("inventory_network") | ("description_modification_station") | ("qio_item_type_undefined") | ("command_radiation_remove_all") | ("filter_new") | ("pump_reset") | ("upgrade_type") | ("miner_silk_enabled") | ("description_laser_amplifier") | ("heat_network_flow") | ("conversion_gas") | ("new_year_line_three") | ("ticks_required") | ("trusted_players") | ("description_chemical_crystallizer") | ("side_config") | ("module_efficiency") | ("filter_count") | ("network_description") | ("crafting_tab") | ("description_electric_pump") | ("module_farming_radius") | ("log_format") | ("oredictionificator_filter_unsupported_tag") | ("redstone_control_pulse") | ("description_oredictionificator") | ("craft_available") | ("crafting_window") | ("dictionary_fluid") | ("redstone_output") | ("disassembler_mode_change") | ("network_reader_needed") | ("pack_description") | ("radial_excavation_speed_extreme") | ("no_fluid") | ("capacity") | ("config_card_set") | ("transporter_config") | ("description_solar_neutron_activator") | ("command_build_built_empty") | ("module_mode") | ("boiler") | ("redstone_control_disabled") | ("dictionary_fluid_tags_found") | ("button_remove") | ("command_radiation_add_entity_target") | ("robit_drop_pickup") | ("description_pressurized_reaction_chamber") | ("miner_buffer_free") | ("dictionary_block_entity_type_desc") | ("network_reader_buffer") | ("robit_owner") | ("config_card_got") | ("energy_network") | ("strict_input") | ("filter") | ("security_override") | ("dictionary_potion") | ("dictionary_potion_desc") | ("robit_crafting") | ("module_handle_mode_change") | ("liquid") | ("sorter_auto_eject") | ("width") | ("description_purification_chamber") | ("upgrade_display_level") | ("waste_barrel_decay_rate_actual") | ("crushing") | ("robit_toggle_follow") | ("sorter_single_item_description") | ("sorter_filter_over_sized") | ("security_overridden") | ("description_metallurgic_infuser") | ("jei_info_heavy_water") | ("main_tab") | ("description_combiner") | ("miner_require_replace") | ("description_painting_machine") | ("dumping_excess") | ("jetpack_hover") | ("stabilizer_toggle_loading") | ("boiler_stats") | ("condensentrator_toggle") | ("boiler_heaters") | ("list_sort") | ("network_reader_border") | ("key_details_mode") | ("qio_compensate_tooltip") | ("module_supported") | ("generic_pre_stored") | ("multiblock_conflict") | ("issue_invalid_oredictionificator_filter") | ("qio_fuzzy_mode") | ("miner_running") | ("radiation_dose") | ("redstone_control_low") | ("robit_greeting") | ("radial_excavation_speed_fast") | ("qio_items") | ("christmas_line_four") | ("free_runners_stored") | ("description_teleporter") | ("finished") | ("key_legs_mode") | ("miner_require_replace_inverse") | ("insulation") | ("robit_following") | ("description_fuelwood_heater") | ("east_short") | ("network_reader_temperature") | ("teleporter_needs_energy") | ("description_energized_smelter") | ("infusing") | ("boiler_invalid_extra_disperser") | ("button_cancel") | ("fluid_network_needed") | ("description_sps_port") | ("config_card_has_data") | ("description_chemical_oxidizer") | ("redstone_control_high") | ("command_chunk_unloaded") | ("description_boiler_casing") | ("fluid_production") | ("chunk") | ("robit") | ("module_purification_neutral") | ("decondensentrating") | ("error") | ("capacity_items") | ("sorter_filter_size_mode") | ("button_stop") | ("jei_inventory_full") | ("teleporter_ready") | ("description_radioactive_waste_barrel") | ("purifying") | ("issue_filter_has_blacklisted_element") | ("security") | ("move_up") | ("module_speed_boost") | ("command_chunk_unwatch") | ("robit_name") | ("multiblock_invalid_inner") | ("dictionary_attribute_desc") | ("stabilizer_disable_radius") | ("fluids") | ("dictionary_item_desc") | ("idle") | ("connection_normal") | ("free_runners_mode") | ("command_chunk_loaded") | ("no_delay") | ("description_chemical_injection_chamber") | ("plenisher_reset") | ("list_sort_mod_desc") | ("transmission_type_energy") | ("jetpack_mode") | ("module_extended_mode") | ("network_reader_acceptors") | ("description_fluid_tank") | ("move_down") | ("dictionary_infuse_type_desc") | ("stock_control") | ("max_boil_rate") | ("move_to_top") | ("tag_filter") | ("boiler_capacity")) | ($MekanismLang);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismLang_ = $MekanismLang$Type;
}}
declare module "packages/mekanism/common/capabilities/energy/$BasicEnergyContainer" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IEnergyContainer, $IEnergyContainer$Type} from "packages/mekanism/api/energy/$IEnergyContainer"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"

export class $BasicEnergyContainer implements $IEnergyContainer {
static readonly "alwaysTrue": $Predicate<($AutomationType)>
static readonly "alwaysFalse": $Predicate<($AutomationType)>
static readonly "internalOnly": $Predicate<($AutomationType)>
static readonly "manualOnly": $Predicate<($AutomationType)>
static readonly "notExternal": $Predicate<($AutomationType)>


public "extract"(amount: $FloatingLong$Type, action: $Action$Type, automationType: $AutomationType$Type): $FloatingLong
public "insert"(amount: $FloatingLong$Type, action: $Action$Type, automationType: $AutomationType$Type): $FloatingLong
public "isEmpty"(): boolean
public static "create"(maxEnergy: $FloatingLong$Type, listener: $IContentsListener$Type): $BasicEnergyContainer
public static "create"(maxEnergy: $FloatingLong$Type, canExtract: $Predicate$Type<($AutomationType$Type)>, canInsert: $Predicate$Type<($AutomationType$Type)>, listener: $IContentsListener$Type): $BasicEnergyContainer
public static "input"(maxEnergy: $FloatingLong$Type, listener: $IContentsListener$Type): $BasicEnergyContainer
public static "output"(maxEnergy: $FloatingLong$Type, listener: $IContentsListener$Type): $BasicEnergyContainer
public "onContentsChanged"(): void
public "getEnergy"(): $FloatingLong
public "setEnergy"(energy: $FloatingLong$Type): void
public "deserializeNBT"(nbt: $CompoundTag$Type): void
public "getMaxEnergy"(): $FloatingLong
public "setEmpty"(): void
public "getNeeded"(): $FloatingLong
get "empty"(): boolean
get "energy"(): $FloatingLong
set "energy"(value: $FloatingLong$Type)
get "maxEnergy"(): $FloatingLong
get "needed"(): $FloatingLong
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicEnergyContainer$Type = ($BasicEnergyContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicEnergyContainer_ = $BasicEnergyContainer$Type;
}}
declare module "packages/mekanism/common/integration/computer/$MethodHelpData$Returns" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MethodData, $MethodData$Type} from "packages/mekanism/common/integration/computer/$MethodData"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $MethodHelpData$Returns extends $Record {
static readonly "NOTHING": $MethodHelpData$Returns
static readonly "CODEC": $Codec<($MethodHelpData$Returns)>

constructor(type: string, javaType: $Class$Type<(any)>, javaExtra: ($Class$Type<(any)>)[])
constructor(type: string, javaType: $Class$Type<(any)>, javaExtra: ($Class$Type<(any)>)[], values: $List$Type<(string)>)

public "type"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "values"(): $List<(string)>
public "hashCode"(): integer
public static "from"(data: $MethodData$Type<(any)>): $MethodHelpData$Returns
public "javaType"(): $Class<(any)>
public "javaExtra"(): ($Class<(any)>)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodHelpData$Returns$Type = ($MethodHelpData$Returns);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodHelpData$Returns_ = $MethodHelpData$Returns$Type;
}}
declare module "packages/mekanism/common/lib/attribute/$IAttributeRefresher" {
import {$ImmutableMultimap$Builder, $ImmutableMultimap$Builder$Type} from "packages/com/google/common/collect/$ImmutableMultimap$Builder"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"

export interface $IAttributeRefresher {

 "addToBuilder"(builder: $ImmutableMultimap$Builder$Type<($Attribute$Type), ($AttributeModifier$Type)>): void

(builder: $ImmutableMultimap$Builder$Type<($Attribute$Type), ($AttributeModifier$Type)>): void
}

export namespace $IAttributeRefresher {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAttributeRefresher$Type = ($IAttributeRefresher);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IAttributeRefresher_ = $IAttributeRefresher$Type;
}}
declare module "packages/mekanism/common/lib/inventory/$TransitRequest$ItemData" {
import {$HashedItem, $HashedItem$Type} from "packages/mekanism/common/lib/inventory/$HashedItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TransitRequest$ItemData {

constructor(itemType: $HashedItem$Type)

public "equals"(o: any): boolean
public "hashCode"(): integer
public "getStack"(): $ItemStack
public "use"(amount: integer): $ItemStack
public "getTotalCount"(): integer
public "getItemType"(): $HashedItem
get "stack"(): $ItemStack
get "totalCount"(): integer
get "itemType"(): $HashedItem
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransitRequest$ItemData$Type = ($TransitRequest$ItemData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransitRequest$ItemData_ = $TransitRequest$ItemData$Type;
}}
declare module "packages/mekanism/common/registration/impl/$RecipeTypeRegistryObject" {
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IMekanismRecipeTypeProvider, $IMekanismRecipeTypeProvider$Type} from "packages/mekanism/common/recipe/$IMekanismRecipeTypeProvider"
import {$WrappedRegistryObject, $WrappedRegistryObject$Type} from "packages/mekanism/common/registration/$WrappedRegistryObject"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MekanismRecipeType, $MekanismRecipeType$Type} from "packages/mekanism/common/recipe/$MekanismRecipeType"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IInputRecipeCache, $IInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$IInputRecipeCache"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"

export class $RecipeTypeRegistryObject<RECIPE extends $MekanismRecipe, INPUT_CACHE extends $IInputRecipeCache> extends $WrappedRegistryObject<($MekanismRecipeType<(RECIPE), (INPUT_CACHE)>)> implements $IMekanismRecipeTypeProvider<(RECIPE), (INPUT_CACHE)> {

constructor(registryObject: $RegistryObject$Type<($MekanismRecipeType$Type<(RECIPE), (INPUT_CACHE)>)>)

public "getRecipeType"(): $MekanismRecipeType<(RECIPE), (INPUT_CACHE)>
public "stream"(world: $Level$Type): $Stream<(RECIPE)>
public "contains"(world: $Level$Type, matchCriteria: $Predicate$Type<(RECIPE)>): boolean
public "findFirst"(world: $Level$Type, matchCriteria: $Predicate$Type<(RECIPE)>): RECIPE
public "getRegistryName"(): $ResourceLocation
public "getInputCache"(): INPUT_CACHE
public "getRecipes"(world: $Level$Type): $List<(RECIPE)>
get "recipeType"(): $MekanismRecipeType<(RECIPE), (INPUT_CACHE)>
get "registryName"(): $ResourceLocation
get "inputCache"(): INPUT_CACHE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeTypeRegistryObject$Type<RECIPE, INPUT_CACHE> = ($RecipeTypeRegistryObject<(RECIPE), (INPUT_CACHE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeTypeRegistryObject_<RECIPE, INPUT_CACHE> = $RecipeTypeRegistryObject$Type<(RECIPE), (INPUT_CACHE)>;
}}
declare module "packages/mekanism/common/item/gear/$ItemScubaMask" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemSpecialArmor, $ItemSpecialArmor$Type} from "packages/mekanism/common/item/gear/$ItemSpecialArmor"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$DispenseItemBehavior, $DispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DispenseItemBehavior"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemScubaMask extends $ItemSpecialArmor {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "initializeClient"(consumer: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "getDefaultTooltipHideFlags"(stack: $ItemStack$Type): integer
public static "get"(arg0: $ItemStack$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemScubaMask$Type = ($ItemScubaMask);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemScubaMask_ = $ItemScubaMask$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$ITileFilterHolder" {
import {$FilterManager, $FilterManager$Type} from "packages/mekanism/common/content/filter/$FilterManager"
import {$IFilter, $IFilter$Type} from "packages/mekanism/common/content/filter/$IFilter"

export interface $ITileFilterHolder<FILTER extends $IFilter<(any)>> {

 "getFilterManager"(): $FilterManager<(FILTER)>

(): $FilterManager<(FILTER)>
}

export namespace $ITileFilterHolder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileFilterHolder$Type<FILTER> = ($ITileFilterHolder<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileFilterHolder_<FILTER> = $ITileFilterHolder$Type<(FILTER)>;
}}
declare module "packages/mekanism/common/lib/$Color" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Color {
static readonly "WHITE": $Color
static readonly "BLACK": $Color


public "equals"(obj: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "blend"(to: $Color$Type, scale: double): $Color
public static "blend"(src: $Color$Type, dest: $Color$Type): $Color
public "b"(): integer
public "ad"(): double
public "a"(): integer
public "rd"(): double
public "g"(): integer
public "gf"(): float
public "r"(): integer
public "rf"(): float
public "alpha"(alpha: double): $Color
public "gd"(): double
public "bd"(): double
public "rgbArray"(): (integer)[]
public static "rgb"(color: (integer)[]): $Color
public static "rgb"(color: integer): $Color
public "rgb"(): integer
public "rgba"(): integer
public static "rgba"(color: integer): $Color
public static "rgba"(color: (integer)[]): $Color
public static "argb"(color: (integer)[]): $Color
public "argb"(): integer
public static "argb"(color: integer): $Color
public "hsvArray"(): (double)[]
public static "hsv"(h: double, s: double, v: double): $Color
public static "argbd"(a: double, r: double, g: double, b: double): $Color
public static "argbi"(a: integer, r: integer, g: integer, b: integer): $Color
public static "rgbai"(r: integer, g: integer, b: integer, a: integer): $Color
public static "rgbi"(r: integer, g: integer, b: integer): $Color
public static "argbToFromABGR"(argb: integer): integer
public static "packOpaque"(rgb: integer): integer
public "darken"(amount: double): $Color
public static "rgbd"(r: double, g: double, b: double): $Color
public "argbArray"(): (integer)[]
public "rgbaArray"(): (integer)[]
public "blendOnto"(baseColor: $Color$Type): $Color
public "af"(): float
public "bf"(): float
public static "rgbad"(r: double, g: double, b: double, a: double): $Color
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Color$Type = ($Color);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Color_ = $Color$Type;
}}
declare module "packages/mekanism/common/lib/multiblock/$MultiblockCache" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$MultiblockCache$RejectContents, $MultiblockCache$RejectContents$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockCache$RejectContents"
import {$IMekanismInventory, $IMekanismInventory$Type} from "packages/mekanism/api/inventory/$IMekanismInventory"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$IGasTracker, $IGasTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IGasTracker"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$IEnergyContainer, $IEnergyContainer$Type} from "packages/mekanism/api/energy/$IEnergyContainer"
import {$IPigmentTank, $IPigmentTank$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentTank"
import {$IPigmentTracker, $IPigmentTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IPigmentTracker"
import {$IHeatCapacitor, $IHeatCapacitor$Type} from "packages/mekanism/api/heat/$IHeatCapacitor"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMekanismFluidHandler, $IMekanismFluidHandler$Type} from "packages/mekanism/api/fluid/$IMekanismFluidHandler"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IInfusionTank, $IInfusionTank$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionTank"
import {$MultiblockData, $MultiblockData$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockData"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$IExtendedFluidTank, $IExtendedFluidTank$Type} from "packages/mekanism/api/fluid/$IExtendedFluidTank"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$ISlurryTank, $ISlurryTank$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryTank"
import {$IMekanismStrictEnergyHandler, $IMekanismStrictEnergyHandler$Type} from "packages/mekanism/api/energy/$IMekanismStrictEnergyHandler"
import {$IMekanismHeatHandler, $IMekanismHeatHandler$Type} from "packages/mekanism/api/heat/$IMekanismHeatHandler"
import {$ISlurryTracker, $ISlurryTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$ISlurryTracker"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$IInfusionTracker, $IInfusionTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IInfusionTracker"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"

export class $MultiblockCache<T extends $MultiblockData> implements $IMekanismInventory, $IMekanismFluidHandler, $IMekanismStrictEnergyHandler, $IMekanismHeatHandler, $IGasTracker, $IInfusionTracker, $IPigmentTracker, $ISlurryTracker {

constructor()

public "load"(nbtTags: $CompoundTag$Type): void
public "apply"(data: T): void
public "merge"(mergeCache: $MultiblockCache$Type<(T)>, rejectContents: $MultiblockCache$RejectContents$Type): void
public "save"(nbtTags: $CompoundTag$Type): void
public "onContentsChanged"(): void
public "getEnergyContainers"(side: $Direction$Type): $List<($IEnergyContainer)>
public "getInventorySlots"(side: $Direction$Type): $List<($IInventorySlot)>
public "getFluidTanks"(side: $Direction$Type): $List<($IExtendedFluidTank)>
public "getInfusionTanks"(side: $Direction$Type): $List<($IInfusionTank)>
public "getPigmentTanks"(side: $Direction$Type): $List<($IPigmentTank)>
public "getGasTanks"(side: $Direction$Type): $List<($IGasTank)>
public "getHeatCapacitors"(side: $Direction$Type): $List<($IHeatCapacitor)>
public "getSlurryTanks"(side: $Direction$Type): $List<($ISlurryTank)>
public "sync"(data: T): void
public "getSlots"(arg0: $Direction$Type): integer
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: $Direction$Type, arg3: $Action$Type): $ItemStack
public "getStackInSlot"(arg0: integer, arg1: $Direction$Type): $ItemStack
public "getSlotLimit"(arg0: integer, arg1: $Direction$Type): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type, arg2: $Direction$Type): boolean
public "extractItem"(arg0: integer, arg1: integer, arg2: $Direction$Type, arg3: $Action$Type): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type, arg2: $Direction$Type): void
public "getInventorySlot"(arg0: integer, arg1: $Direction$Type): $IInventorySlot
public "hasInventory"(): boolean
public "isInventoryEmpty"(arg0: $Direction$Type): boolean
public "isInventoryEmpty"(): boolean
public "getTanks"(arg0: $Direction$Type): integer
public "getTankCapacity"(arg0: integer, arg1: $Direction$Type): integer
public "getFluidInTank"(arg0: integer, arg1: $Direction$Type): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type): boolean
public "getFluidTank"(arg0: integer, arg1: $Direction$Type): $IExtendedFluidTank
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type): void
public "insertFluid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type, arg3: $Action$Type): $FluidStack
public "canHandleFluid"(): boolean
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Direction$Type, arg3: $Action$Type): $FluidStack
public "getEnergyContainer"(arg0: integer, arg1: $Direction$Type): $IEnergyContainer
public "getEnergyContainerCount"(arg0: $Direction$Type): integer
public "extractEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type, arg3: $Action$Type): $FloatingLong
public "getEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "setEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type): void
public "canHandleEnergy"(): boolean
public "getMaxEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "getNeededEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "insertEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type, arg3: $Action$Type): $FloatingLong
public "canHandleHeat"(): boolean
public "getHeatCapacity"(arg0: integer, arg1: $Direction$Type): double
public "getHeatCapacitor"(arg0: integer, arg1: $Direction$Type): $IHeatCapacitor
public "handleHeat"(arg0: integer, arg1: double, arg2: $Direction$Type): void
public "getTemperature"(arg0: integer, arg1: $Direction$Type): double
public "getHeatCapacitorCount"(arg0: $Direction$Type): integer
public "getTotalInverseInsulation"(arg0: $Direction$Type): double
public "getInverseConduction"(arg0: integer, arg1: $Direction$Type): double
public "getInverseInsulation"(arg0: integer, arg1: $Direction$Type): double
public "getSlots"(): integer
public "getInventorySideFor"(): $Direction
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "getStackInSlot"(arg0: integer): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type): void
public "getTanks"(): integer
public "getTankCapacity"(arg0: integer): integer
public "getFluidInTank"(arg0: integer): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$Type): void
public "insertFluid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Action$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$Type, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "getFluidSideFor"(): $Direction
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Action$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$Type, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "getEnergyContainerCount"(): integer
public "extractEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Action$Type): $FloatingLong
public "extractEnergy"(arg0: $FloatingLong$Type, arg1: $Direction$Type, arg2: $Action$Type): $FloatingLong
public "getEnergy"(arg0: integer): $FloatingLong
public "setEnergy"(arg0: integer, arg1: $FloatingLong$Type): void
public "getMaxEnergy"(arg0: integer): $FloatingLong
public "getNeededEnergy"(arg0: integer): $FloatingLong
public "insertEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Action$Type): $FloatingLong
public "insertEnergy"(arg0: $FloatingLong$Type, arg1: $Direction$Type, arg2: $Action$Type): $FloatingLong
public "getEnergySideFor"(): $Direction
public "getHeatCapacity"(arg0: integer): double
public "handleHeat"(arg0: double, arg1: $Direction$Type): void
public "handleHeat"(arg0: integer, arg1: double): void
public "getHeatSideFor"(): $Direction
public "getTotalInverseConductionCoefficient"(arg0: $Direction$Type): double
public "getTemperature"(arg0: integer): double
public "getTotalHeatCapacity"(arg0: $Direction$Type): double
public "getHeatCapacitorCount"(): integer
public "getInverseConduction"(arg0: integer): double
public "getTotalTemperature"(arg0: $Direction$Type): double
/**
 * 
 * @deprecated
 */
public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
/**
 * 
 * @deprecated
 */
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$Type, arg1: $Action$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Action$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$Type, arg1: $Action$Type): $FluidStack
public "extractEnergy"(arg0: $FloatingLong$Type, arg1: $Action$Type): $FloatingLong
public "insertEnergy"(arg0: $FloatingLong$Type, arg1: $Action$Type): $FloatingLong
public "handleHeat"(arg0: double): void
public "getTotalHeatCapacity"(): double
public "getTotalInverseConduction"(): double
public "getTotalTemperature"(): double
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "isMutable"(): boolean
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "getSlotLimit"(i: integer): integer
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "kjs$self"(): $IItemHandler
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "asContainer"(): $Container
public "getWidth"(): integer
public "find"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "clear"(ingredient: $Ingredient$Type): void
public "clear"(): void
public "setChanged"(): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "getHeight"(): integer
get "inventoryEmpty"(): boolean
get "slots"(): integer
get "inventorySideFor"(): $Direction
get "tanks"(): integer
get "fluidSideFor"(): $Direction
get "energyContainerCount"(): integer
get "energySideFor"(): $Direction
get "heatSideFor"(): $Direction
get "heatCapacitorCount"(): integer
get "totalHeatCapacity"(): double
get "totalInverseConduction"(): double
get "totalTemperature"(): double
get "mutable"(): boolean
get "slots"(): integer
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockCache$Type<T> = ($MultiblockCache<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockCache_<T> = $MultiblockCache$Type<(T)>;
}}
declare module "packages/mekanism/common/content/network/$InventoryNetwork$AcceptorData" {
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest$TransitResponse"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $InventoryNetwork$AcceptorData {


public "getLocation"(): $BlockPos
public "getResponse"(): $TransitRequest$TransitResponse
public "getSides"(): $Set<($Direction)>
get "location"(): $BlockPos
get "response"(): $TransitRequest$TransitResponse
get "sides"(): $Set<($Direction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryNetwork$AcceptorData$Type = ($InventoryNetwork$AcceptorData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryNetwork$AcceptorData_ = $InventoryNetwork$AcceptorData$Type;
}}
declare module "packages/mekanism/common/item/block/transmitter/$ItemBlockLogisticalTransporter" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemBlockMekanism, $ItemBlockMekanism$Type} from "packages/mekanism/common/item/block/$ItemBlockMekanism"
import {$BlockLogisticalTransporter, $BlockLogisticalTransporter$Type} from "packages/mekanism/common/block/transmitter/$BlockLogisticalTransporter"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockLogisticalTransporter extends $ItemBlockMekanism<($BlockLogisticalTransporter)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockLogisticalTransporter$Type)

public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockLogisticalTransporter$Type = ($ItemBlockLogisticalTransporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockLogisticalTransporter_ = $ItemBlockLogisticalTransporter$Type;
}}
declare module "packages/mekanism/common/content/blocktype/$BlockTypeTile" {
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$BlockType, $BlockType$Type} from "packages/mekanism/common/content/blocktype/$BlockType"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ILangEntry, $ILangEntry$Type} from "packages/mekanism/api/text/$ILangEntry"

export class $BlockTypeTile<TILE extends $TileEntityMekanism> extends $BlockType {

constructor(tileEntityRegistrar: $Supplier$Type<($TileEntityTypeRegistryObject$Type<(TILE)>)>, description: $ILangEntry$Type)

public "getTileType"(): $TileEntityTypeRegistryObject<(TILE)>
get "tileType"(): $TileEntityTypeRegistryObject<(TILE)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTypeTile$Type<TILE> = ($BlockTypeTile<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTypeTile_<TILE> = $BlockTypeTile$Type<(TILE)>;
}}
declare module "packages/mekanism/common/network/to_client/container/property/$PropertyData" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$PropertyType, $PropertyType$Type} from "packages/mekanism/common/network/to_client/container/property/$PropertyType"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"

export class $PropertyData {


public "getProperty"(): short
public "getType"(): $PropertyType
public static "fromBuffer"(buffer: $FriendlyByteBuf$Type): $PropertyData
public "writeToPacket"(buffer: $FriendlyByteBuf$Type): void
public "handleWindowProperty"(container: $MekanismContainer$Type): void
get "property"(): short
get "type"(): $PropertyType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyData$Type = ($PropertyData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyData_ = $PropertyData$Type;
}}
declare module "packages/mekanism/common/block/prefab/$BlockTileGlass" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$BlockTile, $BlockTile$Type} from "packages/mekanism/common/block/prefab/$BlockTile"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $BlockTileGlass<TILE extends $TileEntityMekanism, TYPE extends $BlockTypeTile<(TILE)>> extends $BlockTile<(TILE), (TYPE)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(type: TYPE)

public "propagatesSkylightDown"(state: $BlockState$Type, reader: $BlockGetter$Type, pos: $BlockPos$Type): boolean
public "shouldDisplayFluidOverlay"(state: $BlockState$Type, world: $BlockAndTintGetter$Type, pos: $BlockPos$Type, fluidState: $FluidState$Type): boolean
/**
 * 
 * @deprecated
 */
public "skipRendering"(state: $BlockState$Type, adjacentBlockState: $BlockState$Type, side: $Direction$Type): boolean
/**
 * 
 * @deprecated
 */
public "getShadeBrightness"(state: $BlockState$Type, worldIn: $BlockGetter$Type, pos: $BlockPos$Type): float
/**
 * 
 * @deprecated
 */
public "getVisualShape"(state: $BlockState$Type, reader: $BlockGetter$Type, pos: $BlockPos$Type, ctx: $CollisionContext$Type): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTileGlass$Type<TILE, TYPE> = ($BlockTileGlass<(TILE), (TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTileGlass_<TILE, TYPE> = $BlockTileGlass$Type<(TILE), (TYPE)>;
}}
declare module "packages/mekanism/common/lib/frequency/$FrequencyManagerWrapper" {
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$FrequencyType, $FrequencyType$Type} from "packages/mekanism/common/lib/frequency/$FrequencyType"
import {$FrequencyManager, $FrequencyManager$Type} from "packages/mekanism/common/lib/frequency/$FrequencyManager"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$FrequencyManagerWrapper$Type, $FrequencyManagerWrapper$Type$Type} from "packages/mekanism/common/lib/frequency/$FrequencyManagerWrapper$Type"

export class $FrequencyManagerWrapper<FREQ extends $Frequency> {


public "clear"(): void
public static "create"<FREQ extends $Frequency>(frequencyType: $FrequencyType$Type<(FREQ)>, type: $FrequencyManagerWrapper$Type$Type): $FrequencyManagerWrapper<(FREQ)>
public "getPublicManager"(): $FrequencyManager<(FREQ)>
public "getPrivateManager"(ownerUUID: $UUID$Type): $FrequencyManager<(FREQ)>
get "publicManager"(): $FrequencyManager<(FREQ)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrequencyManagerWrapper$Type<FREQ> = ($FrequencyManagerWrapper<(FREQ)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FrequencyManagerWrapper_<FREQ> = $FrequencyManagerWrapper$Type<(FREQ)>;
}}
declare module "packages/mekanism/common/recipe/serializer/$ItemStackToInfuseTypeRecipeSerializer" {
import {$ItemStackToChemicalRecipeSerializer, $ItemStackToChemicalRecipeSerializer$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackToChemicalRecipeSerializer"
import {$ItemStackToInfuseTypeRecipe, $ItemStackToInfuseTypeRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackToInfuseTypeRecipe"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$InfuseType, $InfuseType$Type} from "packages/mekanism/api/chemical/infuse/$InfuseType"
import {$InfusionStack, $InfusionStack$Type} from "packages/mekanism/api/chemical/infuse/$InfusionStack"
import {$ItemStackToChemicalRecipeSerializer$IFactory, $ItemStackToChemicalRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackToChemicalRecipeSerializer$IFactory"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ItemStackToInfuseTypeRecipeSerializer<RECIPE extends $ItemStackToInfuseTypeRecipe> extends $ItemStackToChemicalRecipeSerializer<($InfuseType), ($InfusionStack), (RECIPE)> {

constructor(factory: $ItemStackToChemicalRecipeSerializer$IFactory$Type<($InfuseType$Type), ($InfusionStack$Type), (RECIPE)>)

public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackToInfuseTypeRecipeSerializer$Type<RECIPE> = ($ItemStackToInfuseTypeRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackToInfuseTypeRecipeSerializer_<RECIPE> = $ItemStackToInfuseTypeRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/content/transporter/$TransporterStack" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest$TransitResponse"
import {$TransporterStack$Path, $TransporterStack$Path$Type} from "packages/mekanism/common/content/transporter/$TransporterStack$Path"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$LogisticalTransporterBase, $LogisticalTransporterBase$Type} from "packages/mekanism/common/content/network/transmitter/$LogisticalTransporterBase"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$TransitRequest, $TransitRequest$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$TileEntityLogisticalSorter, $TileEntityLogisticalSorter$Type} from "packages/mekanism/common/tile/$TileEntityLogisticalSorter"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TransporterStack {
 "itemStack": $ItemStack
 "progress": integer
 "color": $EnumColor
 "initiatedPath": boolean
 "idleDir": $Direction
 "originalLocation": $BlockPos
 "homeLocation": $BlockPos

constructor()

public "write"(transporter: $LogisticalTransporterBase$Type, buf: $FriendlyByteBuf$Type): void
public "write"(nbtTags: $CompoundTag$Type): void
public "read"(dataStream: $FriendlyByteBuf$Type): void
public "read"(nbtTags: $CompoundTag$Type): void
public "isFinal"(transporter: $LogisticalTransporterBase$Type): boolean
public "getPath"(): $List<($BlockPos)>
public "getSide"(transporter: $LogisticalTransporterBase$Type): $Direction
public "getPrev"(transporter: $LogisticalTransporterBase$Type): $BlockPos
public "getNext"(transporter: $LogisticalTransporterBase$Type): $BlockPos
public "readFromUpdateTag"(updateTag: $CompoundTag$Type): void
public static "readFromNBT"(nbtTags: $CompoundTag$Type): $TransporterStack
public static "readFromPacket"(dataStream: $FriendlyByteBuf$Type): $TransporterStack
public "canInsertToTransporterNN"(transporter: $LogisticalTransporterBase$Type, from: $Direction$Type, transporterFrom: $LogisticalTransporterBase$Type): boolean
public "canInsertToTransporterNN"(transporter: $LogisticalTransporterBase$Type, from: $Direction$Type, tileFrom: $BlockEntity$Type): boolean
public "canInsertToTransporter"(transmitter: $LogisticalTransporterBase$Type, from: $Direction$Type, transporterFrom: $LogisticalTransporterBase$Type): boolean
public "getPathType"(): $TransporterStack$Path
public "getDest"(): $BlockPos
public "hasPath"(): boolean
public "writeToUpdateTag"(transporter: $LogisticalTransporterBase$Type, updateTag: $CompoundTag$Type): void
public static "readFromUpdate"(nbtTags: $CompoundTag$Type): $TransporterStack
public "recalculatePath"(request: $TransitRequest$Type, transporter: $LogisticalTransporterBase$Type, min: integer, additionalFlowingStacks: $Map$Type<($Coord4D$Type), ($Set$Type<($TransporterStack$Type)>)>): $TransitRequest$TransitResponse
public "recalculatePath"(request: $TransitRequest$Type, transporter: $LogisticalTransporterBase$Type, min: integer, updateFlowing: boolean): $TransitRequest$TransitResponse
public "recalculatePath"(request: $TransitRequest$Type, transporter: $LogisticalTransporterBase$Type, min: integer): $TransitRequest$TransitResponse
public "calculateIdle"(transporter: $LogisticalTransporterBase$Type): boolean
public "recalculateRRPath"(request: $TransitRequest$Type, outputter: $TileEntityLogisticalSorter$Type, transporter: $LogisticalTransporterBase$Type, min: integer, updateFlowing: boolean): $TransitRequest$TransitResponse
public "recalculateRRPath"(request: $TransitRequest$Type, outputter: $TileEntityLogisticalSorter$Type, transporter: $LogisticalTransporterBase$Type, min: integer): $TransitRequest$TransitResponse
public "getSideOfDest"(): $Direction
get "path"(): $List<($BlockPos)>
get "pathType"(): $TransporterStack$Path
get "dest"(): $BlockPos
get "sideOfDest"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransporterStack$Type = ($TransporterStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransporterStack_ = $TransporterStack$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemArmoredFreeRunners" {
import {$ImmutableMultimap$Builder, $ImmutableMultimap$Builder$Type} from "packages/com/google/common/collect/$ImmutableMultimap$Builder"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IAttributeRefresher, $IAttributeRefresher$Type} from "packages/mekanism/common/lib/attribute/$IAttributeRefresher"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemFreeRunners, $ItemFreeRunners$Type} from "packages/mekanism/common/item/gear/$ItemFreeRunners"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$DispenseItemBehavior, $DispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DispenseItemBehavior"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemArmoredFreeRunners extends $ItemFreeRunners implements $IAttributeRefresher {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "initializeClient"(consumer: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "addToBuilder"(builder: $ImmutableMultimap$Builder$Type<($Attribute$Type), ($AttributeModifier$Type)>): void
public "getAttributeModifiers"(slot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "getDefense"(): integer
public "getToughness"(): float
public static "displayModeChange"(player: $Player$Type): void
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
public static "get"(arg0: $ItemStack$Type): $Equipable
get "defense"(): integer
get "toughness"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemArmoredFreeRunners$Type = ($ItemArmoredFreeRunners);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemArmoredFreeRunners_ = $ItemArmoredFreeRunners$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$NucleosynthesizingRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NucleosynthesizingRecipe, $NucleosynthesizingRecipe$Type} from "packages/mekanism/api/recipes/$NucleosynthesizingRecipe"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$NucleosynthesizingRecipeSerializer$IFactory, $NucleosynthesizingRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$NucleosynthesizingRecipeSerializer$IFactory"

export class $NucleosynthesizingRecipeSerializer<RECIPE extends $NucleosynthesizingRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(factory: $NucleosynthesizingRecipeSerializer$IFactory$Type<(RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NucleosynthesizingRecipeSerializer$Type<RECIPE> = ($NucleosynthesizingRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NucleosynthesizingRecipeSerializer_<RECIPE> = $NucleosynthesizingRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/config/value/$CachedDoubleValue" {
import {$IMekanismConfig, $IMekanismConfig$Type} from "packages/mekanism/common/config/$IMekanismConfig"
import {$ForgeConfigSpec$ConfigValue, $ForgeConfigSpec$ConfigValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue"
import {$DoubleSupplier, $DoubleSupplier$Type} from "packages/java/util/function/$DoubleSupplier"
import {$CachedValue, $CachedValue$Type} from "packages/mekanism/common/config/value/$CachedValue"

export class $CachedDoubleValue extends $CachedValue<(double)> implements $DoubleSupplier {


public "get"(): double
public static "wrap"(config: $IMekanismConfig$Type, internal: $ForgeConfigSpec$ConfigValue$Type<(double)>): $CachedDoubleValue
public "set"(value: double): void
public "getOrDefault"(): double
public "getAsDouble"(): double
get "orDefault"(): double
get "asDouble"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedDoubleValue$Type = ($CachedDoubleValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedDoubleValue_ = $CachedDoubleValue$Type;
}}
declare module "packages/mekanism/common/item/block/transmitter/$ItemBlockDiversionTransporter" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemBlockMekanism, $ItemBlockMekanism$Type} from "packages/mekanism/common/item/block/$ItemBlockMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$BlockDiversionTransporter, $BlockDiversionTransporter$Type} from "packages/mekanism/common/block/transmitter/$BlockDiversionTransporter"

export class $ItemBlockDiversionTransporter extends $ItemBlockMekanism<($BlockDiversionTransporter)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockDiversionTransporter$Type)

public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockDiversionTransporter$Type = ($ItemBlockDiversionTransporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockDiversionTransporter_ = $ItemBlockDiversionTransporter$Type;
}}
declare module "packages/mekanism/common/integration/computer/$BoundMethodHolder$BoundMethodData" {
import {$BaseComputerHelper, $BaseComputerHelper$Type} from "packages/mekanism/common/integration/computer/$BaseComputerHelper"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ComputerMethodFactory$ComputerFunctionCaller, $ComputerMethodFactory$ComputerFunctionCaller$Type} from "packages/mekanism/common/integration/computer/$ComputerMethodFactory$ComputerFunctionCaller"
import {$MethodData, $MethodData$Type} from "packages/mekanism/common/integration/computer/$MethodData"
import {$WeakReference, $WeakReference$Type} from "packages/java/lang/ref/$WeakReference"

export class $BoundMethodHolder$BoundMethodData<T> extends $Record {

constructor(method: $MethodData$Type<(T)>, subject: $WeakReference$Type<(T)>, isHelpMethod: boolean)

public "returnType"(): $Class<(any)>
public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "method"(): $MethodData<(T)>
public "hashCode"(): integer
public "handler"(): $ComputerMethodFactory$ComputerFunctionCaller<(T)>
public "subject"(): $WeakReference<(T)>
public "call"(helper: $BaseComputerHelper$Type): any
public "argClasses"(): ($Class<(any)>)[]
public "threadSafe"(): boolean
public "isHelpMethod"(): boolean
public "argumentNames"(): (string)[]
get "helpMethod"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoundMethodHolder$BoundMethodData$Type<T> = ($BoundMethodHolder$BoundMethodData<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoundMethodHolder$BoundMethodData_<T> = $BoundMethodHolder$BoundMethodData$Type<(T)>;
}}
declare module "packages/mekanism/common/lib/multiblock/$IValveHandler$ValveData" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $IValveHandler$ValveData {
readonly "location": $BlockPos
readonly "side": $Direction
 "prevActive": boolean
 "activeTicks": integer

constructor(location: $BlockPos$Type, side: $Direction$Type)

public "equals"(obj: any): boolean
public "hashCode"(): integer
public "onTransfer"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IValveHandler$ValveData$Type = ($IValveHandler$ValveData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IValveHandler$ValveData_ = $IValveHandler$ValveData$Type;
}}
declare module "packages/mekanism/common/block/attribute/$AttributeEnergy" {
import {$FloatingLongSupplier, $FloatingLongSupplier$Type} from "packages/mekanism/api/math/$FloatingLongSupplier"
import {$Attribute, $Attribute$Type} from "packages/mekanism/common/block/attribute/$Attribute"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"

export class $AttributeEnergy implements $Attribute {

constructor(energyUsage: $FloatingLongSupplier$Type, energyStorage: $FloatingLongSupplier$Type)

public "getUsage"(): $FloatingLong
public "getStorage"(): $FloatingLong
public "getConfigStorage"(): $FloatingLong
public static "get"<ATTRIBUTE extends $Attribute>(blockProvider: $IBlockProvider$Type, type: $Class$Type<(ATTRIBUTE)>): ATTRIBUTE
public static "get"<ATTRIBUTE extends $Attribute>(block: $Block$Type, type: $Class$Type<(ATTRIBUTE)>): ATTRIBUTE
public static "get"<ATTRIBUTE extends $Attribute>(state: $BlockState$Type, type: $Class$Type<(ATTRIBUTE)>): ATTRIBUTE
public static "matches"<ATTRIBUTE extends $Attribute>(block: $Block$Type, type: $Class$Type<(ATTRIBUTE)>, checker: $Predicate$Type<(any)>): boolean
public static "isActive"(state: $BlockState$Type): boolean
public static "ifPresent"<ATTRIBUTE extends $Attribute>(block: $Block$Type, type: $Class$Type<(ATTRIBUTE)>, action: $Consumer$Type<(any)>): void
public static "has"(block: $Block$Type, type: $Class$Type<(any)>): boolean
public static "has"(state: $BlockState$Type, type: $Class$Type<(any)>): boolean
public static "getAll"(block: $Block$Type): $Collection<($Attribute)>
public static "setActive"(state: $BlockState$Type, active: boolean): $BlockState
public static "getTier"<TIER extends $ITier>(blockProvider: $IBlockProvider$Type, tierClass: $Class$Type<(TIER)>): TIER
public static "getTier"<TIER extends $ITier>(block: $Block$Type, tierClass: $Class$Type<(TIER)>): TIER
public static "getFacing"(state: $BlockState$Type): $Direction
public static "setFacing"(state: $BlockState$Type, facing: $Direction$Type): $BlockState
public static "getBaseTier"(block: $Block$Type): $BaseTier
public "adjustProperties"(props: $BlockBehaviour$Properties$Type): void
get "usage"(): $FloatingLong
get "storage"(): $FloatingLong
get "configStorage"(): $FloatingLong
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeEnergy$Type = ($AttributeEnergy);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttributeEnergy_ = $AttributeEnergy$Type;
}}
declare module "packages/mekanism/common/lib/security/$ISecurityTile" {
import {$SecurityMode, $SecurityMode$Type} from "packages/mekanism/api/security/$SecurityMode"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ISecurityObject, $ISecurityObject$Type} from "packages/mekanism/api/security/$ISecurityObject"
import {$TileComponentSecurity, $TileComponentSecurity$Type} from "packages/mekanism/common/tile/component/$TileComponentSecurity"

export interface $ISecurityTile extends $ISecurityObject {

 "setSecurityMode"(mode: $SecurityMode$Type): void
 "setOwnerUUID"(owner: $UUID$Type): void
 "hasSecurity"(): boolean
 "getSecurity"(): $TileComponentSecurity
 "getSecurityMode"(): $SecurityMode
 "getOwnerName"(): string
 "getOwnerUUID"(): $UUID
 "onSecurityChanged"(arg0: $SecurityMode$Type, arg1: $SecurityMode$Type): void
 "ownerMatches"(arg0: $Player$Type): boolean

(mode: $SecurityMode$Type): void
}

export namespace $ISecurityTile {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISecurityTile$Type = ($ISecurityTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISecurityTile_ = $ISecurityTile$Type;
}}
declare module "packages/mekanism/common/tier/$CableTier" {
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$CachedFloatingLongValue, $CachedFloatingLongValue$Type} from "packages/mekanism/common/config/value/$CachedFloatingLongValue"

export class $CableTier extends $Enum<($CableTier)> implements $ITier {
static readonly "BASIC": $CableTier
static readonly "ADVANCED": $CableTier
static readonly "ELITE": $CableTier
static readonly "ULTIMATE": $CableTier


public static "get"(tier: $BaseTier$Type): $CableTier
public static "values"(): ($CableTier)[]
public static "valueOf"(name: string): $CableTier
public "getBaseCapacity"(): $FloatingLong
public "getBaseTier"(): $BaseTier
public "setConfigReference"(capacityReference: $CachedFloatingLongValue$Type): void
public "getCableCapacity"(): $FloatingLong
get "baseCapacity"(): $FloatingLong
get "baseTier"(): $BaseTier
set "configReference"(value: $CachedFloatingLongValue$Type)
get "cableCapacity"(): $FloatingLong
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CableTier$Type = (("elite") | ("advanced") | ("ultimate") | ("basic")) | ($CableTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CableTier_ = $CableTier$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemElectricBow" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CreativeModeTab$Output, $CreativeModeTab$Output$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$Output"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$BowItem, $BowItem$Type} from "packages/net/minecraft/world/item/$BowItem"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$IModeItem, $IModeItem$Type} from "packages/mekanism/common/item/interfaces/$IModeItem"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$Type} from "packages/mekanism/common/registration/impl/$CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$IItemHUDProvider, $IItemHUDProvider$Type} from "packages/mekanism/common/item/interfaces/$IItemHUDProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemElectricBow extends $BowItem implements $IModeItem, $IItemHUDProvider, $CreativeTabDeferredRegister$ICustomCreativeTabContents {
static readonly "MAX_DRAW_DURATION": integer
static readonly "DEFAULT_RANGE": integer
static readonly "ARROW_ONLY": $Predicate<($ItemStack)>
static readonly "ARROW_OR_FIREWORK": $Predicate<($ItemStack)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "addItems"(tabOutput: $CreativeModeTab$Output$Type): void
public "getEnchantmentLevel"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): integer
public "getAllEnchantments"(stack: $ItemStack$Type): $Map<($Enchantment), (integer)>
public "initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "isBarVisible"(stack: $ItemStack$Type): boolean
public "getBarWidth"(stack: $ItemStack$Type): integer
public "getBarColor"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "releaseUsing"(stack: $ItemStack$Type, world: $Level$Type, entityLiving: $LivingEntity$Type, timeLeft: integer): void
public "getScrollTextComponent"(stack: $ItemStack$Type): $Component
public "addHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): void
public "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
public "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "displayModeChange"(player: $Player$Type): void
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
public "addCurioHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type): void
public "addDefault"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemElectricBow$Type = ($ItemElectricBow);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemElectricBow_ = $ItemElectricBow$Type;
}}
declare module "packages/mekanism/common/recipe/ingredient/$IMultiIngredient" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$InputIngredient, $InputIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$InputIngredient"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"

export interface $IMultiIngredient<TYPE, INGREDIENT extends $InputIngredient<(TYPE)>> extends $InputIngredient<(TYPE)> {

 "getIngredients"(): $List<(INGREDIENT)>
 "forEachIngredient"(checker: $Predicate$Type<(INGREDIENT)>): boolean
 "write"(arg0: $FriendlyByteBuf$Type): void
 "testType"(arg0: TYPE): boolean
 "serialize"(): $JsonElement
 "hasNoMatchingInstances"(): boolean
 "getMatchingInstance"(arg0: TYPE): TYPE
 "getNeededAmount"(arg0: TYPE): long
 "getRepresentations"(): $List<(TYPE)>
 "test"(arg0: TYPE): boolean
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(TYPE)>
 "negate"(): $Predicate<(TYPE)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(TYPE)>
}

export namespace $IMultiIngredient {
function isEqual<T>(arg0: any): $Predicate<(TYPE)>
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(TYPE)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMultiIngredient$Type<TYPE, INGREDIENT> = ($IMultiIngredient<(TYPE), (INGREDIENT)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMultiIngredient_<TYPE, INGREDIENT> = $IMultiIngredient$Type<(TYPE), (INGREDIENT)>;
}}
declare module "packages/mekanism/common/tile/$TileEntityEnergyCube" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$TileComponentEjector, $TileComponentEjector$Type} from "packages/mekanism/common/tile/component/$TileComponentEjector"
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$EnergyCubeEnergyContainer, $EnergyCubeEnergyContainer$Type} from "packages/mekanism/common/capabilities/energy/$EnergyCubeEnergyContainer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$TileEntityEnergyCube$CubeSideState, $TileEntityEnergyCube$CubeSideState$Type} from "packages/mekanism/common/tile/$TileEntityEnergyCube$CubeSideState"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$EnergyCubeTier, $EnergyCubeTier$Type} from "packages/mekanism/common/tier/$EnergyCubeTier"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$TileEntityConfigurableMachine, $TileEntityConfigurableMachine$Type} from "packages/mekanism/common/tile/prefab/$TileEntityConfigurableMachine"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$TileComponentConfig, $TileComponentConfig$Type} from "packages/mekanism/common/tile/component/$TileComponentConfig"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"
import {$IUpgradeData, $IUpgradeData$Type} from "packages/mekanism/common/upgrade/$IUpgradeData"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export class $TileEntityEnergyCube extends $TileEntityConfigurableMachine {
static readonly "SIDE_STATE_PROPERTY": $ModelProperty<(($TileEntityEnergyCube$CubeSideState)[])>
 "ejectorComponent": $TileComponentEjector
 "configComponent": $TileComponentConfig
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "getEnergyContainer"(): $EnergyCubeEnergyContainer
public "getEnergyScale"(): float
public "getModelData"(): $ModelData
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "getTier"(): $EnergyCubeTier
public "getRedstoneLevel"(): integer
public "parseUpgradeData"(upgradeData: $IUpgradeData$Type): void
public "getReducedUpdateTag"(): $CompoundTag
public "getDirection"(): $Direction
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "energyContainer"(): $EnergyCubeEnergyContainer
get "energyScale"(): float
get "modelData"(): $ModelData
get "tier"(): $EnergyCubeTier
get "redstoneLevel"(): integer
get "reducedUpdateTag"(): $CompoundTag
get "direction"(): $Direction
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityEnergyCube$Type = ($TileEntityEnergyCube);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityEnergyCube_ = $TileEntityEnergyCube$Type;
}}
declare module "packages/mekanism/common/capabilities/energy/$MachineEnergyContainer" {
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$BasicEnergyContainer, $BasicEnergyContainer$Type} from "packages/mekanism/common/capabilities/energy/$BasicEnergyContainer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$AttributeEnergy, $AttributeEnergy$Type} from "packages/mekanism/common/block/attribute/$AttributeEnergy"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"

export class $MachineEnergyContainer<TILE extends $TileEntityMekanism> extends $BasicEnergyContainer {
static readonly "alwaysTrue": $Predicate<($AutomationType)>
static readonly "alwaysFalse": $Predicate<($AutomationType)>
static readonly "internalOnly": $Predicate<($AutomationType)>
static readonly "manualOnly": $Predicate<($AutomationType)>
static readonly "notExternal": $Predicate<($AutomationType)>


public static "input"<TILE extends $TileEntityMekanism>(tile: TILE, listener: $IContentsListener$Type): $MachineEnergyContainer<(TILE)>
public static "internal"<TILE extends $TileEntityMekanism>(tile: TILE, listener: $IContentsListener$Type): $MachineEnergyContainer<(TILE)>
public "getBaseEnergyPerTick"(): $FloatingLong
public "updateEnergyPerTick"(): void
public "getBaseMaxEnergy"(): $FloatingLong
public static "validateBlock"(tile: $TileEntityMekanism$Type): $AttributeEnergy
public "adjustableRates"(): boolean
public "setEnergyPerTick"(energyPerTick: $FloatingLong$Type): void
public "updateMaxEnergy"(): void
public "setMaxEnergy"(maxEnergy: $FloatingLong$Type): void
public "getMaxEnergy"(): $FloatingLong
public "getEnergyPerTick"(): $FloatingLong
get "baseEnergyPerTick"(): $FloatingLong
get "baseMaxEnergy"(): $FloatingLong
set "energyPerTick"(value: $FloatingLong$Type)
set "maxEnergy"(value: $FloatingLong$Type)
get "maxEnergy"(): $FloatingLong
get "energyPerTick"(): $FloatingLong
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineEnergyContainer$Type<TILE> = ($MachineEnergyContainer<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineEnergyContainer_<TILE> = $MachineEnergyContainer$Type<(TILE)>;
}}
declare module "packages/mekanism/common/lib/multiblock/$Structure$Axis" {
import {$BlockPosBuilder, $BlockPosBuilder$Type} from "packages/mekanism/common/lib/math/voxel/$BlockPosBuilder"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $Structure$Axis extends $Enum<($Structure$Axis)> {
static readonly "X": $Structure$Axis
static readonly "Y": $Structure$Axis
static readonly "Z": $Structure$Axis


public static "get"(side: $Direction$Type): $Structure$Axis
public static "values"(): ($Structure$Axis)[]
public static "valueOf"(name: string): $Structure$Axis
public "set"(pos: $BlockPosBuilder$Type, val: integer): void
public "vertical"(): $Structure$Axis
public "horizontal"(): $Structure$Axis
public "getCoord"(pos: $BlockPos$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Structure$Axis$Type = (("x") | ("y") | ("z")) | ($Structure$Axis);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Structure$Axis_ = $Structure$Axis$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemFlamethrower" {
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CreativeModeTab$Output, $CreativeModeTab$Output$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$Output"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$Type} from "packages/mekanism/common/registration/impl/$CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$ItemFlamethrower$FlamethrowerMode, $ItemFlamethrower$FlamethrowerMode$Type} from "packages/mekanism/common/item/gear/$ItemFlamethrower$FlamethrowerMode"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$CapabilityItem, $CapabilityItem$Type} from "packages/mekanism/common/item/$CapabilityItem"
import {$IModeItem, $IModeItem$Type} from "packages/mekanism/common/item/interfaces/$IModeItem"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$IGasItem, $IGasItem$Type} from "packages/mekanism/common/item/interfaces/$IGasItem"
import {$IItemHUDProvider, $IItemHUDProvider$Type} from "packages/mekanism/common/item/interfaces/$IItemHUDProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemFlamethrower extends $CapabilityItem implements $IItemHUDProvider, $IModeItem, $IGasItem, $CreativeTabDeferredRegister$ICustomCreativeTabContents {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "setMode"(stack: $ItemStack$Type, mode: $ItemFlamethrower$FlamethrowerMode$Type): void
public "getMode"(stack: $ItemStack$Type): $ItemFlamethrower$FlamethrowerMode
public "addItems"(tabOutput: $CreativeModeTab$Output$Type): void
public "initializeClient"(consumer: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "isBarVisible"(stack: $ItemStack$Type): boolean
public "getBarWidth"(stack: $ItemStack$Type): integer
public "getBarColor"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "isEnchantable"(stack: $ItemStack$Type): boolean
public "isBookEnchantable"(stack: $ItemStack$Type, book: $ItemStack$Type): boolean
public "getScrollTextComponent"(stack: $ItemStack$Type): $Component
public "addHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): void
public "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
public "addCurioHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type): void
public "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "displayModeChange"(player: $Player$Type): void
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
public "hasGas"(stack: $ItemStack$Type): boolean
public "useGas"(stack: $ItemStack$Type, amount: long): $GasStack
public "addDefault"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFlamethrower$Type = ($ItemFlamethrower);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFlamethrower_ = $ItemFlamethrower$Type;
}}
declare module "packages/mekanism/common/content/qio/$IQIODriveItem" {
import {$QIODriveData, $QIODriveData$Type} from "packages/mekanism/common/content/qio/$QIODriveData"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IQIODriveItem {

 "getCountCapacity"(stack: $ItemStack$Type): long
 "getTypeCapacity"(stack: $ItemStack$Type): integer
 "loadItemMap"(stack: $ItemStack$Type, data: $QIODriveData$Type): void
 "hasStoredItemMap"(stack: $ItemStack$Type): boolean
 "writeItemMap"(stack: $ItemStack$Type, map: $QIODriveData$Type): void
}

export namespace $IQIODriveItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IQIODriveItem$Type = ($IQIODriveItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IQIODriveItem_ = $IQIODriveItem$Type;
}}
declare module "packages/mekanism/common/block/prefab/$BlockFactoryMachine" {
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockTile, $BlockTile$Type} from "packages/mekanism/common/block/prefab/$BlockTile"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Machine$FactoryMachine, $Machine$FactoryMachine$Type} from "packages/mekanism/common/content/blocktype/$Machine$FactoryMachine"

export class $BlockFactoryMachine<TILE extends $TileEntityMekanism, MACHINE extends $Machine$FactoryMachine<(TILE)>> extends $BlockTile<(TILE), (MACHINE)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(machineType: MACHINE, propertiesModifier: $UnaryOperator$Type<($BlockBehaviour$Properties$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockFactoryMachine$Type<TILE, MACHINE> = ($BlockFactoryMachine<(TILE), (MACHINE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockFactoryMachine_<TILE, MACHINE> = $BlockFactoryMachine$Type<(TILE), (MACHINE)>;
}}
declare module "packages/mekanism/common/tile/prefab/$TileEntityMultiblock" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FormationProtocol, $FormationProtocol$Type} from "packages/mekanism/common/lib/multiblock/$FormationProtocol"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BoundMethodHolder, $BoundMethodHolder$Type} from "packages/mekanism/common/integration/computer/$BoundMethodHolder"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$MultiblockData, $MultiblockData$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockData"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$IMultiblock, $IMultiblock$Type} from "packages/mekanism/common/lib/multiblock/$IMultiblock"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$MultiblockManager, $MultiblockManager$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockManager"
import {$IConfigurable, $IConfigurable$Type} from "packages/mekanism/api/$IConfigurable"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Structure, $Structure$Type} from "packages/mekanism/common/lib/multiblock/$Structure"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"

export class $TileEntityMultiblock<T extends $MultiblockData> extends $TileEntityMekanism implements $IMultiblock<(T)>, $IConfigurable {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "onNeighborChange"(block: $Block$Type, neighborPos: $BlockPos$Type): void
public "getRenderBoundingBox"(): $AABB
public "load"(nbt: $CompoundTag$Type): void
public "m_183515_"(nbtTags: $CompoundTag$Type): void
public "setRemoved"(): void
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "shouldDumpRadiation"(): boolean
public "addContainerTrackers"(container: $MekanismContainer$Type): void
public "isComputerCapabilityPersistent"(): boolean
public "onRightClick"(player: $Player$Type): $InteractionResult
public "onActivate"(player: $Player$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type): $InteractionResult
public "getStructure"(): $Structure
public "persistInventory"(): boolean
public "getComputerMethods"(holder: $BoundMethodHolder$Type): void
public "getReducedUpdateTag"(): $CompoundTag
public "resetCache"(): void
public "getCacheID"(): $UUID
public "onSneakRightClick"(player: $Player$Type): $InteractionResult
public "setStructure"(structure: $Structure$Type): void
public "exposesMultiblockToComputer"(): boolean
public "getDefaultData"(): T
public "isMaster"(): boolean
public "canBeMaster"(): boolean
public "resetForFormed"(): void
public "getMultiblock"(): T
public "getManager"(): $MultiblockManager<(T)>
public "getStructure"(manager: $MultiblockManager$Type<(any)>): $Structure
public "createMultiblock"(): T
public "setStructure"(manager: $MultiblockManager$Type<(any)>, structure: $Structure$Type): void
public "createFormationProtocol"(): $FormationProtocol<(T)>
public "hasStructure"(structure: $Structure$Type): boolean
public "getMultiblockData"(manager: $MultiblockManager$Type<(any)>): $MultiblockData
public "resetStructure"(manager: $MultiblockManager$Type<(any)>): $Structure
public "setMultiblockData"(manager: $MultiblockManager$Type<(any)>, multiblockData: $MultiblockData$Type): void
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "renderBoundingBox"(): $AABB
get "computerCapabilityPersistent"(): boolean
get "structure"(): $Structure
get "reducedUpdateTag"(): $CompoundTag
get "cacheID"(): $UUID
set "structure"(value: $Structure$Type)
get "defaultData"(): T
get "master"(): boolean
get "multiblock"(): T
get "manager"(): $MultiblockManager<(T)>
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityMultiblock$Type<T> = ($TileEntityMultiblock<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityMultiblock_<T> = $TileEntityMultiblock$Type<(T)>;
}}
declare module "packages/mekanism/common/content/oredictionificator/$OredictionificatorFilter" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$BaseFilter, $BaseFilter$Type} from "packages/mekanism/common/content/filter/$BaseFilter"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $OredictionificatorFilter<TYPE, STACK, FILTER extends $OredictionificatorFilter<(TYPE), (STACK), (FILTER)>> extends $BaseFilter<(FILTER)> {


public "equals"(o: any): boolean
public "hashCode"(): integer
public "next"(): void
public "write"(nbtTags: $CompoundTag$Type): $CompoundTag
public "write"(buffer: $FriendlyByteBuf$Type): void
public "read"(nbtTags: $CompoundTag$Type): void
public "read"(buffer: $FriendlyByteBuf$Type): void
public "previous"(): void
public "getResult"(): STACK
public "computerSetFilter"(tag: $ResourceLocation$Type): void
public "checkValidity"(): void
public "flushCachedTag"(): void
public "filterMatches"(location: $ResourceLocation$Type): boolean
public "hasFilter"(): boolean
public "setSelectedOutput"(output: TYPE): void
public "setFilter"(location: $ResourceLocation$Type): void
public "getFilterText"(): string
public "getResultElement"(): TYPE
get "result"(): STACK
set "selectedOutput"(value: TYPE)
set "filter"(value: $ResourceLocation$Type)
get "filterText"(): string
get "resultElement"(): TYPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OredictionificatorFilter$Type<TYPE, STACK, FILTER> = ($OredictionificatorFilter<(TYPE), (STACK), (FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OredictionificatorFilter_<TYPE, STACK, FILTER> = $OredictionificatorFilter$Type<(TYPE), (STACK), (FILTER)>;
}}
declare module "packages/mekanism/common/inventory/container/$SelectedWindowData" {
import {$SelectedWindowData$WindowType, $SelectedWindowData$WindowType$Type} from "packages/mekanism/common/inventory/container/$SelectedWindowData$WindowType"
import {$SelectedWindowData$WindowPosition, $SelectedWindowData$WindowPosition$Type} from "packages/mekanism/common/inventory/container/$SelectedWindowData$WindowPosition"

export class $SelectedWindowData {
static readonly "UNSPECIFIED": $SelectedWindowData
readonly "type": $SelectedWindowData$WindowType
readonly "extraData": byte

constructor(type: $SelectedWindowData$WindowType$Type)
constructor(type: $SelectedWindowData$WindowType$Type, extraData: byte)

public "equals"(o: any): boolean
public "hashCode"(): integer
public "getLastPosition"(): $SelectedWindowData$WindowPosition
public "updateLastPosition"(x: integer, y: integer): void
get "lastPosition"(): $SelectedWindowData$WindowPosition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SelectedWindowData$Type = ($SelectedWindowData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SelectedWindowData_ = $SelectedWindowData$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemHazmatSuitArmor" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$ArmorItem, $ArmorItem$Type} from "packages/net/minecraft/world/item/$ArmorItem"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$DispenseItemBehavior, $DispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DispenseItemBehavior"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"

export class $ItemHazmatSuitArmor extends $ArmorItem {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(armorType: $ArmorItem$Type$Type, properties: $Item$Properties$Type)

public "initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public static "getShieldingByArmor"(type: $ArmorItem$Type$Type): double
public "getDefaultTooltipHideFlags"(stack: $ItemStack$Type): integer
public "canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "isEnchantable"(stack: $ItemStack$Type): boolean
public "isBookEnchantable"(stack: $ItemStack$Type, book: $ItemStack$Type): boolean
public static "get"(arg0: $ItemStack$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemHazmatSuitArmor$Type = ($ItemHazmatSuitArmor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemHazmatSuitArmor_ = $ItemHazmatSuitArmor$Type;
}}
declare module "packages/mekanism/common/config/value/$CachedValue$IConfigValueInvalidationListener" {
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export interface $CachedValue$IConfigValueInvalidationListener extends $Runnable {

 "run"(): void

(): void
}

export namespace $CachedValue$IConfigValueInvalidationListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedValue$IConfigValueInvalidationListener$Type = ($CachedValue$IConfigValueInvalidationListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedValue$IConfigValueInvalidationListener_ = $CachedValue$IConfigValueInvalidationListener$Type;
}}
declare module "packages/mekanism/common/tile/component/$ITileComponent" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"

export interface $ITileComponent {

 "write"(nbtTags: $CompoundTag$Type): void
 "read"(nbtTags: $CompoundTag$Type): void
 "removed"(): void
 "invalidate"(): void
 "trackForMainContainer"(container: $MekanismContainer$Type): void
 "readFromUpdateTag"(updateTag: $CompoundTag$Type): void
 "addToUpdateTag"(updateTag: $CompoundTag$Type): void
}

export namespace $ITileComponent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileComponent$Type = ($ITileComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileComponent_ = $ITileComponent$Type;
}}
declare module "packages/mekanism/common/lib/multiblock/$FormationProtocol$FormationResult" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ILangEntry, $ILangEntry$Type} from "packages/mekanism/api/text/$ILangEntry"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $FormationProtocol$FormationResult {
static readonly "SUCCESS": $FormationProtocol$FormationResult
static readonly "FAIL": $FormationProtocol$FormationResult


public static "fail"(text: $Component$Type): $FormationProtocol$FormationResult
public static "fail"(text: $Component$Type, noIgnore: boolean): $FormationProtocol$FormationResult
public static "fail"(text: $ILangEntry$Type, pos: $BlockPos$Type): $FormationProtocol$FormationResult
public static "fail"(text: $ILangEntry$Type, pos: $BlockPos$Type, noIgnore: boolean): $FormationProtocol$FormationResult
public static "fail"(text: $ILangEntry$Type): $FormationProtocol$FormationResult
public static "fail"(text: $ILangEntry$Type, noIgnore: boolean): $FormationProtocol$FormationResult
public "isFormed"(): boolean
public "isNoIgnore"(): boolean
public "getResultText"(): $Component
get "formed"(): boolean
get "noIgnore"(): boolean
get "resultText"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FormationProtocol$FormationResult$Type = ($FormationProtocol$FormationResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FormationProtocol$FormationResult_ = $FormationProtocol$FormationResult$Type;
}}
declare module "packages/mekanism/common/content/entangloporter/$InventoryFrequency" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IMekanismInventory, $IMekanismInventory$Type} from "packages/mekanism/api/inventory/$IMekanismInventory"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$IGasTracker, $IGasTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IGasTracker"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$IEnergyContainer, $IEnergyContainer$Type} from "packages/mekanism/api/energy/$IEnergyContainer"
import {$IPigmentTank, $IPigmentTank$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentTank"
import {$IPigmentTracker, $IPigmentTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IPigmentTracker"
import {$IHeatCapacitor, $IHeatCapacitor$Type} from "packages/mekanism/api/heat/$IHeatCapacitor"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMekanismFluidHandler, $IMekanismFluidHandler$Type} from "packages/mekanism/api/fluid/$IMekanismFluidHandler"
import {$IHeatHandler, $IHeatHandler$Type} from "packages/mekanism/api/heat/$IHeatHandler"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$IInfusionTank, $IInfusionTank$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionTank"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$IExtendedFluidTank, $IExtendedFluidTank$Type} from "packages/mekanism/api/fluid/$IExtendedFluidTank"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$HeatAPI$HeatTransfer, $HeatAPI$HeatTransfer$Type} from "packages/mekanism/api/heat/$HeatAPI$HeatTransfer"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$ISlurryTank, $ISlurryTank$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryTank"
import {$IMekanismStrictEnergyHandler, $IMekanismStrictEnergyHandler$Type} from "packages/mekanism/api/energy/$IMekanismStrictEnergyHandler"
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ISlurryTracker, $ISlurryTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$ISlurryTracker"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$ITileHeatHandler, $ITileHeatHandler$Type} from "packages/mekanism/common/capabilities/heat/$ITileHeatHandler"
import {$IInfusionTracker, $IInfusionTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IInfusionTracker"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"

export class $InventoryFrequency extends $Frequency implements $IMekanismInventory, $IMekanismFluidHandler, $IMekanismStrictEnergyHandler, $ITileHeatHandler, $IGasTracker, $IInfusionTracker, $IPigmentTracker, $ISlurryTracker {
 "storedEnergy": $IEnergyContainer

constructor(n: string, uuid: $UUID$Type)
constructor()

public "update"(tile: $BlockEntity$Type): boolean
public "write"(buffer: $FriendlyByteBuf$Type): void
public "write"(nbtTags: $CompoundTag$Type): void
public "handleEject"(gameTime: long): void
public "onContentsChanged"(): void
public "getEnergyContainers"(side: $Direction$Type): $List<($IEnergyContainer)>
public "getInventorySlots"(side: $Direction$Type): $List<($IInventorySlot)>
public "getFluidTanks"(side: $Direction$Type): $List<($IExtendedFluidTank)>
public "getInfusionTanks"(side: $Direction$Type): $List<($IInfusionTank)>
public "getPigmentTanks"(side: $Direction$Type): $List<($IPigmentTank)>
public "getGasTanks"(side: $Direction$Type): $List<($IGasTank)>
public "getHeatCapacitors"(side: $Direction$Type): $List<($IHeatCapacitor)>
public "getSlurryTanks"(side: $Direction$Type): $List<($ISlurryTank)>
public "onDeactivate"(tile: $BlockEntity$Type): boolean
public "getSlots"(arg0: $Direction$Type): integer
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: $Direction$Type, arg3: $Action$Type): $ItemStack
public "getStackInSlot"(arg0: integer, arg1: $Direction$Type): $ItemStack
public "getSlotLimit"(arg0: integer, arg1: $Direction$Type): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type, arg2: $Direction$Type): boolean
public "extractItem"(arg0: integer, arg1: integer, arg2: $Direction$Type, arg3: $Action$Type): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type, arg2: $Direction$Type): void
public "getInventorySlot"(arg0: integer, arg1: $Direction$Type): $IInventorySlot
public "hasInventory"(): boolean
public "isInventoryEmpty"(arg0: $Direction$Type): boolean
public "isInventoryEmpty"(): boolean
public "getTanks"(arg0: $Direction$Type): integer
public "getTankCapacity"(arg0: integer, arg1: $Direction$Type): integer
public "getFluidInTank"(arg0: integer, arg1: $Direction$Type): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type): boolean
public "getFluidTank"(arg0: integer, arg1: $Direction$Type): $IExtendedFluidTank
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type): void
public "insertFluid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type, arg3: $Action$Type): $FluidStack
public "canHandleFluid"(): boolean
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Direction$Type, arg3: $Action$Type): $FluidStack
public "getEnergyContainer"(arg0: integer, arg1: $Direction$Type): $IEnergyContainer
public "getEnergyContainerCount"(arg0: $Direction$Type): integer
public "extractEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type, arg3: $Action$Type): $FloatingLong
public "getEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "setEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type): void
public "canHandleEnergy"(): boolean
public "getMaxEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "getNeededEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "insertEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type, arg3: $Action$Type): $FloatingLong
public "simulate"(): $HeatAPI$HeatTransfer
public "getAmbientTemperature"(side: $Direction$Type): double
public "simulateEnvironment"(): double
public "updateHeatCapacitors"(side: $Direction$Type): void
public "incrementAdjacentTransfer"(currentAdjacentTransfer: double, tempToTransfer: double, side: $Direction$Type): double
public "getAdjacent"(side: $Direction$Type): $IHeatHandler
public "simulateAdjacent"(): double
public "getSlots"(): integer
public "getInventorySideFor"(): $Direction
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "getStackInSlot"(arg0: integer): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type): void
public "getTanks"(): integer
public "getTankCapacity"(arg0: integer): integer
public "getFluidInTank"(arg0: integer): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$Type): void
public "insertFluid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Action$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$Type, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "getFluidSideFor"(): $Direction
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Action$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$Type, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "getEnergyContainerCount"(): integer
public "extractEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Action$Type): $FloatingLong
public "extractEnergy"(arg0: $FloatingLong$Type, arg1: $Direction$Type, arg2: $Action$Type): $FloatingLong
public "getEnergy"(arg0: integer): $FloatingLong
public "setEnergy"(arg0: integer, arg1: $FloatingLong$Type): void
public "getMaxEnergy"(arg0: integer): $FloatingLong
public "getNeededEnergy"(arg0: integer): $FloatingLong
public "insertEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Action$Type): $FloatingLong
public "insertEnergy"(arg0: $FloatingLong$Type, arg1: $Direction$Type, arg2: $Action$Type): $FloatingLong
public "getEnergySideFor"(): $Direction
public "canHandleHeat"(): boolean
public "getHeatCapacity"(arg0: integer, arg1: $Direction$Type): double
public "getHeatCapacitor"(arg0: integer, arg1: $Direction$Type): $IHeatCapacitor
public "handleHeat"(arg0: integer, arg1: double, arg2: $Direction$Type): void
public "getTemperature"(arg0: integer, arg1: $Direction$Type): double
public "getHeatCapacitorCount"(arg0: $Direction$Type): integer
public "getTotalInverseInsulation"(arg0: $Direction$Type): double
public "getInverseConduction"(arg0: integer, arg1: $Direction$Type): double
public "getInverseInsulation"(arg0: integer, arg1: $Direction$Type): double
/**
 * 
 * @deprecated
 */
public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
/**
 * 
 * @deprecated
 */
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$Type, arg1: $Action$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Action$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$Type, arg1: $Action$Type): $FluidStack
public "extractEnergy"(arg0: $FloatingLong$Type, arg1: $Action$Type): $FloatingLong
public "insertEnergy"(arg0: $FloatingLong$Type, arg1: $Action$Type): $FloatingLong
public "getHeatCapacity"(arg0: integer): double
public "handleHeat"(arg0: double, arg1: $Direction$Type): void
public "handleHeat"(arg0: integer, arg1: double): void
public "getHeatSideFor"(): $Direction
public "getTotalInverseConductionCoefficient"(arg0: $Direction$Type): double
public "getTemperature"(arg0: integer): double
public "getTotalHeatCapacity"(arg0: $Direction$Type): double
public "getHeatCapacitorCount"(): integer
public "getInverseConduction"(arg0: integer): double
public "getTotalTemperature"(arg0: $Direction$Type): double
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "isMutable"(): boolean
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "getSlotLimit"(i: integer): integer
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "kjs$self"(): $IItemHandler
public "handleHeat"(arg0: double): void
public "getTotalHeatCapacity"(): double
public "getTotalInverseConduction"(): double
public "getTotalTemperature"(): double
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "asContainer"(): $Container
public "getWidth"(): integer
public "find"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "clear"(ingredient: $Ingredient$Type): void
public "clear"(): void
public "setChanged"(): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "getHeight"(): integer
get "inventoryEmpty"(): boolean
get "slots"(): integer
get "inventorySideFor"(): $Direction
get "tanks"(): integer
get "fluidSideFor"(): $Direction
get "energyContainerCount"(): integer
get "energySideFor"(): $Direction
get "heatSideFor"(): $Direction
get "heatCapacitorCount"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "totalHeatCapacity"(): double
get "totalInverseConduction"(): double
get "totalTemperature"(): double
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryFrequency$Type = ($InventoryFrequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryFrequency_ = $InventoryFrequency$Type;
}}
declare module "packages/mekanism/common/lib/frequency/$Frequency$FrequencyIdentity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FrequencyType, $FrequencyType$Type} from "packages/mekanism/common/lib/frequency/$FrequencyType"
import {$Record, $Record$Type} from "packages/java/lang/$Record"

export class $Frequency$FrequencyIdentity extends $Record {

constructor(key: any, isPublic: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "load"(type: $FrequencyType$Type<(any)>, tag: $CompoundTag$Type): $Frequency$FrequencyIdentity
public "isPublic"(): boolean
public "key"(): any
get "public"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Frequency$FrequencyIdentity$Type = ($Frequency$FrequencyIdentity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Frequency$FrequencyIdentity_ = $Frequency$FrequencyIdentity$Type;
}}
declare module "packages/mekanism/common/lib/transmitter/$ConnectionType" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$IHasTranslationKey, $IHasTranslationKey$Type} from "packages/mekanism/api/text/$IHasTranslationKey"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$IIncrementalEnum, $IIncrementalEnum$Type} from "packages/mekanism/api/$IIncrementalEnum"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$IHasTextComponent, $IHasTextComponent$Type} from "packages/mekanism/api/text/$IHasTextComponent"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $ConnectionType extends $Enum<($ConnectionType)> implements $IIncrementalEnum<($ConnectionType)>, $StringRepresentable, $IHasTranslationKey, $IHasTextComponent {
static readonly "NORMAL": $ConnectionType
static readonly "PUSH": $ConnectionType
static readonly "PULL": $ConnectionType
static readonly "NONE": $ConnectionType


public static "values"(): ($ConnectionType)[]
public static "valueOf"(name: string): $ConnectionType
public "getTranslationKey"(): string
public "byIndex"(index: integer): $ConnectionType
public "getSerializedName"(): string
public "getTextComponent"(): $Component
public static "byIndexStatic"(index: integer): $ConnectionType
public "ordinal"(): integer
public "adjust"(arg0: integer): $ConnectionType
public "adjust"(arg0: integer, arg1: $Predicate$Type<($ConnectionType$Type)>): $ConnectionType
public "getNext"(arg0: $Predicate$Type<($ConnectionType$Type)>): $ConnectionType
public "getNext"(): $ConnectionType
public "getPrevious"(): $ConnectionType
public "getPrevious"(arg0: $Predicate$Type<($ConnectionType$Type)>): $ConnectionType
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
get "translationKey"(): string
get "serializedName"(): string
get "textComponent"(): $Component
get "next"(): $ConnectionType
get "previous"(): $ConnectionType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConnectionType$Type = (("normal") | ("pull") | ("none") | ("push")) | ($ConnectionType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConnectionType_ = $ConnectionType$Type;
}}
declare module "packages/mekanism/common/content/qio/$IQIODriveHolder" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$Type} from "packages/mekanism/common/lib/frequency/$Frequency$FrequencyIdentity"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IQIOFrequencyHolder, $IQIOFrequencyHolder$Type} from "packages/mekanism/common/content/qio/$IQIOFrequencyHolder"
import {$TileComponentFrequency, $TileComponentFrequency$Type} from "packages/mekanism/common/lib/frequency/$TileComponentFrequency"
import {$QIODriveData, $QIODriveData$Type} from "packages/mekanism/common/content/qio/$QIODriveData"
import {$QIOFrequency, $QIOFrequency$Type} from "packages/mekanism/common/content/qio/$QIOFrequency"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$FrequencyType, $FrequencyType$Type} from "packages/mekanism/common/lib/frequency/$FrequencyType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IQIODriveHolder extends $IQIOFrequencyHolder {

 "save"(slot: integer, data: $QIODriveData$Type): void
 "onDataUpdate"(): void
 "getDriveSlots"(): $List<($IInventorySlot)>
 "getPrivateFrequencies"(): $List<($QIOFrequency)>
 "getPublicFrequencies"(): $List<($QIOFrequency)>
 "getFrequencyComponent"(): $TileComponentFrequency
 "getFrequency"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): FREQ
 "setFrequency"(type: $FrequencyType$Type<(any)>, data: $Frequency$FrequencyIdentity$Type, player: $UUID$Type): void
 "setFrequency"(type: $FrequencyType$Type<(any)>, frequencyCompound: $CompoundTag$Type): void
 "removeFrequency"(type: $FrequencyType$Type<(any)>, data: $Frequency$FrequencyIdentity$Type, player: $UUID$Type): void
 "getPublicCache"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): $List<(FREQ)>
 "getPrivateCache"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): $List<(FREQ)>
 "getTilePos"(): $BlockPos
 "getTileWorld"(): $Level
 "getTileCoord"(): $Coord4D
 "getTileChunk"(): $Chunk3D
}

export namespace $IQIODriveHolder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IQIODriveHolder$Type = ($IQIODriveHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IQIODriveHolder_ = $IQIODriveHolder$Type;
}}
declare module "packages/mekanism/common/lib/math/voxel/$VoxelCuboid$CuboidRelative" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $VoxelCuboid$CuboidRelative extends $Enum<($VoxelCuboid$CuboidRelative)> {
static readonly "INSIDE": $VoxelCuboid$CuboidRelative
static readonly "OUTSIDE": $VoxelCuboid$CuboidRelative
static readonly "WALLS": $VoxelCuboid$CuboidRelative


public static "values"(): ($VoxelCuboid$CuboidRelative)[]
public static "valueOf"(name: string): $VoxelCuboid$CuboidRelative
public "isWall"(): boolean
get "wall"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VoxelCuboid$CuboidRelative$Type = (("walls") | ("outside") | ("inside")) | ($VoxelCuboid$CuboidRelative);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VoxelCuboid$CuboidRelative_ = $VoxelCuboid$CuboidRelative$Type;
}}
declare module "packages/mekanism/common/inventory/container/type/$MekanismItemContainerType$IMekanismSidedItemContainerFactory" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$MekanismItemContainerType$IMekanismItemContainerFactory, $MekanismItemContainerType$IMekanismItemContainerFactory$Type} from "packages/mekanism/common/inventory/container/type/$MekanismItemContainerType$IMekanismItemContainerFactory"

export interface $MekanismItemContainerType$IMekanismSidedItemContainerFactory<ITEM extends $Item, CONTAINER extends $AbstractContainerMenu> extends $MekanismItemContainerType$IMekanismItemContainerFactory<(ITEM), (CONTAINER)> {

 "create"(id: integer, inv: $Inventory$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type, remote: boolean): CONTAINER
 "create"(id: integer, inv: $Inventory$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type): CONTAINER

(id: integer, inv: $Inventory$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type, remote: boolean): CONTAINER
}

export namespace $MekanismItemContainerType$IMekanismSidedItemContainerFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismItemContainerType$IMekanismSidedItemContainerFactory$Type<ITEM, CONTAINER> = ($MekanismItemContainerType$IMekanismSidedItemContainerFactory<(ITEM), (CONTAINER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismItemContainerType$IMekanismSidedItemContainerFactory_<ITEM, CONTAINER> = $MekanismItemContainerType$IMekanismSidedItemContainerFactory$Type<(ITEM), (CONTAINER)>;
}}
declare module "packages/mekanism/common/item/block/machine/$ItemBlockMachine" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemBlockTooltip, $ItemBlockTooltip$Type} from "packages/mekanism/common/item/block/$ItemBlockTooltip"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ListTag, $ListTag$Type} from "packages/net/minecraft/nbt/$ListTag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockTile, $BlockTile$Type} from "packages/mekanism/common/block/prefab/$BlockTile"
import {$IItemSustainedInventory, $IItemSustainedInventory$Type} from "packages/mekanism/common/item/interfaces/$IItemSustainedInventory"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockMachine extends $ItemBlockTooltip<($BlockTile<(any), (any)>)> implements $IItemSustainedInventory {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockTile$Type<(any), (any)>)

public "getSustainedInventory"(stack: $ItemStack$Type): $ListTag
public "getSustainedInventory"(): $ListTag
public "setSustainedInventory"(nbtTags: $ListTag$Type): void
public "setSustainedInventory"(nbtTags: $ListTag$Type, stack: $ItemStack$Type): void
public "getDroppedSlots"(stack: $ItemStack$Type): $List<($IInventorySlot)>
public "hasSustainedInventory"(stack: $ItemStack$Type): boolean
public "hasSustainedInventory"(): boolean
public "canContentsDrop"(stack: $ItemStack$Type): boolean
get "sustainedInventory"(): $ListTag
set "sustainedInventory"(value: $ListTag$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockMachine$Type = ($ItemBlockMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockMachine_ = $ItemBlockMachine$Type;
}}
declare module "packages/mekanism/common/block/interfaces/$ITypeBlock" {
import {$BlockType, $BlockType$Type} from "packages/mekanism/common/content/blocktype/$BlockType"

export interface $ITypeBlock {

 "getType"(): $BlockType

(): $BlockType
}

export namespace $ITypeBlock {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITypeBlock$Type = ($ITypeBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITypeBlock_ = $ITypeBlock$Type;
}}
declare module "packages/mekanism/common/item/block/$ItemBlockRadioactiveWasteBarrel" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemBlockTooltip, $ItemBlockTooltip$Type} from "packages/mekanism/common/item/block/$ItemBlockTooltip"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$BlockRadioactiveWasteBarrel, $BlockRadioactiveWasteBarrel$Type} from "packages/mekanism/common/block/$BlockRadioactiveWasteBarrel"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockRadioactiveWasteBarrel extends $ItemBlockTooltip<($BlockRadioactiveWasteBarrel)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockRadioactiveWasteBarrel$Type, properties: $Item$Properties$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockRadioactiveWasteBarrel$Type = ($ItemBlockRadioactiveWasteBarrel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockRadioactiveWasteBarrel_ = $ItemBlockRadioactiveWasteBarrel$Type;
}}
declare module "packages/mekanism/common/block/transmitter/$BlockDiversionTransporter" {
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$TileEntityDiversionTransporter, $TileEntityDiversionTransporter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityDiversionTransporter"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$IHasTileEntity, $IHasTileEntity$Type} from "packages/mekanism/common/block/interfaces/$IHasTileEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockLargeTransmitter, $BlockLargeTransmitter$Type} from "packages/mekanism/common/block/transmitter/$BlockLargeTransmitter"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export class $BlockDiversionTransporter extends $BlockLargeTransmitter implements $IHasTileEntity<($TileEntityDiversionTransporter)> {
static readonly "CENTER": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor()

public "getTileType"(): $TileEntityTypeRegistryObject<($TileEntityDiversionTransporter)>
public "createDummyBlockEntity"(state: $BlockState$Type): $TileEntityDiversionTransporter
public "createDummyBlockEntity"(): $TileEntityDiversionTransporter
public "triggerBlockEntityEvent"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, id: integer, param: integer): boolean
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $TileEntityDiversionTransporter
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
get "tileType"(): $TileEntityTypeRegistryObject<($TileEntityDiversionTransporter)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDiversionTransporter$Type = ($BlockDiversionTransporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockDiversionTransporter_ = $BlockDiversionTransporter$Type;
}}
declare module "packages/mekanism/common/world/$ResizableOreFeatureConfig" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ConfiguredFeature, $ConfiguredFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$ConfiguredFeature"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration$TargetBlockState"
import {$FeatureConfiguration, $FeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$FeatureConfiguration"
import {$OreType$OreVeinType, $OreType$OreVeinType$Type} from "packages/mekanism/common/resource/ore/$OreType$OreVeinType"
import {$FloatSupplier, $FloatSupplier$Type} from "packages/mekanism/api/functions/$FloatSupplier"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $ResizableOreFeatureConfig extends $Record implements $FeatureConfiguration {
static readonly "CODEC": $Codec<($ResizableOreFeatureConfig)>

constructor(targetStates: $List$Type<($OreConfiguration$TargetBlockState$Type)>, oreVeinType: $OreType$OreVeinType$Type, size: $IntSupplier$Type, discardChanceOnAirExposure: $FloatSupplier$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "size"(): $IntSupplier
public "discardChanceOnAirExposure"(): $FloatSupplier
public "oreVeinType"(): $OreType$OreVeinType
public "targetStates"(): $List<($OreConfiguration$TargetBlockState)>
public "getFeatures"(): $Stream<($ConfiguredFeature<(any), (any)>)>
get "features"(): $Stream<($ConfiguredFeature<(any), (any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResizableOreFeatureConfig$Type = ($ResizableOreFeatureConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResizableOreFeatureConfig_ = $ResizableOreFeatureConfig$Type;
}}
declare module "packages/mekanism/common/tile/$TileEntityRadioactiveWasteBarrel" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IConfigurable, $IConfigurable$Type} from "packages/mekanism/api/$IConfigurable"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$StackedWasteBarrel, $StackedWasteBarrel$Type} from "packages/mekanism/common/capabilities/chemical/$StackedWasteBarrel"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$Gas, $Gas$Type} from "packages/mekanism/api/chemical/gas/$Gas"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$IChemicalTankHolder, $IChemicalTankHolder$Type} from "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export class $TileEntityRadioactiveWasteBarrel extends $TileEntityMekanism implements $IConfigurable {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "getGasTank"(): $StackedWasteBarrel
public "getInitialGasTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($Gas), ($GasStack), ($IGasTank)>
public "onRightClick"(player: $Player$Type): $InteractionResult
public "getRedstoneLevel"(): integer
public "getReducedUpdateTag"(): $CompoundTag
public "onSneakRightClick"(player: $Player$Type): $InteractionResult
public "getGasScale"(): double
public "getGas"(): $GasStack
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "gasTank"(): $StackedWasteBarrel
get "redstoneLevel"(): integer
get "reducedUpdateTag"(): $CompoundTag
get "gasScale"(): double
get "gas"(): $GasStack
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityRadioactiveWasteBarrel$Type = ($TileEntityRadioactiveWasteBarrel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityRadioactiveWasteBarrel_ = $TileEntityRadioactiveWasteBarrel$Type;
}}
declare module "packages/mekanism/common/config/value/$CachedFloatValue" {
import {$IMekanismConfig, $IMekanismConfig$Type} from "packages/mekanism/common/config/$IMekanismConfig"
import {$ForgeConfigSpec$ConfigValue, $ForgeConfigSpec$ConfigValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue"
import {$FloatSupplier, $FloatSupplier$Type} from "packages/mekanism/api/functions/$FloatSupplier"
import {$CachedValue, $CachedValue$Type} from "packages/mekanism/common/config/value/$CachedValue"

export class $CachedFloatValue extends $CachedValue<(double)> implements $FloatSupplier {


public "get"(): float
public static "wrap"(config: $IMekanismConfig$Type, internal: $ForgeConfigSpec$ConfigValue$Type<(double)>): $CachedFloatValue
public "set"(value: float): void
public "getOrDefault"(): float
public "getAsFloat"(): float
get "orDefault"(): float
get "asFloat"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedFloatValue$Type = ($CachedFloatValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedFloatValue_ = $CachedFloatValue$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$SingleChemical" {
import {$ChemicalStackIngredient, $ChemicalStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient"
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$ChemicalInputCache, $ChemicalInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$ChemicalInputCache"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$SingleInputRecipeCache, $SingleInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$SingleInputRecipeCache"
import {$MekanismRecipeType, $MekanismRecipeType$Type} from "packages/mekanism/common/recipe/$MekanismRecipeType"

export class $InputRecipeCache$SingleChemical<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, RECIPE extends ($MekanismRecipe) & ($Predicate<(STACK)>)> extends $SingleInputRecipeCache<(STACK), ($ChemicalStackIngredient<(CHEMICAL), (STACK)>), (RECIPE), ($ChemicalInputCache<(CHEMICAL), (STACK), (RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$Type<(RECIPE), (any)>, inputExtractor: $Function$Type<(RECIPE), ($ChemicalStackIngredient$Type<(CHEMICAL), (STACK)>)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$SingleChemical$Type<CHEMICAL, STACK, RECIPE> = ($InputRecipeCache$SingleChemical<(CHEMICAL), (STACK), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$SingleChemical_<CHEMICAL, STACK, RECIPE> = $InputRecipeCache$SingleChemical$Type<(CHEMICAL), (STACK), (RECIPE)>;
}}
declare module "packages/mekanism/common/lib/inventory/$TransitRequest$SimpleTransitRequest" {
import {$TransitRequest, $TransitRequest$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest"
import {$TransitRequest$ItemData, $TransitRequest$ItemData$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest$ItemData"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export class $TransitRequest$SimpleTransitRequest extends $TransitRequest {


public "getItemData"(): $Collection<($TransitRequest$ItemData)>
get "itemData"(): $Collection<($TransitRequest$ItemData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransitRequest$SimpleTransitRequest$Type = ($TransitRequest$SimpleTransitRequest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransitRequest$SimpleTransitRequest_ = $TransitRequest$SimpleTransitRequest$Type;
}}
declare module "packages/mekanism/common/integration/computer/$BaseComputerHelper" {
import {$QIOFilter, $QIOFilter$Type} from "packages/mekanism/common/content/qio/filter/$QIOFilter"
import {$Vec3i, $Vec3i$Type} from "packages/net/minecraft/core/$Vec3i"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TableType, $TableType$Type} from "packages/mekanism/common/integration/computer/$TableType"
import {$IFilter, $IFilter$Type} from "packages/mekanism/common/content/filter/$IFilter"
import {$Lazy, $Lazy$Type} from "packages/net/minecraftforge/common/util/$Lazy"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Convertable, $Convertable$Type} from "packages/mekanism/common/integration/computer/$Convertable"
import {$MethodHelpData, $MethodHelpData$Type} from "packages/mekanism/common/integration/computer/$MethodHelpData"
import {$MinerFilter, $MinerFilter$Type} from "packages/mekanism/common/content/miner/$MinerFilter"
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$OredictionificatorFilter, $OredictionificatorFilter$Type} from "packages/mekanism/common/content/oredictionificator/$OredictionificatorFilter"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$SorterFilter, $SorterFilter$Type} from "packages/mekanism/common/content/transporter/$SorterFilter"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BaseComputerHelper {
static readonly "BUILTIN_TABLES": $Lazy<($Map<($Class<(any)>), ($TableType)>)>

constructor()

public "getBoolean"(param: integer): boolean
public "getByte"(param: integer): byte
public "getShort"(param: integer): short
public "getChar"(param: integer): character
public "getInt"(param: integer): integer
public "getLong"(param: integer): long
public "getFloat"(param: integer): float
public "getDouble"(param: integer): double
public "convert"(coord: $Coord4D$Type): any
public "convert"(pos: $Vec3i$Type): any
public "convert"(state: $BlockState$Type): any
public "convert"(frequency: $Frequency$Type): any
public "convert"(res: $Enum$Type<(any)>): any
public "convert"(rl: $ResourceLocation$Type): any
public "convert"(stack: $ChemicalStack$Type<(any)>): any
public "convert"(stack: $FluidStack$Type): any
public "convert"(stack: $ItemStack$Type): any
public "convert"<KEY, VALUE>(res: $Map$Type<(KEY), (VALUE)>, keyConverter: $Function$Type<(KEY), (any)>, valueConverter: $Function$Type<(VALUE), (any)>): any
public "convert"(item: $Item$Type): any
public "convert"(convertable: $Convertable$Type<(any)>): any
public "convert"(methodHelpData: $MethodHelpData$Type): any
public "convert"(minerFilter: $MinerFilter$Type<(any)>): any
public "convert"(sorterFilter: $SorterFilter$Type<(any)>): any
public "convert"(qioFilter: $QIOFilter$Type<(any)>): any
public "convert"(filter: $OredictionificatorFilter$Type<(any), (any), (any)>): any
public "convert"(d: double): any
public "convert"(i: long): any
public "convert"(uuid: $UUID$Type): any
public "convert"(result: $FloatingLong$Type): any
public "convert"(i: integer): any
public "convert"<T>(list: $Collection$Type<(T)>, converter: $Function$Type<(T), (any)>): any
public "convert"(b: boolean): any
public "convert"(s: string): any
public "getMap"(param: integer): $Map<(any), (any)>
public "getFilter"<FILTER extends $IFilter<(FILTER)>>(param: integer, expectedType: $Class$Type<(FILTER)>): FILTER
public static "convertType"(clazz: $Class$Type<(any)>): $Class<(any)>
public "getItem"(param: integer): $Item
public "getString"(param: integer): string
public "getResourceLocation"(param: integer): $ResourceLocation
public "getEnum"<T extends $Enum<(T)>>(param: integer, enumClazz: $Class$Type<(T)>): T
public "getFloatingLong"(param: integer): $FloatingLong
public "getItemStack"(param: integer): $ItemStack
public "voidResult"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseComputerHelper$Type = ($BaseComputerHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseComputerHelper_ = $BaseComputerHelper$Type;
}}
declare module "packages/mekanism/common/item/block/transmitter/$ItemBlockRestrictiveTransporter" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemBlockMekanism, $ItemBlockMekanism$Type} from "packages/mekanism/common/item/block/$ItemBlockMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockRestrictiveTransporter, $BlockRestrictiveTransporter$Type} from "packages/mekanism/common/block/transmitter/$BlockRestrictiveTransporter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockRestrictiveTransporter extends $ItemBlockMekanism<($BlockRestrictiveTransporter)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockRestrictiveTransporter$Type)

public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockRestrictiveTransporter$Type = ($ItemBlockRestrictiveTransporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockRestrictiveTransporter_ = $ItemBlockRestrictiveTransporter$Type;
}}
declare module "packages/mekanism/common/item/interfaces/$IUpgradeItem" {
import {$Upgrade, $Upgrade$Type} from "packages/mekanism/api/$Upgrade"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IUpgradeItem {

 "getUpgradeType"(stack: $ItemStack$Type): $Upgrade

(stack: $ItemStack$Type): $Upgrade
}

export namespace $IUpgradeItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IUpgradeItem$Type = ($IUpgradeItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IUpgradeItem_ = $IUpgradeItem$Type;
}}
declare module "packages/mekanism/common/capabilities/holder/$IHolder" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"

export interface $IHolder {

 "canInsert"(direction: $Direction$Type): boolean
 "canExtract"(direction: $Direction$Type): boolean
}

export namespace $IHolder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHolder$Type = ($IHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHolder_ = $IHolder$Type;
}}
declare module "packages/mekanism/common/item/block/$ItemBlockInductionProvider" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemBlockTooltip, $ItemBlockTooltip$Type} from "packages/mekanism/common/item/block/$ItemBlockTooltip"
import {$InductionProviderTier, $InductionProviderTier$Type} from "packages/mekanism/common/tier/$InductionProviderTier"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$BlockTile, $BlockTile$Type} from "packages/mekanism/common/block/prefab/$BlockTile"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$TileEntityInductionProvider, $TileEntityInductionProvider$Type} from "packages/mekanism/common/tile/multiblock/$TileEntityInductionProvider"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockInductionProvider extends $ItemBlockTooltip<($BlockTile<($TileEntityInductionProvider), ($BlockTypeTile<($TileEntityInductionProvider)>)>)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockTile$Type<($TileEntityInductionProvider$Type), ($BlockTypeTile$Type<($TileEntityInductionProvider$Type)>)>)

public "getTier"(): $InductionProviderTier
get "tier"(): $InductionProviderTier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockInductionProvider$Type = ($ItemBlockInductionProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockInductionProvider_ = $ItemBlockInductionProvider$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemAtomicDisassembler" {
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ItemAtomicDisassembler$DisassemblerMode, $ItemAtomicDisassembler$DisassemblerMode$Type} from "packages/mekanism/common/item/gear/$ItemAtomicDisassembler$DisassemblerMode"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ImmutableMultimap$Builder, $ImmutableMultimap$Builder$Type} from "packages/com/google/common/collect/$ImmutableMultimap$Builder"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$ItemEnergized, $ItemEnergized$Type} from "packages/mekanism/common/item/$ItemEnergized"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IAttributeRefresher, $IAttributeRefresher$Type} from "packages/mekanism/common/lib/attribute/$IAttributeRefresher"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$IRadialEnumModeItem, $IRadialEnumModeItem$Type} from "packages/mekanism/common/lib/radial/$IRadialEnumModeItem"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$IRadialMode, $IRadialMode$Type} from "packages/mekanism/api/radial/mode/$IRadialMode"
import {$RadialData, $RadialData$Type} from "packages/mekanism/api/radial/$RadialData"
import {$IItemHUDProvider, $IItemHUDProvider$Type} from "packages/mekanism/common/item/interfaces/$IItemHUDProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemAtomicDisassembler extends $ItemEnergized implements $IItemHUDProvider, $IRadialEnumModeItem<($ItemAtomicDisassembler$DisassemblerMode)>, $IAttributeRefresher {
static readonly "ALWAYS_SUPPORTED_ACTIONS": $Set<($ToolAction)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "initializeClient"(consumer: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "canPerformAction"(stack: $ItemStack$Type, action: $ToolAction$Type): boolean
public static "fullyChargedStack"(): $ItemStack
public "addToBuilder"(builder: $ImmutableMultimap$Builder$Type<($Attribute$Type), ($AttributeModifier$Type)>): void
public "getAttributeModifiers"(slot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "isCorrectToolForDrops"(state: $BlockState$Type): boolean
public "mineBlock"(stack: $ItemStack$Type, world: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, entityliving: $LivingEntity$Type): boolean
public "getDestroySpeed"(stack: $ItemStack$Type, state: $BlockState$Type): float
public "hurtEnemy"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "isEnchantable"(stack: $ItemStack$Type): boolean
public "onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "isBookEnchantable"(stack: $ItemStack$Type, book: $ItemStack$Type): boolean
public "getScrollTextComponent"(stack: $ItemStack$Type): $Component
public "getModeSaveKey"(): string
public "getRadialData"(stack: $ItemStack$Type): $RadialData<($ItemAtomicDisassembler$DisassemblerMode)>
public "addHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): void
public "getModeByIndex"(ordinal: integer): $ItemAtomicDisassembler$DisassemblerMode
public "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
public "addCurioHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type): void
public "setMode"(stack: $ItemStack$Type, player: $Player$Type, mode: $ItemAtomicDisassembler$DisassemblerMode$Type): void
public "setMode"<M extends $IRadialMode>(stack: $ItemStack$Type, player: $Player$Type, radialData: $RadialData$Type<(M)>, mode: M): void
public "getMode"<M extends $IRadialMode>(stack: $ItemStack$Type, radialData: $RadialData$Type<(M)>): M
public "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "displayModeChange"(player: $Player$Type): void
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
get "modeSaveKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemAtomicDisassembler$Type = ($ItemAtomicDisassembler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemAtomicDisassembler_ = $ItemAtomicDisassembler$Type;
}}
declare module "packages/mekanism/common/capabilities/chemical/item/$ChemicalTankSpec" {
import {$TriPredicate, $TriPredicate$Type} from "packages/net/minecraftforge/common/util/$TriPredicate"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$GenericTankSpec, $GenericTankSpec$Type} from "packages/mekanism/common/capabilities/$GenericTankSpec"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LongSupplier, $LongSupplier$Type} from "packages/java/util/function/$LongSupplier"

export class $ChemicalTankSpec<CHEMICAL extends $Chemical<(CHEMICAL)>> extends $GenericTankSpec<(CHEMICAL)> {
readonly "isValid": $Predicate<(TYPE)>
readonly "canExtract": $BiPredicate<(TYPE), ($AutomationType)>
readonly "canInsert": $TriPredicate<(TYPE), ($AutomationType), ($ItemStack)>

constructor(rate: $LongSupplier$Type, capacity: $LongSupplier$Type, canExtract: $BiPredicate$Type<(CHEMICAL), ($AutomationType$Type)>, canInsert: $TriPredicate$Type<(CHEMICAL), ($AutomationType$Type), ($ItemStack$Type)>, isValid: $Predicate$Type<(CHEMICAL)>, supportsStack: $Predicate$Type<($ItemStack$Type)>)

public static "createFillOnly"<CHEMICAL extends $Chemical<(CHEMICAL)>>(rate: $LongSupplier$Type, capacity: $LongSupplier$Type, isValid: $Predicate$Type<(CHEMICAL)>): $ChemicalTankSpec<(CHEMICAL)>
public static "createFillOnly"<CHEMICAL extends $Chemical<(CHEMICAL)>>(rate: $LongSupplier$Type, capacity: $LongSupplier$Type, isValid: $Predicate$Type<(CHEMICAL)>, supportsStack: $Predicate$Type<($ItemStack$Type)>): $ChemicalTankSpec<(CHEMICAL)>
public static "create"<CHEMICAL extends $Chemical<(CHEMICAL)>>(rate: $LongSupplier$Type, capacity: $LongSupplier$Type): $ChemicalTankSpec<(CHEMICAL)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalTankSpec$Type<CHEMICAL> = ($ChemicalTankSpec<(CHEMICAL)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalTankSpec_<CHEMICAL> = $ChemicalTankSpec$Type<(CHEMICAL)>;
}}
declare module "packages/mekanism/common/tier/$ConductorTier" {
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Color, $Color$Type} from "packages/mekanism/common/lib/$Color"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"
import {$CachedDoubleValue, $CachedDoubleValue$Type} from "packages/mekanism/common/config/value/$CachedDoubleValue"

export class $ConductorTier extends $Enum<($ConductorTier)> implements $ITier {
static readonly "BASIC": $ConductorTier
static readonly "ADVANCED": $ConductorTier
static readonly "ELITE": $ConductorTier
static readonly "ULTIMATE": $ConductorTier


public static "get"(tier: $BaseTier$Type): $ConductorTier
public static "values"(): ($ConductorTier)[]
public static "valueOf"(name: string): $ConductorTier
public "getHeatCapacity"(): double
public "getBaseHeatCapacity"(): double
public "getBaseConductionInsulation"(): double
public "getBaseTier"(): $BaseTier
public "setConfigReference"(conductionReference: $CachedDoubleValue$Type, capacityReference: $CachedDoubleValue$Type, insulationReference: $CachedDoubleValue$Type): void
public "getInverseConductionInsulation"(): double
public "getBaseConduction"(): double
public "getBaseColor"(): $Color
public "getInverseConduction"(): double
get "heatCapacity"(): double
get "baseHeatCapacity"(): double
get "baseConductionInsulation"(): double
get "baseTier"(): $BaseTier
get "inverseConductionInsulation"(): double
get "baseConduction"(): double
get "baseColor"(): $Color
get "inverseConduction"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConductorTier$Type = (("elite") | ("advanced") | ("ultimate") | ("basic")) | ($ConductorTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConductorTier_ = $ConductorTier$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemCanteen" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$CreativeModeTab$Output, $CreativeModeTab$Output$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$Output"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CapabilityItem, $CapabilityItem$Type} from "packages/mekanism/common/item/$CapabilityItem"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$Type} from "packages/mekanism/common/registration/impl/$CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$UseAnim, $UseAnim$Type} from "packages/net/minecraft/world/item/$UseAnim"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemCanteen extends $CapabilityItem implements $CreativeTabDeferredRegister$ICustomCreativeTabContents {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "addItems"(tabOutput: $CreativeModeTab$Output$Type): void
public "getUseDuration"(stack: $ItemStack$Type): integer
public "use"(worldIn: $Level$Type, playerIn: $Player$Type, handIn: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "finishUsingItem"(stack: $ItemStack$Type, world: $Level$Type, entityLiving: $LivingEntity$Type): $ItemStack
public "isBarVisible"(stack: $ItemStack$Type): boolean
public "getBarWidth"(stack: $ItemStack$Type): integer
public "getBarColor"(stack: $ItemStack$Type): integer
public "getUseAnimation"(stack: $ItemStack$Type): $UseAnim
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "addDefault"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemCanteen$Type = ($ItemCanteen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemCanteen_ = $ItemCanteen$Type;
}}
declare module "packages/mekanism/common/registration/impl/$FluidDeferredRegister$FluidTypeRenderProperties" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $FluidDeferredRegister$FluidTypeRenderProperties {


public static "builder"(): $FluidDeferredRegister$FluidTypeRenderProperties
public "texture"(still: $ResourceLocation$Type, flowing: $ResourceLocation$Type, overlay: $ResourceLocation$Type): $FluidDeferredRegister$FluidTypeRenderProperties
public "texture"(still: $ResourceLocation$Type, flowing: $ResourceLocation$Type): $FluidDeferredRegister$FluidTypeRenderProperties
public "renderOverlay"(renderOverlay: $ResourceLocation$Type): $FluidDeferredRegister$FluidTypeRenderProperties
public "tint"(color: integer): $FluidDeferredRegister$FluidTypeRenderProperties
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidDeferredRegister$FluidTypeRenderProperties$Type = ($FluidDeferredRegister$FluidTypeRenderProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidDeferredRegister$FluidTypeRenderProperties_ = $FluidDeferredRegister$FluidTypeRenderProperties$Type;
}}
declare module "packages/mekanism/common/item/interfaces/$IItemHUDProvider" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IItemHUDProvider {

 "addCurioHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type): void
 "addHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): void

(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type): void
}

export namespace $IItemHUDProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IItemHUDProvider$Type = ($IItemHUDProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IItemHUDProvider_ = $IItemHUDProvider$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ItemStackChemicalToItemStackRecipeSerializer" {
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$ChemicalStackIngredient, $ChemicalStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ItemStackChemicalToItemStackRecipe, $ItemStackChemicalToItemStackRecipe$Type} from "packages/mekanism/api/recipes/chemical/$ItemStackChemicalToItemStackRecipe"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ItemStackChemicalToItemStackRecipeSerializer<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, INGREDIENT extends $ChemicalStackIngredient<(CHEMICAL), (STACK)>, RECIPE extends $ItemStackChemicalToItemStackRecipe<(CHEMICAL), (STACK), (INGREDIENT)>> implements $RecipeSerializer<(RECIPE)> {


public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackChemicalToItemStackRecipeSerializer$Type<CHEMICAL, STACK, INGREDIENT, RECIPE> = ($ItemStackChemicalToItemStackRecipeSerializer<(CHEMICAL), (STACK), (INGREDIENT), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackChemicalToItemStackRecipeSerializer_<CHEMICAL, STACK, INGREDIENT, RECIPE> = $ItemStackChemicalToItemStackRecipeSerializer$Type<(CHEMICAL), (STACK), (INGREDIENT), (RECIPE)>;
}}
declare module "packages/mekanism/common/content/gear/$IModuleContainerItem" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IModule, $IModule$Type} from "packages/mekanism/api/gear/$IModule"
import {$Module, $Module$Type} from "packages/mekanism/common/content/gear/$Module"
import {$IModuleDataProvider, $IModuleDataProvider$Type} from "packages/mekanism/api/providers/$IModuleDataProvider"
import {$IHUDElement, $IHUDElement$Type} from "packages/mekanism/api/gear/$IHUDElement"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ICustomModule, $ICustomModule$Type} from "packages/mekanism/api/gear/$ICustomModule"
import {$ModuleData, $ModuleData$Type} from "packages/mekanism/api/gear/$ModuleData"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IItemHUDProvider, $IItemHUDProvider$Type} from "packages/mekanism/common/item/interfaces/$IItemHUDProvider"

export interface $IModuleContainerItem extends $IItemHUDProvider {

 "getModule"<MODULE extends $ICustomModule<(MODULE)>>(stack: $ItemStack$Type, typeProvider: $IModuleDataProvider$Type<(MODULE)>): $IModule<(MODULE)>
 "addModuleDetails"(stack: $ItemStack$Type, tooltip: $List$Type<($Component$Type)>): void
 "isModuleEnabled"(stack: $ItemStack$Type, type: $IModuleDataProvider$Type<(any)>): boolean
 "supportsModule"(stack: $ItemStack$Type, typeProvider: $IModuleDataProvider$Type<(any)>): boolean
 "getHUDElements"(player: $Player$Type, stack: $ItemStack$Type): $List<($IHUDElement)>
 "removeModule"(stack: $ItemStack$Type, type: $ModuleData$Type<(any)>): void
 "hasModule"(stack: $ItemStack$Type, type: $IModuleDataProvider$Type<(any)>): boolean
 "addModule"(stack: $ItemStack$Type, type: $ModuleData$Type<(any)>): void
 "getModules"(stack: $ItemStack$Type): $List<($Module<(any)>)>
 "addHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): void
 "addCurioHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type): void
}

export namespace $IModuleContainerItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModuleContainerItem$Type = ($IModuleContainerItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModuleContainerItem_ = $IModuleContainerItem$Type;
}}
declare module "packages/mekanism/common/content/blocktype/$Factory" {
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$ContainerTypeRegistryObject, $ContainerTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$ContainerTypeRegistryObject"
import {$FactoryTier, $FactoryTier$Type} from "packages/mekanism/common/tier/$FactoryTier"
import {$TileEntityFactory, $TileEntityFactory$Type} from "packages/mekanism/common/tile/factory/$TileEntityFactory"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Machine$FactoryMachine, $Machine$FactoryMachine$Type} from "packages/mekanism/common/content/blocktype/$Machine$FactoryMachine"

export class $Factory<TILE extends $TileEntityFactory<(any)>> extends $Machine$FactoryMachine<(TILE)> {

constructor(tileEntityRegistrar: $Supplier$Type<($TileEntityTypeRegistryObject$Type<(TILE)>)>, containerRegistrar: $Supplier$Type<($ContainerTypeRegistryObject$Type<(any)>)>, origMachine: $Machine$FactoryMachine$Type<(any)>, tier: $FactoryTier$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Factory$Type<TILE> = ($Factory<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Factory_<TILE> = $Factory$Type<(TILE)>;
}}
declare module "packages/mekanism/common/recipe/serializer/$ItemStackToChemicalRecipeSerializer$IFactory" {
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$ItemStackToChemicalRecipe, $ItemStackToChemicalRecipe$Type} from "packages/mekanism/api/recipes/chemical/$ItemStackToChemicalRecipe"
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $ItemStackToChemicalRecipeSerializer$IFactory<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, RECIPE extends $ItemStackToChemicalRecipe<(CHEMICAL), (STACK)>> {

 "create"(id: $ResourceLocation$Type, input: $ItemStackIngredient$Type, output: STACK): RECIPE

(id: $ResourceLocation$Type, input: $ItemStackIngredient$Type, output: STACK): RECIPE
}

export namespace $ItemStackToChemicalRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackToChemicalRecipeSerializer$IFactory$Type<CHEMICAL, STACK, RECIPE> = ($ItemStackToChemicalRecipeSerializer$IFactory<(CHEMICAL), (STACK), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackToChemicalRecipeSerializer$IFactory_<CHEMICAL, STACK, RECIPE> = $ItemStackToChemicalRecipeSerializer$IFactory$Type<(CHEMICAL), (STACK), (RECIPE)>;
}}
declare module "packages/mekanism/common/block/states/$TransmitterType$Size" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $TransmitterType$Size extends $Enum<($TransmitterType$Size)> {
static readonly "SMALL": $TransmitterType$Size
static readonly "LARGE": $TransmitterType$Size
readonly "centerSize": integer


public static "values"(): ($TransmitterType$Size)[]
public static "valueOf"(name: string): $TransmitterType$Size
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransmitterType$Size$Type = (("small") | ("large")) | ($TransmitterType$Size);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransmitterType$Size_ = $TransmitterType$Size$Type;
}}
declare module "packages/mekanism/common/lib/transmitter/$CompatibleTransmitterValidator" {
import {$DynamicNetwork, $DynamicNetwork$Type} from "packages/mekanism/common/lib/transmitter/$DynamicNetwork"
import {$Transmitter, $Transmitter$Type} from "packages/mekanism/common/content/network/transmitter/$Transmitter"

export class $CompatibleTransmitterValidator<ACCEPTOR, NETWORK extends $DynamicNetwork<(ACCEPTOR), (NETWORK), (TRANSMITTER)>, TRANSMITTER extends $Transmitter<(ACCEPTOR), (NETWORK), (TRANSMITTER)>> {

constructor()

public "isTransmitterCompatible"(transmitter: $Transmitter$Type<(any), (any), (any)>): boolean
public "isNetworkCompatible"(net: NETWORK): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompatibleTransmitterValidator$Type<ACCEPTOR, NETWORK, TRANSMITTER> = ($CompatibleTransmitterValidator<(ACCEPTOR), (NETWORK), (TRANSMITTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompatibleTransmitterValidator_<ACCEPTOR, NETWORK, TRANSMITTER> = $CompatibleTransmitterValidator$Type<(ACCEPTOR), (NETWORK), (TRANSMITTER)>;
}}
declare module "packages/mekanism/common/inventory/container/slot/$VirtualInventoryContainerSlot" {
import {$IVirtualSlot, $IVirtualSlot$Type} from "packages/mekanism/common/inventory/container/slot/$IVirtualSlot"
import {$SlotOverlay, $SlotOverlay$Type} from "packages/mekanism/common/inventory/container/slot/$SlotOverlay"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$InventoryContainerSlot, $InventoryContainerSlot$Type} from "packages/mekanism/common/inventory/container/slot/$InventoryContainerSlot"
import {$BasicInventorySlot, $BasicInventorySlot$Type} from "packages/mekanism/common/inventory/slot/$BasicInventorySlot"
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$SelectedWindowData, $SelectedWindowData$Type} from "packages/mekanism/common/inventory/container/$SelectedWindowData"
import {$IGUIWindow, $IGUIWindow$Type} from "packages/mekanism/common/inventory/container/$IGUIWindow"

export class $VirtualInventoryContainerSlot extends $InventoryContainerSlot implements $IVirtualSlot {
readonly "slot": integer
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(slot: $BasicInventorySlot$Type, windowData: $SelectedWindowData$Type, slotOverlay: $SlotOverlay$Type, uncheckedSetter: $Consumer$Type<($ItemStack$Type)>)

public "getSlot"(): $Slot
public "exists"(windowData: $SelectedWindowData$Type): boolean
public "updatePosition"(window: $IGUIWindow$Type, xPositionSupplier: $IntSupplier$Type, yPositionSupplier: $IntSupplier$Type): void
public "getActualX"(): integer
public "shouldDrawOverlay"(): boolean
public "getActualY"(): integer
public "getLinkedWindow"(): $IGUIWindow
public "updateRenderInfo"(stackToRender: $ItemStack$Type, shouldDrawOverlay: boolean, tooltipOverride: string): void
public "getTooltipOverride"(): string
public "getStackToRender"(): $ItemStack
get "slot"(): $Slot
get "actualX"(): integer
get "actualY"(): integer
get "linkedWindow"(): $IGUIWindow
get "tooltipOverride"(): string
get "stackToRender"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualInventoryContainerSlot$Type = ($VirtualInventoryContainerSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VirtualInventoryContainerSlot_ = $VirtualInventoryContainerSlot$Type;
}}
declare module "packages/mekanism/common/particle/$LaserParticleData" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$ParticleOptions$Deserializer, $ParticleOptions$Deserializer$Type} from "packages/net/minecraft/core/particles/$ParticleOptions$Deserializer"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"

export class $LaserParticleData extends $Record implements $ParticleOptions {
static readonly "DESERIALIZER": $ParticleOptions$Deserializer<($LaserParticleData)>
static readonly "CODEC": $Codec<($LaserParticleData)>

constructor(direction: $Direction$Type, distance: double, energyScale: float)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "distance"(): double
public "writeToNetwork"(buffer: $FriendlyByteBuf$Type): void
public "getType"(): $ParticleType<(any)>
public "writeToString"(): string
public "energyScale"(): float
public "direction"(): $Direction
get "type"(): $ParticleType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LaserParticleData$Type = ($LaserParticleData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LaserParticleData_ = $LaserParticleData$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$FluidToFluidRecipeSerializer$IFactory" {
import {$FluidStackIngredient, $FluidStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$FluidStackIngredient"
import {$FluidToFluidRecipe, $FluidToFluidRecipe$Type} from "packages/mekanism/api/recipes/$FluidToFluidRecipe"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $FluidToFluidRecipeSerializer$IFactory<RECIPE extends $FluidToFluidRecipe> {

 "create"(id: $ResourceLocation$Type, input: $FluidStackIngredient$Type, output: $FluidStack$Type): RECIPE

(id: $ResourceLocation$Type, input: $FluidStackIngredient$Type, output: $FluidStack$Type): RECIPE
}

export namespace $FluidToFluidRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidToFluidRecipeSerializer$IFactory$Type<RECIPE> = ($FluidToFluidRecipeSerializer$IFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidToFluidRecipeSerializer$IFactory_<RECIPE> = $FluidToFluidRecipeSerializer$IFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/inventory/container/item/$PersonalStorageItemContainer" {
import {$ClickType, $ClickType$Type} from "packages/net/minecraft/world/inventory/$ClickType"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ContainerListener, $ContainerListener$Type} from "packages/net/minecraft/world/inventory/$ContainerListener"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$MekanismItemContainer, $MekanismItemContainer$Type} from "packages/mekanism/common/inventory/container/item/$MekanismItemContainer"

export class $PersonalStorageItemContainer extends $MekanismItemContainer {
static readonly "BASE_Y_OFFSET": integer
static readonly "TRANSPORTER_CONFIG_WINDOW": integer
static readonly "SIDE_CONFIG_WINDOW": integer
static readonly "UPGRADE_WINDOW": integer
static readonly "SKIN_SELECT_WINDOW": integer
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
 "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
 "remoteSlots": $NonNullList<($ItemStack)>
 "stateId": integer
 "containerId": integer
readonly "containerListeners": $List<($ContainerListener)>

constructor(id: integer, inv: $Inventory$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type, isRemote: boolean)

public "clicked"(slotId: integer, dragType: integer, clickType: $ClickType$Type, player: $Player$Type): void
public "getHand"(): $InteractionHand
get "hand"(): $InteractionHand
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PersonalStorageItemContainer$Type = ($PersonalStorageItemContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PersonalStorageItemContainer_ = $PersonalStorageItemContainer$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/type/$FluidInputCache" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$FluidStackIngredient, $FluidStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$FluidStackIngredient"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$NBTSensitiveInputCache, $NBTSensitiveInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$NBTSensitiveInputCache"

export class $FluidInputCache<RECIPE extends $MekanismRecipe> extends $NBTSensitiveInputCache<($Fluid), ($FluidStack), ($FluidStack), ($FluidStackIngredient), (RECIPE)> {

constructor()

public "isEmpty"(input: $FluidStack$Type): boolean
public "mapInputs"(recipe: RECIPE, inputIngredient: $FluidStackIngredient$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidInputCache$Type<RECIPE> = ($FluidInputCache<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidInputCache_<RECIPE> = $FluidInputCache$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/lib/math/$Range3D" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"

export class $Range3D extends $Record {

constructor(xMin: integer, zMin: integer, xMax: integer, zMax: integer, dimension: $ResourceKey$Type<($Level$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "dimension"(): $ResourceKey<($Level)>
public "zMin"(): integer
public "xMin"(): integer
public "zMax"(): integer
public "xMax"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Range3D$Type = ($Range3D);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Range3D_ = $Range3D$Type;
}}
declare module "packages/mekanism/common/tile/$TileEntitySecurityDesk" {
import {$SecurityMode, $SecurityMode$Type} from "packages/mekanism/api/security/$SecurityMode"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Vec3i, $Vec3i$Type} from "packages/net/minecraft/core/$Vec3i"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$IBoundingBlock, $IBoundingBlock$Type} from "packages/mekanism/common/tile/interfaces/$IBoundingBlock"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$SecurityFrequency, $SecurityFrequency$Type} from "packages/mekanism/common/lib/security/$SecurityFrequency"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export class $TileEntitySecurityDesk extends $TileEntityMekanism implements $IBoundingBlock {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "getFreq"(): $SecurityFrequency
public "setSecurityDeskMode"(mode: $SecurityMode$Type): void
public "isOffsetCapabilityDisabled"(capability: $Capability$Type<(any)>, side: $Direction$Type, offset: $Vec3i$Type): boolean
public "removeTrusted"(index: integer): void
public "addTrusted"(name: string): void
public "toggleOverride"(): void
public "onBoundingBlockPowerChange"(boundingPos: $BlockPos$Type, oldLevel: integer, newLevel: integer): void
public "triggerBoundingEvent"(offset: $Vec3i$Type, id: integer, param: integer): boolean
public "getBoundingComparatorSignal"(offset: $Vec3i$Type): integer
public "getOffsetCapabilityIfEnabled"<T>(capability: $Capability$Type<(T)>, side: $Direction$Type, offset: $Vec3i$Type): $LazyOptional<(T)>
public "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
public "getOffsetCapability"<T>(capability: $Capability$Type<(T)>, side: $Direction$Type, offset: $Vec3i$Type): $LazyOptional<(T)>
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "freq"(): $SecurityFrequency
set "securityDeskMode"(value: $SecurityMode$Type)
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntitySecurityDesk$Type = ($TileEntitySecurityDesk);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntitySecurityDesk_ = $TileEntitySecurityDesk$Type;
}}
declare module "packages/mekanism/common/capabilities/energy/$LaserEnergyContainer" {
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$BasicEnergyContainer, $BasicEnergyContainer$Type} from "packages/mekanism/common/capabilities/energy/$BasicEnergyContainer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"

export class $LaserEnergyContainer extends $BasicEnergyContainer {
static readonly "alwaysTrue": $Predicate<($AutomationType)>
static readonly "alwaysFalse": $Predicate<($AutomationType)>
static readonly "internalOnly": $Predicate<($AutomationType)>
static readonly "manualOnly": $Predicate<($AutomationType)>
static readonly "notExternal": $Predicate<($AutomationType)>


public static "create"(canExtract: $Predicate$Type<($AutomationType$Type)>, canInsert: $Predicate$Type<($AutomationType$Type)>, tile: $TileEntityMekanism$Type, listener: $IContentsListener$Type): $LaserEnergyContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LaserEnergyContainer$Type = ($LaserEnergyContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LaserEnergyContainer_ = $LaserEnergyContainer$Type;
}}
declare module "packages/mekanism/common/integration/computer/$IComputerTile" {
import {$BoundMethodHolder, $BoundMethodHolder$Type} from "packages/mekanism/common/integration/computer/$BoundMethodHolder"

export interface $IComputerTile {

 "isComputerCapabilityPersistent"(): boolean
 "hasComputerSupport"(): boolean
 "getComputerMethods"(holder: $BoundMethodHolder$Type): void
 "getComputerName"(): string

(): boolean
}

export namespace $IComputerTile {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IComputerTile$Type = ($IComputerTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IComputerTile_ = $IComputerTile$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$RotaryRecipeSerializer$IFactory" {
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$FluidStackIngredient, $FluidStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$FluidStackIngredient"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$ChemicalStackIngredient$GasStackIngredient, $ChemicalStackIngredient$GasStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient$GasStackIngredient"
import {$RotaryRecipe, $RotaryRecipe$Type} from "packages/mekanism/api/recipes/$RotaryRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $RotaryRecipeSerializer$IFactory<RECIPE extends $RotaryRecipe> {

 "create"(id: $ResourceLocation$Type, fluidInput: $FluidStackIngredient$Type, gasOutput: $GasStack$Type): RECIPE
 "create"(id: $ResourceLocation$Type, gasInput: $ChemicalStackIngredient$GasStackIngredient$Type, fluidOutput: $FluidStack$Type): RECIPE
 "create"(id: $ResourceLocation$Type, fluidInput: $FluidStackIngredient$Type, gasInput: $ChemicalStackIngredient$GasStackIngredient$Type, gasOutput: $GasStack$Type, fluidOutput: $FluidStack$Type): RECIPE
}

export namespace $RotaryRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotaryRecipeSerializer$IFactory$Type<RECIPE> = ($RotaryRecipeSerializer$IFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RotaryRecipeSerializer$IFactory_<RECIPE> = $RotaryRecipeSerializer$IFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder" {
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$IChemicalTank, $IChemicalTank$Type} from "packages/mekanism/api/chemical/$IChemicalTank"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IHolder, $IHolder$Type} from "packages/mekanism/common/capabilities/holder/$IHolder"

export interface $IChemicalTankHolder<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, TANK extends $IChemicalTank<(CHEMICAL), (STACK)>> extends $IHolder {

 "getTanks"(side: $Direction$Type): $List<(TANK)>
 "canInsert"(direction: $Direction$Type): boolean
 "canExtract"(direction: $Direction$Type): boolean

(side: $Direction$Type): $List<(TANK)>
}

export namespace $IChemicalTankHolder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IChemicalTankHolder$Type<CHEMICAL, STACK, TANK> = ($IChemicalTankHolder<(CHEMICAL), (STACK), (TANK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IChemicalTankHolder_<CHEMICAL, STACK, TANK> = $IChemicalTankHolder$Type<(CHEMICAL), (STACK), (TANK)>;
}}
declare module "packages/mekanism/common/content/network/transmitter/$Transmitter" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$CompatibleTransmitterValidator, $CompatibleTransmitterValidator$Type} from "packages/mekanism/common/lib/transmitter/$CompatibleTransmitterValidator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$TransmissionType, $TransmissionType$Type} from "packages/mekanism/common/lib/transmitter/$TransmissionType"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$DynamicNetwork, $DynamicNetwork$Type} from "packages/mekanism/common/lib/transmitter/$DynamicNetwork"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$AbstractAcceptorCache, $AbstractAcceptorCache$Type} from "packages/mekanism/common/lib/transmitter/acceptor/$AbstractAcceptorCache"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ConnectionType, $ConnectionType$Type} from "packages/mekanism/common/lib/transmitter/$ConnectionType"
import {$ITileWrapper, $ITileWrapper$Type} from "packages/mekanism/common/tile/interfaces/$ITileWrapper"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $Transmitter<ACCEPTOR, NETWORK extends $DynamicNetwork<(ACCEPTOR), (NETWORK), (TRANSMITTER)>, TRANSMITTER extends $Transmitter<(ACCEPTOR), (NETWORK), (TRANSMITTER)>> implements $ITileWrapper {
 "currentTransmitterConnections": byte

constructor(transmitterTile: $TileEntityTransmitter$Type, ...transmissionTypes: ($TransmissionType$Type)[])

public "remove"(): void
public "write"(nbtTags: $CompoundTag$Type): $CompoundTag
public "read"(nbtTags: $CompoundTag$Type): void
public "isValid"(): boolean
public "canConnect"(side: $Direction$Type): boolean
public "onNeighborBlockChange"(side: $Direction$Type): void
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "setTransmitterNetwork"(network: NETWORK, requestNow: boolean): boolean
public "setTransmitterNetwork"(network: NETWORK): void
public "getTilePos"(): $BlockPos
public "isRemote"(): boolean
public "getSupportedTransmissionTypes"(): $Set<($TransmissionType)>
public "onRightClick"(player: $Player$Type, side: $Direction$Type): $InteractionResult
public "getConnections"(type: $ConnectionType$Type): $Set<($Direction)>
public "getConnectionType"(side: $Direction$Type): $ConnectionType
public "onModeChange"(side: $Direction$Type): void
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
public "requestsUpdate"(): void
public "takeShare"(): void
public "getReducedUpdateTag"(updateTag: $CompoundTag$Type): $CompoundTag
public "hasTransmitterNetwork"(): boolean
public "getTransmitterNetwork"(): NETWORK
public "onNeighborTileChange"(side: $Direction$Type): void
public "getConnectionTypesRaw"(): ($ConnectionType)[]
public "setConnectionTypesRaw"(connectionTypes: ($ConnectionType$Type)[]): void
public "createEmptyNetworkWithID"(networkID: $UUID$Type): NETWORK
public "setConnectionTypeRaw"(side: $Direction$Type, type: $ConnectionType$Type): void
public "getConnectionTypeRaw"(side: $Direction$Type): $ConnectionType
public "validateAndTakeShare"(): void
public "getAllCurrentConnections"(): byte
public static "connectionMapContainsSide"(connections: byte, side: $Direction$Type): boolean
public "canConnectToAcceptor"(side: $Direction$Type): boolean
public "createNetworkByMerging"(toMerge: $Collection$Type<(NETWORK)>): NETWORK
public "isRedstoneActivated"(): boolean
public "getNewOrphanValidator"(): $CompatibleTransmitterValidator<(ACCEPTOR), (NETWORK), (TRANSMITTER)>
public "isValidTransmitterBasic"(transmitter: $TileEntityTransmitter$Type, side: $Direction$Type): boolean
public "supportsTransmissionType"(transmitter: $Transmitter$Type<(any), (any), (any)>): boolean
public "supportsTransmissionType"(transmitter: $TileEntityTransmitter$Type): boolean
public "getPossibleAcceptorConnections"(): byte
public "getPossibleTransmitterConnections"(): byte
public "refreshConnections"(): void
public "refreshConnections"(side: $Direction$Type): void
public "startUpgrading"(): void
public "onConfigure"(player: $Player$Type, side: $Direction$Type): $InteractionResult
public "notifyTileChange"(): void
public "getTransmitterTile"(): $TileEntityTransmitter
public "isUpgrading"(): boolean
public "setOrphan"(nowOrphaned: boolean): void
public "isOrphan"(): boolean
public "getAcceptor"(side: $Direction$Type): $LazyOptional<(ACCEPTOR)>
public "getAcceptorCache"(): $AbstractAcceptorCache<(ACCEPTOR), (any)>
public "canConnectMutual"(side: $Direction$Type, cachedTile: $BlockEntity$Type): boolean
public "canConnectMutual"(side: $Direction$Type, cachedTransmitter: TRANSMITTER): boolean
public "isValidTransmitter"(transmitter: $TileEntityTransmitter$Type, side: $Direction$Type): boolean
public "markDirtyAcceptor"(side: $Direction$Type): void
public "isValidAcceptor"(tile: $BlockEntity$Type, side: $Direction$Type): boolean
public "handlesRedstone"(): boolean
get "valid"(): boolean
set "transmitterNetwork"(value: NETWORK)
get "tilePos"(): $BlockPos
get "remote"(): boolean
get "supportedTransmissionTypes"(): $Set<($TransmissionType)>
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
get "transmitterNetwork"(): NETWORK
get "connectionTypesRaw"(): ($ConnectionType)[]
set "connectionTypesRaw"(value: ($ConnectionType$Type)[])
get "allCurrentConnections"(): byte
get "redstoneActivated"(): boolean
get "newOrphanValidator"(): $CompatibleTransmitterValidator<(ACCEPTOR), (NETWORK), (TRANSMITTER)>
get "possibleAcceptorConnections"(): byte
get "possibleTransmitterConnections"(): byte
get "transmitterTile"(): $TileEntityTransmitter
get "upgrading"(): boolean
set "orphan"(value: boolean)
get "orphan"(): boolean
get "acceptorCache"(): $AbstractAcceptorCache<(ACCEPTOR), (any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Transmitter$Type<ACCEPTOR, NETWORK, TRANSMITTER> = ($Transmitter<(ACCEPTOR), (NETWORK), (TRANSMITTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Transmitter_<ACCEPTOR, NETWORK, TRANSMITTER> = $Transmitter$Type<(ACCEPTOR), (NETWORK), (TRANSMITTER)>;
}}
declare module "packages/mekanism/common/content/qio/$QIODriveData" {
import {$HashedItem, $HashedItem$Type} from "packages/mekanism/common/lib/inventory/$HashedItem"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$Object2LongMap, $Object2LongMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongMap"
import {$QIODriveData$QIODriveKey, $QIODriveData$QIODriveKey$Type} from "packages/mekanism/common/content/qio/$QIODriveData$QIODriveKey"

export class $QIODriveData {

constructor(key: $QIODriveData$QIODriveKey$Type)

public "add"(type: $HashedItem$Type, amount: long, action: $Action$Type): long
public "remove"(type: $HashedItem$Type, amount: long, action: $Action$Type): long
public "getKey"(): $QIODriveData$QIODriveKey
public "getTotalCount"(): long
public "getTotalTypes"(): integer
public "getCountCapacity"(): long
public "getTypeCapacity"(): integer
public "getStored"(type: $HashedItem$Type): long
public "getItemMap"(): $Object2LongMap<($HashedItem)>
get "key"(): $QIODriveData$QIODriveKey
get "totalCount"(): long
get "totalTypes"(): integer
get "countCapacity"(): long
get "typeCapacity"(): integer
get "itemMap"(): $Object2LongMap<($HashedItem)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIODriveData$Type = ($QIODriveData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIODriveData_ = $QIODriveData$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/type/$NBTSensitiveInputCache" {
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$InputIngredient, $InputIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$InputIngredient"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$BaseInputCache, $BaseInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$BaseInputCache"

export class $NBTSensitiveInputCache<KEY, NBT_KEY, INPUT, INGREDIENT extends $InputIngredient<(INPUT)>, RECIPE extends $MekanismRecipe> extends $BaseInputCache<(KEY), (INPUT), (INGREDIENT), (RECIPE)> {

constructor()

public "clear"(): void
public "contains"(input: INPUT, matchCriteria: $Predicate$Type<(RECIPE)>): boolean
public "contains"(input: INPUT): boolean
public "findFirstRecipe"(input: INPUT, matchCriteria: $Predicate$Type<(RECIPE)>): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTSensitiveInputCache$Type<KEY, NBT_KEY, INPUT, INGREDIENT, RECIPE> = ($NBTSensitiveInputCache<(KEY), (NBT_KEY), (INPUT), (INGREDIENT), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NBTSensitiveInputCache_<KEY, NBT_KEY, INPUT, INGREDIENT, RECIPE> = $NBTSensitiveInputCache$Type<(KEY), (NBT_KEY), (INPUT), (INGREDIENT), (RECIPE)>;
}}
declare module "packages/mekanism/common/tier/$PipeTier" {
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"
import {$CachedIntValue, $CachedIntValue$Type} from "packages/mekanism/common/config/value/$CachedIntValue"

export class $PipeTier extends $Enum<($PipeTier)> implements $ITier {
static readonly "BASIC": $PipeTier
static readonly "ADVANCED": $PipeTier
static readonly "ELITE": $PipeTier
static readonly "ULTIMATE": $PipeTier


public static "get"(tier: $BaseTier$Type): $PipeTier
public static "values"(): ($PipeTier)[]
public static "valueOf"(name: string): $PipeTier
public "getBaseCapacity"(): integer
public "getBaseTier"(): $BaseTier
public "setConfigReference"(capacityReference: $CachedIntValue$Type, pullReference: $CachedIntValue$Type): void
public "getPipeCapacity"(): integer
public "getPipePullAmount"(): integer
public "getBasePull"(): integer
get "baseCapacity"(): integer
get "baseTier"(): $BaseTier
get "pipeCapacity"(): integer
get "pipePullAmount"(): integer
get "basePull"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeTier$Type = (("elite") | ("advanced") | ("ultimate") | ("basic")) | ($PipeTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PipeTier_ = $PipeTier$Type;
}}
declare module "packages/mekanism/common/lib/transmitter/$DynamicBufferedNetwork" {
import {$DynamicNetwork, $DynamicNetwork$Type} from "packages/mekanism/common/lib/transmitter/$DynamicNetwork"
import {$Range3D, $Range3D$Type} from "packages/mekanism/common/lib/math/$Range3D"
import {$CompatibleTransmitterValidator, $CompatibleTransmitterValidator$Type} from "packages/mekanism/common/lib/transmitter/$CompatibleTransmitterValidator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BufferedTransmitter, $BufferedTransmitter$Type} from "packages/mekanism/common/content/network/transmitter/$BufferedTransmitter"

export class $DynamicBufferedNetwork<ACCEPTOR, NETWORK extends $DynamicBufferedNetwork<(ACCEPTOR), (NETWORK), (BUFFER), (TRANSMITTER)>, BUFFER, TRANSMITTER extends $BufferedTransmitter<(ACCEPTOR), (NETWORK), (BUFFER), (TRANSMITTER)>> extends $DynamicNetwork<(ACCEPTOR), (NETWORK), (TRANSMITTER)> {
 "currentScale": float


public "isCompatibleWith"(other: NETWORK): boolean
public "getCapacity"(): long
public "getBuffer"(): BUFFER
public "markDirty"(): void
public "adoptTransmittersAndAcceptorsFrom"(net: NETWORK): $List<(TRANSMITTER)>
public "getNetworkReaderCapacity"(): any
public "onUpdate"(): void
public "deregister"(): void
public "addNewTransmitters"(newTransmitters: $Collection$Type<(TRANSMITTER)>, transmitterValidator: $CompatibleTransmitterValidator$Type<(ACCEPTOR), (NETWORK), (TRANSMITTER)>): void
public "absorbBuffer"(transmitter: TRANSMITTER): void
public "updateCapacity"(): void
public "clampBuffer"(): void
public "validateSaveShares"(triggerTransmitter: TRANSMITTER): void
public "getPacketRange"(): $Range3D
get "capacity"(): long
get "buffer"(): BUFFER
get "networkReaderCapacity"(): any
get "packetRange"(): $Range3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicBufferedNetwork$Type<ACCEPTOR, NETWORK, BUFFER, TRANSMITTER> = ($DynamicBufferedNetwork<(ACCEPTOR), (NETWORK), (BUFFER), (TRANSMITTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DynamicBufferedNetwork_<ACCEPTOR, NETWORK, BUFFER, TRANSMITTER> = $DynamicBufferedNetwork$Type<(ACCEPTOR), (NETWORK), (BUFFER), (TRANSMITTER)>;
}}
declare module "packages/mekanism/common/block/$BlockRadioactiveWasteBarrel" {
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$Type} from "packages/mekanism/common/block/prefab/$BlockTile$BlockTileModel"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$TileEntityRadioactiveWasteBarrel, $TileEntityRadioactiveWasteBarrel$Type} from "packages/mekanism/common/tile/$TileEntityRadioactiveWasteBarrel"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockRadioactiveWasteBarrel extends $BlockTile$BlockTileModel<($TileEntityRadioactiveWasteBarrel), ($BlockTypeTile<($TileEntityRadioactiveWasteBarrel)>)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor()

/**
 * 
 * @deprecated
 */
public "use"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRadioactiveWasteBarrel$Type = ($BlockRadioactiveWasteBarrel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockRadioactiveWasteBarrel_ = $BlockRadioactiveWasteBarrel$Type;
}}
declare module "packages/mekanism/common/tile/multiblock/$TileEntityInductionProvider" {
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$TileEntityInternalMultiblock, $TileEntityInternalMultiblock$Type} from "packages/mekanism/common/tile/prefab/$TileEntityInternalMultiblock"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$InductionProviderTier, $InductionProviderTier$Type} from "packages/mekanism/common/tier/$InductionProviderTier"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export class $TileEntityInductionProvider extends $TileEntityInternalMultiblock {
 "tier": $InductionProviderTier
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityInductionProvider$Type = ($TileEntityInductionProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityInductionProvider_ = $TileEntityInductionProvider$Type;
}}
declare module "packages/mekanism/common/tier/$BinTier" {
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"
import {$CachedIntValue, $CachedIntValue$Type} from "packages/mekanism/common/config/value/$CachedIntValue"

export class $BinTier extends $Enum<($BinTier)> implements $ITier {
static readonly "BASIC": $BinTier
static readonly "ADVANCED": $BinTier
static readonly "ELITE": $BinTier
static readonly "ULTIMATE": $BinTier
static readonly "CREATIVE": $BinTier


public static "values"(): ($BinTier)[]
public static "valueOf"(name: string): $BinTier
public "getBaseStorage"(): integer
public "getBaseTier"(): $BaseTier
public "getStorage"(): integer
public "setConfigReference"(storageReference: $CachedIntValue$Type): void
get "baseStorage"(): integer
get "baseTier"(): $BaseTier
get "storage"(): integer
set "configReference"(value: $CachedIntValue$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinTier$Type = (("elite") | ("advanced") | ("ultimate") | ("basic") | ("creative")) | ($BinTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinTier_ = $BinTier$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$FluidSlurryToSlurryRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$FluidSlurryToSlurryRecipe, $FluidSlurryToSlurryRecipe$Type} from "packages/mekanism/api/recipes/$FluidSlurryToSlurryRecipe"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidSlurryToSlurryRecipeSerializer$IFactory, $FluidSlurryToSlurryRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$FluidSlurryToSlurryRecipeSerializer$IFactory"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $FluidSlurryToSlurryRecipeSerializer<RECIPE extends $FluidSlurryToSlurryRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(factory: $FluidSlurryToSlurryRecipeSerializer$IFactory$Type<(RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidSlurryToSlurryRecipeSerializer$Type<RECIPE> = ($FluidSlurryToSlurryRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidSlurryToSlurryRecipeSerializer_<RECIPE> = $FluidSlurryToSlurryRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$ChemicalCrystallizerInputRecipeCache" {
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$BoxedChemicalStack, $BoxedChemicalStack$Type} from "packages/mekanism/api/chemical/merged/$BoxedChemicalStack"
import {$ChemicalCrystallizerRecipe, $ChemicalCrystallizerRecipe$Type} from "packages/mekanism/api/recipes/$ChemicalCrystallizerRecipe"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$AbstractInputRecipeCache, $AbstractInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$AbstractInputRecipeCache"
import {$MekanismRecipeType, $MekanismRecipeType$Type} from "packages/mekanism/common/recipe/$MekanismRecipeType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"

export class $ChemicalCrystallizerInputRecipeCache extends $AbstractInputRecipeCache<($ChemicalCrystallizerRecipe)> {

constructor(recipeType: $MekanismRecipeType$Type<($ChemicalCrystallizerRecipe$Type), (any)>)

public "clear"(): void
public "findFirstRecipe"(world: $Level$Type, input: $BoxedChemicalStack$Type): $ChemicalCrystallizerRecipe
public "containsInput"(world: $Level$Type, input: $BoxedChemicalStack$Type): boolean
public "containsInput"<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>>(world: $Level$Type, input: CHEMICAL): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalCrystallizerInputRecipeCache$Type = ($ChemicalCrystallizerInputRecipeCache);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalCrystallizerInputRecipeCache_ = $ChemicalCrystallizerInputRecipeCache$Type;
}}
declare module "packages/mekanism/common/content/transporter/$SorterFilter" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$TransitRequest, $TransitRequest$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Finder, $Finder$Type} from "packages/mekanism/common/lib/inventory/$Finder"
import {$BaseFilter, $BaseFilter$Type} from "packages/mekanism/common/content/filter/$BaseFilter"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"

export class $SorterFilter<FILTER extends $SorterFilter<(FILTER)>> extends $BaseFilter<(FILTER)> {
static readonly "MAX_LENGTH": integer
 "color": $EnumColor
 "allowDefault": boolean
 "sizeMode": boolean
 "min": integer
 "max": integer


public "equals"(o: any): boolean
public "hashCode"(): integer
public "write"(buffer: $FriendlyByteBuf$Type): void
public "write"(nbtTags: $CompoundTag$Type): $CompoundTag
public "read"(nbtTags: $CompoundTag$Type): void
public "read"(dataStream: $FriendlyByteBuf$Type): void
public "getFinder"(): $Finder
public "mapInventory"(tile: $BlockEntity$Type, side: $Direction$Type, singleItem: boolean): $TransitRequest
get "finder"(): $Finder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SorterFilter$Type<FILTER> = ($SorterFilter<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SorterFilter_<FILTER> = $SorterFilter$Type<(FILTER)>;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/type/$ChemicalInputCache" {
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$ChemicalStackIngredient, $ChemicalStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$BaseInputCache, $BaseInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$BaseInputCache"

export class $ChemicalInputCache<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, RECIPE extends $MekanismRecipe> extends $BaseInputCache<(CHEMICAL), (STACK), ($ChemicalStackIngredient<(CHEMICAL), (STACK)>), (RECIPE)> {

constructor()

public "isEmpty"(input: STACK): boolean
public "mapInputs"(recipe: RECIPE, inputIngredient: $ChemicalStackIngredient$Type<(CHEMICAL), (STACK)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalInputCache$Type<CHEMICAL, STACK, RECIPE> = ($ChemicalInputCache<(CHEMICAL), (STACK), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalInputCache_<CHEMICAL, STACK, RECIPE> = $ChemicalInputCache$Type<(CHEMICAL), (STACK), (RECIPE)>;
}}
declare module "packages/mekanism/common/item/$ItemRefinedGlowstoneIngot" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemRefinedGlowstoneIngot extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "isPiglinCurrency"(stack: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemRefinedGlowstoneIngot$Type = ($ItemRefinedGlowstoneIngot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemRefinedGlowstoneIngot_ = $ItemRefinedGlowstoneIngot$Type;
}}
declare module "packages/mekanism/common/tile/prefab/$TileEntityConfigurableMachine" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$TileComponentEjector, $TileComponentEjector$Type} from "packages/mekanism/common/tile/component/$TileComponentEjector"
import {$DataType, $DataType$Type} from "packages/mekanism/common/tile/component/config/$DataType"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$ISideConfiguration, $ISideConfiguration$Type} from "packages/mekanism/common/tile/interfaces/$ISideConfiguration"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$TileComponentConfig, $TileComponentConfig$Type} from "packages/mekanism/common/tile/component/$TileComponentConfig"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export class $TileEntityConfigurableMachine extends $TileEntityMekanism implements $ISideConfiguration {
 "ejectorComponent": $TileComponentEjector
 "configComponent": $TileComponentConfig
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "getConfigurationData"(player: $Player$Type): $CompoundTag
public "setConfigurationData"(player: $Player$Type, data: $CompoundTag$Type): void
public "getConfig"(): $TileComponentConfig
public "getEjector"(): $TileComponentEjector
public "getDirection"(): $Direction
public "getActiveDataType"(container: any): $DataType
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "config"(): $TileComponentConfig
get "ejector"(): $TileComponentEjector
get "direction"(): $Direction
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityConfigurableMachine$Type = ($TileEntityConfigurableMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityConfigurableMachine_ = $TileEntityConfigurableMachine$Type;
}}
declare module "packages/mekanism/common/upgrade/transmitter/$PressurizedTubeUpgradeData" {
import {$BoxedChemicalStack, $BoxedChemicalStack$Type} from "packages/mekanism/api/chemical/merged/$BoxedChemicalStack"
import {$TransmitterUpgradeData, $TransmitterUpgradeData$Type} from "packages/mekanism/common/upgrade/transmitter/$TransmitterUpgradeData"
import {$ConnectionType, $ConnectionType$Type} from "packages/mekanism/common/lib/transmitter/$ConnectionType"

export class $PressurizedTubeUpgradeData extends $TransmitterUpgradeData {
readonly "contents": $BoxedChemicalStack
readonly "redstoneReactive": boolean
readonly "connectionTypes": ($ConnectionType)[]

constructor(redstoneReactive: boolean, connectionTypes: ($ConnectionType$Type)[], contents: $BoxedChemicalStack$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressurizedTubeUpgradeData$Type = ($PressurizedTubeUpgradeData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PressurizedTubeUpgradeData_ = $PressurizedTubeUpgradeData$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$GasToGasRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$GasToGasRecipe, $GasToGasRecipe$Type} from "packages/mekanism/api/recipes/$GasToGasRecipe"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$GasToGasRecipeSerializer$IFactory, $GasToGasRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$GasToGasRecipeSerializer$IFactory"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $GasToGasRecipeSerializer<RECIPE extends $GasToGasRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(factory: $GasToGasRecipeSerializer$IFactory$Type<(RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GasToGasRecipeSerializer$Type<RECIPE> = ($GasToGasRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GasToGasRecipeSerializer_<RECIPE> = $GasToGasRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/tier/$ChemicalTankTier" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"
import {$CachedLongValue, $CachedLongValue$Type} from "packages/mekanism/common/config/value/$CachedLongValue"

export class $ChemicalTankTier extends $Enum<($ChemicalTankTier)> implements $ITier, $StringRepresentable {
static readonly "BASIC": $ChemicalTankTier
static readonly "ADVANCED": $ChemicalTankTier
static readonly "ELITE": $ChemicalTankTier
static readonly "ULTIMATE": $ChemicalTankTier
static readonly "CREATIVE": $ChemicalTankTier


public static "values"(): ($ChemicalTankTier)[]
public static "valueOf"(name: string): $ChemicalTankTier
public "getOutput"(): long
public "getSerializedName"(): string
public "getBaseStorage"(): long
public "getBaseTier"(): $BaseTier
public "getStorage"(): long
public "getBaseOutput"(): long
public "setConfigReference"(storageReference: $CachedLongValue$Type, outputReference: $CachedLongValue$Type): void
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
get "output"(): long
get "serializedName"(): string
get "baseStorage"(): long
get "baseTier"(): $BaseTier
get "storage"(): long
get "baseOutput"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalTankTier$Type = (("elite") | ("advanced") | ("ultimate") | ("basic") | ("creative")) | ($ChemicalTankTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalTankTier_ = $ChemicalTankTier$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ItemStackToItemStackRecipeSerializer$IFactory" {
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemStackToItemStackRecipe, $ItemStackToItemStackRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackToItemStackRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $ItemStackToItemStackRecipeSerializer$IFactory<RECIPE extends $ItemStackToItemStackRecipe> {

 "create"(id: $ResourceLocation$Type, input: $ItemStackIngredient$Type, output: $ItemStack$Type): RECIPE

(id: $ResourceLocation$Type, input: $ItemStackIngredient$Type, output: $ItemStack$Type): RECIPE
}

export namespace $ItemStackToItemStackRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackToItemStackRecipeSerializer$IFactory$Type<RECIPE> = ($ItemStackToItemStackRecipeSerializer$IFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackToItemStackRecipeSerializer$IFactory_<RECIPE> = $ItemStackToItemStackRecipeSerializer$IFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/inventory/container/$SelectedWindowData$WindowPosition" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"

export class $SelectedWindowData$WindowPosition extends $Record {

constructor(x: integer, y: integer)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "x"(): integer
public "y"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SelectedWindowData$WindowPosition$Type = ($SelectedWindowData$WindowPosition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SelectedWindowData$WindowPosition_ = $SelectedWindowData$WindowPosition$Type;
}}
declare module "packages/mekanism/common/inventory/slot/$BasicInventorySlot" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ContainerSlotType, $ContainerSlotType$Type} from "packages/mekanism/common/inventory/container/slot/$ContainerSlotType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$SlotOverlay, $SlotOverlay$Type} from "packages/mekanism/common/inventory/container/slot/$SlotOverlay"
import {$ISupportsWarning, $ISupportsWarning$Type} from "packages/mekanism/common/inventory/warning/$ISupportsWarning"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"

export class $BasicInventorySlot implements $IInventorySlot {
static readonly "alwaysTrue": $Predicate<($ItemStack)>
static readonly "alwaysFalse": $Predicate<($ItemStack)>
static readonly "alwaysTrueBi": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "DEFAULT_LIMIT": integer


public "isEmpty"(): boolean
public static "at"(listener: $IContentsListener$Type, x: integer, y: integer): $BasicInventorySlot
public static "at"(validator: $Predicate$Type<($ItemStack$Type)>, listener: $IContentsListener$Type, x: integer, y: integer): $BasicInventorySlot
public static "at"(canExtract: $Predicate$Type<($ItemStack$Type)>, canInsert: $Predicate$Type<($ItemStack$Type)>, listener: $IContentsListener$Type, x: integer, y: integer): $BasicInventorySlot
public static "at"(canExtract: $BiPredicate$Type<($ItemStack$Type), ($AutomationType$Type)>, canInsert: $BiPredicate$Type<($ItemStack$Type), ($AutomationType$Type)>, listener: $IContentsListener$Type, x: integer, y: integer): $BasicInventorySlot
public "getStack"(): $ItemStack
public "getCount"(): integer
public "setStack"(stack: $ItemStack$Type): void
public "onContentsChanged"(): void
public "getLimit"(stack: $ItemStack$Type): integer
public "setSlotType"(slotType: $ContainerSlotType$Type): void
public "deserializeNBT"(nbt: $CompoundTag$Type): void
public "serializeNBT"(): $CompoundTag
public "growStack"(amount: integer, action: $Action$Type): integer
public "setSlotOverlay"(slotOverlay: $SlotOverlay$Type): void
public "tracksWarnings"(warningAdder: $Consumer$Type<($ISupportsWarning$Type<(any)>)>): void
public "insertItem"(stack: $ItemStack$Type, action: $Action$Type, automationType: $AutomationType$Type): $ItemStack
public "isItemValid"(stack: $ItemStack$Type): boolean
public "extractItem"(amount: integer, action: $Action$Type, automationType: $AutomationType$Type): $ItemStack
public "setStackSize"(amount: integer, action: $Action$Type): integer
public "isItemValidForInsertion"(stack: $ItemStack$Type, automationType: $AutomationType$Type): boolean
public "setEmpty"(): void
public "shrinkStack"(arg0: integer, arg1: $Action$Type): integer
get "empty"(): boolean
get "stack"(): $ItemStack
get "count"(): integer
set "stack"(value: $ItemStack$Type)
set "slotType"(value: $ContainerSlotType$Type)
set "slotOverlay"(value: $SlotOverlay$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicInventorySlot$Type = ($BasicInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicInventorySlot_ = $BasicInventorySlot$Type;
}}
declare module "packages/mekanism/common/item/$ItemTierInstaller" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemTierInstaller extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(fromTier: $BaseTier$Type, toTier: $BaseTier$Type, properties: $Item$Properties$Type)

public "getToTier"(): $BaseTier
public "getFromTier"(): $BaseTier
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "getName"(stack: $ItemStack$Type): $Component
get "toTier"(): $BaseTier
get "fromTier"(): $BaseTier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTierInstaller$Type = ($ItemTierInstaller);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTierInstaller_ = $ItemTierInstaller$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ChemicalChemicalToChemicalRecipeSerializer$IFactory" {
import {$ChemicalStackIngredient, $ChemicalStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient"
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$ChemicalChemicalToChemicalRecipe, $ChemicalChemicalToChemicalRecipe$Type} from "packages/mekanism/api/recipes/chemical/$ChemicalChemicalToChemicalRecipe"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $ChemicalChemicalToChemicalRecipeSerializer$IFactory<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, INGREDIENT extends $ChemicalStackIngredient<(CHEMICAL), (STACK)>, RECIPE extends $ChemicalChemicalToChemicalRecipe<(CHEMICAL), (STACK), (INGREDIENT)>> {

 "create"(id: $ResourceLocation$Type, leftInput: INGREDIENT, rightInput: INGREDIENT, output: STACK): RECIPE

(id: $ResourceLocation$Type, leftInput: INGREDIENT, rightInput: INGREDIENT, output: STACK): RECIPE
}

export namespace $ChemicalChemicalToChemicalRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalChemicalToChemicalRecipeSerializer$IFactory$Type<CHEMICAL, STACK, INGREDIENT, RECIPE> = ($ChemicalChemicalToChemicalRecipeSerializer$IFactory<(CHEMICAL), (STACK), (INGREDIENT), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalChemicalToChemicalRecipeSerializer$IFactory_<CHEMICAL, STACK, INGREDIENT, RECIPE> = $ChemicalChemicalToChemicalRecipeSerializer$IFactory$Type<(CHEMICAL), (STACK), (INGREDIENT), (RECIPE)>;
}}
declare module "packages/mekanism/common/inventory/container/slot/$HotBarSlot" {
import {$InsertableSlot, $InsertableSlot$Type} from "packages/mekanism/common/inventory/container/slot/$InsertableSlot"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $HotBarSlot extends $InsertableSlot {
readonly "slot": integer
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(inventory: $Container$Type, index: integer, x: integer, y: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HotBarSlot$Type = ($HotBarSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HotBarSlot_ = $HotBarSlot$Type;
}}
declare module "packages/mekanism/common/item/block/$ItemBlockEnergyCube" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ListTag, $ListTag$Type} from "packages/net/minecraft/nbt/$ListTag"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$CreativeModeTab$Output, $CreativeModeTab$Output$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$Output"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$BlockEnergyCube, $BlockEnergyCube$Type} from "packages/mekanism/common/block/$BlockEnergyCube"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemBlockTooltip, $ItemBlockTooltip$Type} from "packages/mekanism/common/item/block/$ItemBlockTooltip"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IItemSustainedInventory, $IItemSustainedInventory$Type} from "packages/mekanism/common/item/interfaces/$IItemSustainedInventory"
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$Type} from "packages/mekanism/common/registration/impl/$CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockEnergyCube extends $ItemBlockTooltip<($BlockEnergyCube)> implements $IItemSustainedInventory, $CreativeTabDeferredRegister$ICustomCreativeTabContents {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockEnergyCube$Type)

public "addItems"(tabOutput: $CreativeModeTab$Output$Type): void
public "initializeClient"(consumer: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "addDefault"(): boolean
public "isBarVisible"(stack: $ItemStack$Type): boolean
public "getBarWidth"(stack: $ItemStack$Type): integer
public "getBarColor"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "getSustainedInventory"(stack: $ItemStack$Type): $ListTag
public "getSustainedInventory"(): $ListTag
public "setSustainedInventory"(nbtTags: $ListTag$Type): void
public "setSustainedInventory"(nbtTags: $ListTag$Type, stack: $ItemStack$Type): void
public "getDroppedSlots"(stack: $ItemStack$Type): $List<($IInventorySlot)>
public "hasSustainedInventory"(stack: $ItemStack$Type): boolean
public "hasSustainedInventory"(): boolean
public "canContentsDrop"(stack: $ItemStack$Type): boolean
get "sustainedInventory"(): $ListTag
set "sustainedInventory"(value: $ListTag$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockEnergyCube$Type = ($ItemBlockEnergyCube);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockEnergyCube_ = $ItemBlockEnergyCube$Type;
}}
declare module "packages/mekanism/common/lib/multiblock/$IStructureValidator" {
import {$Long2ObjectMap, $Long2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap"
import {$FormationProtocol$FormationResult, $FormationProtocol$FormationResult$Type} from "packages/mekanism/common/lib/multiblock/$FormationProtocol$FormationResult"
import {$FormationProtocol, $FormationProtocol$Type} from "packages/mekanism/common/lib/multiblock/$FormationProtocol"
import {$MultiblockManager, $MultiblockManager$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockManager"
import {$IShape, $IShape$Type} from "packages/mekanism/common/lib/math/voxel/$IShape"
import {$ChunkAccess, $ChunkAccess$Type} from "packages/net/minecraft/world/level/chunk/$ChunkAccess"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Structure, $Structure$Type} from "packages/mekanism/common/lib/multiblock/$Structure"
import {$MultiblockData, $MultiblockData$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockData"

export interface $IStructureValidator<T extends $MultiblockData> {

 "validate"(ctx: $FormationProtocol$Type<(T)>, chunkMap: $Long2ObjectMap$Type<($ChunkAccess$Type)>): $FormationProtocol$FormationResult
 "init"(world: $Level$Type, manager: $MultiblockManager$Type<(T)>, structure: $Structure$Type): void
 "getShape"(): $IShape
 "precheck"(): boolean
 "postcheck"(structure: T, chunkMap: $Long2ObjectMap$Type<($ChunkAccess$Type)>): $FormationProtocol$FormationResult
}

export namespace $IStructureValidator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IStructureValidator$Type<T> = ($IStructureValidator<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IStructureValidator_<T> = $IStructureValidator$Type<(T)>;
}}
declare module "packages/mekanism/common/content/filter/$FilterType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $FilterType extends $Enum<($FilterType)> {
static readonly "MINER_ITEMSTACK_FILTER": $FilterType
static readonly "MINER_MODID_FILTER": $FilterType
static readonly "MINER_TAG_FILTER": $FilterType
static readonly "SORTER_ITEMSTACK_FILTER": $FilterType
static readonly "SORTER_MODID_FILTER": $FilterType
static readonly "SORTER_TAG_FILTER": $FilterType
static readonly "OREDICTIONIFICATOR_ITEM_FILTER": $FilterType
static readonly "QIO_ITEMSTACK_FILTER": $FilterType
static readonly "QIO_MODID_FILTER": $FilterType
static readonly "QIO_TAG_FILTER": $FilterType


public static "values"(): ($FilterType)[]
public static "valueOf"(name: string): $FilterType
public static "byIndexStatic"(index: integer): $FilterType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterType$Type = (("oredictionificator_item_filter") | ("miner_tag_filter") | ("sorter_tag_filter") | ("sorter_modid_filter") | ("qio_modid_filter") | ("qio_tag_filter") | ("miner_itemstack_filter") | ("qio_itemstack_filter") | ("miner_modid_filter") | ("sorter_itemstack_filter")) | ($FilterType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterType_ = $FilterType$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$IRedstoneControl$RedstoneControl" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IIncrementalEnum, $IIncrementalEnum$Type} from "packages/mekanism/api/$IIncrementalEnum"
import {$IHasTextComponent, $IHasTextComponent$Type} from "packages/mekanism/api/text/$IHasTextComponent"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export class $IRedstoneControl$RedstoneControl extends $Enum<($IRedstoneControl$RedstoneControl)> implements $IIncrementalEnum<($IRedstoneControl$RedstoneControl)>, $IHasTextComponent {
static readonly "DISABLED": $IRedstoneControl$RedstoneControl
static readonly "HIGH": $IRedstoneControl$RedstoneControl
static readonly "LOW": $IRedstoneControl$RedstoneControl
static readonly "PULSE": $IRedstoneControl$RedstoneControl


public static "values"(): ($IRedstoneControl$RedstoneControl)[]
public static "valueOf"(name: string): $IRedstoneControl$RedstoneControl
public "byIndex"(index: integer): $IRedstoneControl$RedstoneControl
public "getTextComponent"(): $Component
public static "byIndexStatic"(index: integer): $IRedstoneControl$RedstoneControl
public "ordinal"(): integer
public "adjust"(arg0: integer): $IRedstoneControl$RedstoneControl
public "adjust"(arg0: integer, arg1: $Predicate$Type<($IRedstoneControl$RedstoneControl$Type)>): $IRedstoneControl$RedstoneControl
public "getNext"(arg0: $Predicate$Type<($IRedstoneControl$RedstoneControl$Type)>): $IRedstoneControl$RedstoneControl
public "getNext"(): $IRedstoneControl$RedstoneControl
public "getPrevious"(): $IRedstoneControl$RedstoneControl
public "getPrevious"(arg0: $Predicate$Type<($IRedstoneControl$RedstoneControl$Type)>): $IRedstoneControl$RedstoneControl
get "textComponent"(): $Component
get "next"(): $IRedstoneControl$RedstoneControl
get "previous"(): $IRedstoneControl$RedstoneControl
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRedstoneControl$RedstoneControl$Type = (("high") | ("low") | ("pulse") | ("disabled")) | ($IRedstoneControl$RedstoneControl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRedstoneControl$RedstoneControl_ = $IRedstoneControl$RedstoneControl$Type;
}}
declare module "packages/mekanism/common/item/block/$ItemBlockPersonalStorage" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ContainerTypeRegistryObject, $ContainerTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$ContainerTypeRegistryObject"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$IGuiItem, $IGuiItem$Type} from "packages/mekanism/common/item/interfaces/$IGuiItem"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$BlockPersonalStorage, $BlockPersonalStorage$Type} from "packages/mekanism/common/block/$BlockPersonalStorage"
import {$ItemBlockTooltip, $ItemBlockTooltip$Type} from "packages/mekanism/common/item/block/$ItemBlockTooltip"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PersonalStorageItemContainer, $PersonalStorageItemContainer$Type} from "packages/mekanism/common/inventory/container/item/$PersonalStorageItemContainer"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$IDroppableContents, $IDroppableContents$Type} from "packages/mekanism/common/item/interfaces/$IDroppableContents"

export class $ItemBlockPersonalStorage<BLOCK extends $BlockPersonalStorage<(any), (any)>> extends $ItemBlockTooltip<(BLOCK)> implements $IDroppableContents, $IGuiItem {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: BLOCK, openStat: $ResourceLocation$Type)

public "onDestroyed"(item: $ItemEntity$Type, damageSource: $DamageSource$Type): void
public "getDroppedSlots"(stack: $ItemStack$Type): $List<($IInventorySlot)>
public "use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "getContainerType"(): $ContainerTypeRegistryObject<($PersonalStorageItemContainer)>
public "canContentsDrop"(stack: $ItemStack$Type): boolean
get "containerType"(): $ContainerTypeRegistryObject<($PersonalStorageItemContainer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockPersonalStorage$Type<BLOCK> = ($ItemBlockPersonalStorage<(BLOCK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockPersonalStorage_<BLOCK> = $ItemBlockPersonalStorage$Type<(BLOCK)>;
}}
declare module "packages/mekanism/common/lib/frequency/$TileComponentFrequency" {
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FrequencyType, $FrequencyType$Type} from "packages/mekanism/common/lib/frequency/$FrequencyType"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$Type} from "packages/mekanism/common/lib/frequency/$Frequency$FrequencyIdentity"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ITileComponent, $ITileComponent$Type} from "packages/mekanism/common/tile/component/$ITileComponent"

export class $TileComponentFrequency implements $ITileComponent {

constructor(tile: $TileEntityMekanism$Type)

public "write"(nbtTags: $CompoundTag$Type): void
public "read"(nbtTags: $CompoundTag$Type): void
public "invalidate"(): void
public "trackForMainContainer"(container: $MekanismContainer$Type): void
public "setFrequencyFromData"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>, data: $Frequency$FrequencyIdentity$Type, player: $UUID$Type): void
public "writeConfiguredFrequencies"(data: $CompoundTag$Type): void
public "readConfiguredFrequencies"(player: $Player$Type, data: $CompoundTag$Type): void
public "removeFrequencyFromData"(type: $FrequencyType$Type<(any)>, data: $Frequency$FrequencyIdentity$Type, player: $UUID$Type): void
public "hasCustomFrequencies"(): boolean
public "track"(type: $FrequencyType$Type<(any)>, needsSync: boolean, needsListCache: boolean, notifyNeighbors: boolean): void
public "getFrequency"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): FREQ
public "tickServer"(): void
public "getPublicCache"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): $List<(FREQ)>
public "getPrivateCache"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): $List<(FREQ)>
public "unsetFrequency"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): void
public "removed"(): void
public "readFromUpdateTag"(updateTag: $CompoundTag$Type): void
public "addToUpdateTag"(updateTag: $CompoundTag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileComponentFrequency$Type = ($TileComponentFrequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileComponentFrequency_ = $TileComponentFrequency$Type;
}}
declare module "packages/mekanism/common/tile/$TileEntityPersonalChest" {
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$LidBlockEntity, $LidBlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$LidBlockEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$TileEntityPersonalStorage, $TileEntityPersonalStorage$Type} from "packages/mekanism/common/tile/$TileEntityPersonalStorage"

export class $TileEntityPersonalChest extends $TileEntityPersonalStorage implements $LidBlockEntity {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "getOpenNess"(partialTicks: float): float
public "openGui"(player: $Player$Type): $InteractionResult
public "triggerEvent"(id: integer, type: integer): boolean
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityPersonalChest$Type = ($TileEntityPersonalChest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityPersonalChest_ = $TileEntityPersonalChest$Type;
}}
declare module "packages/mekanism/common/recipe/$WrappedShapedRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$ShapedRecipe, $ShapedRecipe$Type} from "packages/net/minecraft/world/item/crafting/$ShapedRecipe"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IShapedRecipe, $IShapedRecipe$Type} from "packages/net/minecraftforge/common/crafting/$IShapedRecipe"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CraftingBookCategory, $CraftingBookCategory$Type} from "packages/net/minecraft/world/item/crafting/$CraftingBookCategory"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$CraftingRecipe, $CraftingRecipe$Type} from "packages/net/minecraft/world/item/crafting/$CraftingRecipe"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $WrappedShapedRecipe implements $CraftingRecipe, $IShapedRecipe<($CraftingContainer)> {


public "matches"(inv: $CraftingContainer$Type, world: $Level$Type): boolean
public "getId"(): $ResourceLocation
public "isSpecial"(): boolean
public "category"(): $CraftingBookCategory
public "getInternal"(): $ShapedRecipe
public "isIncomplete"(): boolean
public "canCraftInDimensions"(width: integer, height: integer): boolean
public "getToastSymbol"(): $ItemStack
public "getIngredients"(): $NonNullList<($Ingredient)>
public "assemble"(inv: $CraftingContainer$Type, registryAccess: $RegistryAccess$Type): $ItemStack
public "getRemainingItems"(inv: $CraftingContainer$Type): $NonNullList<($ItemStack)>
public "getRecipeWidth"(): integer
public "getRecipeHeight"(): integer
public "getResultItem"(registryAccess: $RegistryAccess$Type): $ItemStack
public "getSerializer"(): $RecipeSerializer<(any)>
public "showNotification"(): boolean
public "getMod"(): string
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
public "getOrCreateId"(): $ResourceLocation
public "setGroup"(group: string): void
public "getGroup"(): string
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "getType"(): $ResourceLocation
get "id"(): $ResourceLocation
get "special"(): boolean
get "internal"(): $ShapedRecipe
get "incomplete"(): boolean
get "toastSymbol"(): $ItemStack
get "ingredients"(): $NonNullList<($Ingredient)>
get "recipeWidth"(): integer
get "recipeHeight"(): integer
get "serializer"(): $RecipeSerializer<(any)>
get "mod"(): string
get "schema"(): $RecipeSchema
get "orCreateId"(): $ResourceLocation
set "group"(value: string)
get "group"(): string
get "type"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedShapedRecipe$Type = ($WrappedShapedRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedShapedRecipe_ = $WrappedShapedRecipe$Type;
}}
declare module "packages/mekanism/common/lib/frequency/$IFrequencyItem" {
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$FrequencyType, $FrequencyType$Type} from "packages/mekanism/common/lib/frequency/$FrequencyType"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$Type} from "packages/mekanism/common/lib/frequency/$Frequency$FrequencyIdentity"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IFrequencyItem {

 "getFrequency"(stack: $ItemStack$Type): $Frequency
 "setFrequency"(stack: $ItemStack$Type, frequency: $Frequency$Type): void
 "getFrequencyIdentity"(stack: $ItemStack$Type): $Frequency$FrequencyIdentity
 "getFrequencyType"(): $FrequencyType<(any)>
 "hasFrequency"(stack: $ItemStack$Type): boolean

(stack: $ItemStack$Type): $Frequency
}

export namespace $IFrequencyItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFrequencyItem$Type = ($IFrequencyItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFrequencyItem_ = $IFrequencyItem$Type;
}}
declare module "packages/mekanism/common/inventory/$ISlotClickHandler$IScrollableSlot" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$HashedItem, $HashedItem$Type} from "packages/mekanism/common/lib/inventory/$HashedItem"

export interface $ISlotClickHandler$IScrollableSlot {

 "count"(): long
 "getDisplayName"(): string
 "item"(): $HashedItem
 "getModID"(): string
 "itemUUID"(): $UUID
}

export namespace $ISlotClickHandler$IScrollableSlot {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISlotClickHandler$IScrollableSlot$Type = ($ISlotClickHandler$IScrollableSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISlotClickHandler$IScrollableSlot_ = $ISlotClickHandler$IScrollableSlot$Type;
}}
declare module "packages/mekanism/common/item/interfaces/$IItemSustainedInventory" {
import {$ListTag, $ListTag$Type} from "packages/net/minecraft/nbt/$ListTag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ISustainedInventory, $ISustainedInventory$Type} from "packages/mekanism/common/tile/interfaces/$ISustainedInventory"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$IDroppableContents, $IDroppableContents$Type} from "packages/mekanism/common/item/interfaces/$IDroppableContents"

export interface $IItemSustainedInventory extends $ISustainedInventory, $IDroppableContents {

 "getSustainedInventory"(stack: $ItemStack$Type): $ListTag
 "getSustainedInventory"(): $ListTag
 "setSustainedInventory"(nbtTags: $ListTag$Type): void
 "setSustainedInventory"(nbtTags: $ListTag$Type, stack: $ItemStack$Type): void
 "getDroppedSlots"(stack: $ItemStack$Type): $List<($IInventorySlot)>
 "hasSustainedInventory"(stack: $ItemStack$Type): boolean
 "hasSustainedInventory"(): boolean
 "canContentsDrop"(stack: $ItemStack$Type): boolean
}

export namespace $IItemSustainedInventory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IItemSustainedInventory$Type = ($IItemSustainedInventory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IItemSustainedInventory_ = $IItemSustainedInventory$Type;
}}
declare module "packages/mekanism/common/item/$ItemNutritionalPasteBucket" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BucketItem, $BucketItem$Type} from "packages/net/minecraft/world/item/$BucketItem"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$UseAnim, $UseAnim$Type} from "packages/net/minecraft/world/item/$UseAnim"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemNutritionalPasteBucket extends $BucketItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(supplier: $Supplier$Type<(any)>, builder: $Item$Properties$Type)

public "initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "getUseDuration"(stack: $ItemStack$Type): integer
public "use"(level: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "finishUsingItem"(stack: $ItemStack$Type, level: $Level$Type, entity: $LivingEntity$Type): $ItemStack
public "getUseAnimation"(stack: $ItemStack$Type): $UseAnim
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemNutritionalPasteBucket$Type = ($ItemNutritionalPasteBucket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemNutritionalPasteBucket_ = $ItemNutritionalPasteBucket$Type;
}}
declare module "packages/mekanism/common/tile/$TileEntityPersonalStorage" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"

export class $TileEntityPersonalStorage extends $TileEntityMekanism {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState


public "close"(player: $Player$Type): void
public "open"(player: $Player$Type): void
public "recheckOpen"(): void
public "openGui"(player: $Player$Type): $InteractionResult
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityPersonalStorage$Type = ($TileEntityPersonalStorage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityPersonalStorage_ = $TileEntityPersonalStorage$Type;
}}
declare module "packages/mekanism/common/block/$BlockOre" {
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ILangEntry, $ILangEntry$Type} from "packages/mekanism/api/text/$ILangEntry"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$OreType, $OreType$Type} from "packages/mekanism/common/resource/ore/$OreType"
import {$IHasDescription, $IHasDescription$Type} from "packages/mekanism/common/block/interfaces/$IHasDescription"

export class $BlockOre extends $Block implements $IHasDescription {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(ore: $OreType$Type)
constructor(ore: $OreType$Type, properties: $BlockBehaviour$Properties$Type)

public "getDescription"(): $ILangEntry
public "getExpDrop"(state: $BlockState$Type, reader: $LevelReader$Type, random: $RandomSource$Type, pos: $BlockPos$Type, fortune: integer, silkTouch: integer): integer
public "getDescriptionTranslationKey"(): string
get "description"(): $ILangEntry
get "descriptionTranslationKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockOre$Type = ($BlockOre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockOre_ = $BlockOre$Type;
}}
declare module "packages/mekanism/common/content/network/transmitter/$DiversionTransporter$DiversionControl" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IIncrementalEnum, $IIncrementalEnum$Type} from "packages/mekanism/api/$IIncrementalEnum"
import {$IHasTextComponent, $IHasTextComponent$Type} from "packages/mekanism/api/text/$IHasTextComponent"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export class $DiversionTransporter$DiversionControl extends $Enum<($DiversionTransporter$DiversionControl)> implements $IIncrementalEnum<($DiversionTransporter$DiversionControl)>, $IHasTextComponent {
static readonly "DISABLED": $DiversionTransporter$DiversionControl
static readonly "HIGH": $DiversionTransporter$DiversionControl
static readonly "LOW": $DiversionTransporter$DiversionControl


public static "values"(): ($DiversionTransporter$DiversionControl)[]
public static "valueOf"(name: string): $DiversionTransporter$DiversionControl
public "byIndex"(index: integer): $DiversionTransporter$DiversionControl
public "getTextComponent"(): $Component
public static "byIndexStatic"(index: integer): $DiversionTransporter$DiversionControl
public "ordinal"(): integer
public "adjust"(arg0: integer): $DiversionTransporter$DiversionControl
public "adjust"(arg0: integer, arg1: $Predicate$Type<($DiversionTransporter$DiversionControl$Type)>): $DiversionTransporter$DiversionControl
public "getNext"(arg0: $Predicate$Type<($DiversionTransporter$DiversionControl$Type)>): $DiversionTransporter$DiversionControl
public "getNext"(): $DiversionTransporter$DiversionControl
public "getPrevious"(): $DiversionTransporter$DiversionControl
public "getPrevious"(arg0: $Predicate$Type<($DiversionTransporter$DiversionControl$Type)>): $DiversionTransporter$DiversionControl
get "textComponent"(): $Component
get "next"(): $DiversionTransporter$DiversionControl
get "previous"(): $DiversionTransporter$DiversionControl
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiversionTransporter$DiversionControl$Type = (("high") | ("low") | ("disabled")) | ($DiversionTransporter$DiversionControl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DiversionTransporter$DiversionControl_ = $DiversionTransporter$DiversionControl$Type;
}}
declare module "packages/mekanism/common/block/transmitter/$BlockTransmitter" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IStateFluidLoggable, $IStateFluidLoggable$Type} from "packages/mekanism/common/block/states/$IStateFluidLoggable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$PathComputationType, $PathComputationType$Type} from "packages/net/minecraft/world/level/pathfinder/$PathComputationType"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockMekanism, $BlockMekanism$Type} from "packages/mekanism/common/block/$BlockMekanism"

export class $BlockTransmitter extends $BlockMekanism implements $IStateFluidLoggable {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties


public "getName"(): $MutableComponent
public "setPlacedBy"(world: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, placer: $LivingEntity$Type, stack: $ItemStack$Type): void
public "onNeighborChange"(state: $BlockState$Type, world: $LevelReader$Type, pos: $BlockPos$Type, neighbor: $BlockPos$Type): void
/**
 * 
 * @deprecated
 */
public "neighborChanged"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, neighborBlock: $Block$Type, neighborPos: $BlockPos$Type, isMoving: boolean): void
/**
 * 
 * @deprecated
 */
public "isPathfindable"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, type: $PathComputationType$Type): boolean
/**
 * 
 * @deprecated
 */
public "use"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
/**
 * 
 * @deprecated
 */
public "getOcclusionShape"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type): $VoxelShape
/**
 * 
 * @deprecated
 */
public "getCollisionShape"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
/**
 * 
 * @deprecated
 */
public "getShape"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
public "setState"(state: $BlockState$Type, fluid: $Fluid$Type): $BlockState
public "getFluidLightLevel"(state: $BlockState$Type): integer
public "getFluid"(state: $BlockState$Type): $FluidState
public "canPlaceLiquid"(world: $BlockGetter$Type, pos: $BlockPos$Type, state: $BlockState$Type, fluid: $Fluid$Type): boolean
public "pickupBlock"(world: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type): $ItemStack
public "getPickupSound"(state: $BlockState$Type): $Optional<($SoundEvent)>
public "placeLiquid"(world: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type, fluidState: $FluidState$Type): boolean
public "getPickupSound"(): $Optional<($SoundEvent)>
public "getFluidLoggedProperty"(): $EnumProperty<(any)>
public "isValidFluid"(fluid: $Fluid$Type): boolean
public "updateFluids"(state: $BlockState$Type, world: $LevelAccessor$Type, currentPos: $BlockPos$Type): void
get "name"(): $MutableComponent
get "pickupSound"(): $Optional<($SoundEvent)>
get "fluidLoggedProperty"(): $EnumProperty<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTransmitter$Type = ($BlockTransmitter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTransmitter_ = $BlockTransmitter$Type;
}}
declare module "packages/mekanism/common/capabilities/chemical/$StackedWasteBarrel" {
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ChemicalAttributeValidator, $ChemicalAttributeValidator$Type} from "packages/mekanism/api/chemical/attribute/$ChemicalAttributeValidator"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$Gas, $Gas$Type} from "packages/mekanism/api/chemical/gas/$Gas"
import {$VariableCapacityChemicalTank, $VariableCapacityChemicalTank$Type} from "packages/mekanism/common/capabilities/chemical/variable/$VariableCapacityChemicalTank"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$TileEntityRadioactiveWasteBarrel, $TileEntityRadioactiveWasteBarrel$Type} from "packages/mekanism/common/tile/$TileEntityRadioactiveWasteBarrel"
import {$IGasHandler, $IGasHandler$Type} from "packages/mekanism/api/chemical/gas/$IGasHandler"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export class $StackedWasteBarrel extends $VariableCapacityChemicalTank<($Gas), ($GasStack)> implements $IGasHandler, $IGasTank {


public "insert"(stack: $GasStack$Type, action: $Action$Type, automationType: $AutomationType$Type): $GasStack
public static "create"(tile: $TileEntityRadioactiveWasteBarrel$Type, listener: $IContentsListener$Type): $StackedWasteBarrel
public "growStack"(amount: long, action: $Action$Type): long
public "deserializeNBT"(arg0: $CompoundTag$Type): void
public "createStack"(arg0: $GasStack$Type, arg1: long): $GasStack
public "isValid"(arg0: integer, arg1: $GasStack$Type): boolean
public "getTanks"(): integer
public "getTankCapacity"(arg0: integer): long
public "insertChemical"(arg0: integer, arg1: $GasStack$Type, arg2: $Action$Type): $GasStack
public "getChemicalInTank"(arg0: integer): $GasStack
public "extractChemical"(arg0: integer, arg1: long, arg2: $Action$Type): $GasStack
public "setChemicalInTank"(arg0: integer, arg1: $GasStack$Type): void
public "getEmptyStack"(): $GasStack
public "extract"(arg0: long, arg1: $Action$Type, arg2: $AutomationType$Type): $GasStack
public "isEmpty"(): boolean
public "getType"(): $Gas
public "getStack"(): $GasStack
public "isValid"(arg0: $GasStack$Type): boolean
public "setStack"(arg0: $GasStack$Type): void
public "isTypeEqual"(arg0: $Gas$Type): boolean
public "isTypeEqual"(arg0: $GasStack$Type): boolean
public "setStackUnchecked"(arg0: $GasStack$Type): void
public "getStored"(): long
public "getAttributeValidator"(): $ChemicalAttributeValidator
get "tanks"(): integer
get "emptyStack"(): $GasStack
get "empty"(): boolean
get "type"(): $Gas
get "stack"(): $GasStack
set "stack"(value: $GasStack$Type)
set "stackUnchecked"(value: $GasStack$Type)
get "stored"(): long
get "attributeValidator"(): $ChemicalAttributeValidator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StackedWasteBarrel$Type = ($StackedWasteBarrel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StackedWasteBarrel_ = $StackedWasteBarrel$Type;
}}
declare module "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager$GasHandlerManager" {
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$ChemicalHandlerManager, $ChemicalHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager"
import {$Gas, $Gas$Type} from "packages/mekanism/api/chemical/gas/$Gas"
import {$IGasHandler$ISidedGasHandler, $IGasHandler$ISidedGasHandler$Type} from "packages/mekanism/api/chemical/gas/$IGasHandler$ISidedGasHandler"
import {$IChemicalTankHolder, $IChemicalTankHolder$Type} from "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$IGasHandler, $IGasHandler$Type} from "packages/mekanism/api/chemical/gas/$IGasHandler"

export class $ChemicalHandlerManager$GasHandlerManager extends $ChemicalHandlerManager<($Gas), ($GasStack), ($IGasTank), ($IGasHandler), ($IGasHandler$ISidedGasHandler)> {

constructor(holder: $IChemicalTankHolder$Type<($Gas$Type), ($GasStack$Type), ($IGasTank$Type)>, baseHandler: $IGasHandler$ISidedGasHandler$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalHandlerManager$GasHandlerManager$Type = ($ChemicalHandlerManager$GasHandlerManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalHandlerManager$GasHandlerManager_ = $ChemicalHandlerManager$GasHandlerManager$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$PigmentMixingRecipeSerializer" {
import {$ChemicalStackIngredient$PigmentStackIngredient, $ChemicalStackIngredient$PigmentStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient$PigmentStackIngredient"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$ChemicalChemicalToChemicalRecipeSerializer$IFactory, $ChemicalChemicalToChemicalRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$ChemicalChemicalToChemicalRecipeSerializer$IFactory"
import {$PigmentMixingRecipe, $PigmentMixingRecipe$Type} from "packages/mekanism/api/recipes/$PigmentMixingRecipe"
import {$ChemicalChemicalToChemicalRecipeSerializer, $ChemicalChemicalToChemicalRecipeSerializer$Type} from "packages/mekanism/common/recipe/serializer/$ChemicalChemicalToChemicalRecipeSerializer"
import {$Pigment, $Pigment$Type} from "packages/mekanism/api/chemical/pigment/$Pigment"
import {$PigmentStack, $PigmentStack$Type} from "packages/mekanism/api/chemical/pigment/$PigmentStack"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $PigmentMixingRecipeSerializer<RECIPE extends $PigmentMixingRecipe> extends $ChemicalChemicalToChemicalRecipeSerializer<($Pigment), ($PigmentStack), ($ChemicalStackIngredient$PigmentStackIngredient), (RECIPE)> {

constructor(factory: $ChemicalChemicalToChemicalRecipeSerializer$IFactory$Type<($Pigment$Type), ($PigmentStack$Type), ($ChemicalStackIngredient$PigmentStackIngredient$Type), (RECIPE)>)

public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PigmentMixingRecipeSerializer$Type<RECIPE> = ($PigmentMixingRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PigmentMixingRecipeSerializer_<RECIPE> = $PigmentMixingRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/inventory/container/$QIOItemViewerContainer$ListSortType" {
import {$ISlotClickHandler$IScrollableSlot, $ISlotClickHandler$IScrollableSlot$Type} from "packages/mekanism/common/inventory/$ISlotClickHandler$IScrollableSlot"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$QIOItemViewerContainer$SortDirection, $QIOItemViewerContainer$SortDirection$Type} from "packages/mekanism/common/inventory/container/$QIOItemViewerContainer$SortDirection"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$List, $List$Type} from "packages/java/util/$List"
import {$GuiComponents$IDropdownEnum, $GuiComponents$IDropdownEnum$Type} from "packages/mekanism/common/inventory/$GuiComponents$IDropdownEnum"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $QIOItemViewerContainer$ListSortType extends $Enum<($QIOItemViewerContainer$ListSortType)> implements $GuiComponents$IDropdownEnum<($QIOItemViewerContainer$ListSortType)> {
static readonly "NAME": $QIOItemViewerContainer$ListSortType
static readonly "SIZE": $QIOItemViewerContainer$ListSortType
static readonly "MOD": $QIOItemViewerContainer$ListSortType


public static "values"(): ($QIOItemViewerContainer$ListSortType)[]
public static "valueOf"(name: string): $QIOItemViewerContainer$ListSortType
public "sort"(list: $List$Type<($ISlotClickHandler$IScrollableSlot$Type)>, direction: $QIOItemViewerContainer$SortDirection$Type): void
public "getShortName"(): $Component
public "getTooltip"(): $Component
public "getIcon"(): $ResourceLocation
get "shortName"(): $Component
get "tooltip"(): $Component
get "icon"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOItemViewerContainer$ListSortType$Type = (("mod") | ("size") | ("name")) | ($QIOItemViewerContainer$ListSortType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOItemViewerContainer$ListSortType_ = $QIOItemViewerContainer$ListSortType$Type;
}}
declare module "packages/mekanism/common/content/transporter/$TransporterStack$Path" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $TransporterStack$Path extends $Enum<($TransporterStack$Path)> {
static readonly "DEST": $TransporterStack$Path
static readonly "HOME": $TransporterStack$Path
static readonly "NONE": $TransporterStack$Path


public static "values"(): ($TransporterStack$Path)[]
public static "valueOf"(name: string): $TransporterStack$Path
public static "byIndexStatic"(index: integer): $TransporterStack$Path
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransporterStack$Path$Type = (("none") | ("dest") | ("home")) | ($TransporterStack$Path);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransporterStack$Path_ = $TransporterStack$Path$Type;
}}
declare module "packages/mekanism/common/capabilities/proxy/$ProxyConfigurable$ISidedConfigurable" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IConfigurable, $IConfigurable$Type} from "packages/mekanism/api/$IConfigurable"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"

export interface $ProxyConfigurable$ISidedConfigurable extends $IConfigurable {

 "onRightClick"(player: $Player$Type): $InteractionResult
 "onRightClick"(player: $Player$Type, side: $Direction$Type): $InteractionResult
 "onSneakRightClick"(player: $Player$Type): $InteractionResult
 "onSneakRightClick"(player: $Player$Type, side: $Direction$Type): $InteractionResult
}

export namespace $ProxyConfigurable$ISidedConfigurable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProxyConfigurable$ISidedConfigurable$Type = ($ProxyConfigurable$ISidedConfigurable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProxyConfigurable$ISidedConfigurable_ = $ProxyConfigurable$ISidedConfigurable$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/type/$BaseInputCache" {
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$InputIngredient, $InputIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$InputIngredient"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IInputCache, $IInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$IInputCache"
import {$IMultiIngredient, $IMultiIngredient$Type} from "packages/mekanism/common/recipe/ingredient/$IMultiIngredient"

export class $BaseInputCache<KEY, INPUT, INGREDIENT extends $InputIngredient<(INPUT)>, RECIPE extends $MekanismRecipe> implements $IInputCache<(INPUT), (INGREDIENT), (RECIPE)> {

constructor()

public "clear"(): void
public "contains"(input: INPUT, matchCriteria: $Predicate$Type<(RECIPE)>): boolean
public "contains"(input: INPUT): boolean
public "findFirstRecipe"(input: INPUT, matchCriteria: $Predicate$Type<(RECIPE)>): RECIPE
public "isEmpty"(input: INPUT): boolean
public "mapInputs"(recipe: RECIPE, inputIngredient: INGREDIENT): boolean
public "mapMultiInputs"(recipe: RECIPE, multi: $IMultiIngredient$Type<(INPUT), (any)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseInputCache$Type<KEY, INPUT, INGREDIENT, RECIPE> = ($BaseInputCache<(KEY), (INPUT), (INGREDIENT), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseInputCache_<KEY, INPUT, INGREDIENT, RECIPE> = $BaseInputCache$Type<(KEY), (INPUT), (INGREDIENT), (RECIPE)>;
}}
declare module "packages/mekanism/common/content/network/$BoxedChemicalNetwork" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$BoxedPressurizedTube, $BoxedPressurizedTube$Type} from "packages/mekanism/common/content/network/transmitter/$BoxedPressurizedTube"
import {$BoxedChemical, $BoxedChemical$Type} from "packages/mekanism/api/chemical/merged/$BoxedChemical"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$DynamicBufferedNetwork, $DynamicBufferedNetwork$Type} from "packages/mekanism/common/lib/transmitter/$DynamicBufferedNetwork"
import {$IGasTracker, $IGasTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IGasTracker"
import {$ISlurryTank, $ISlurryTank$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryTank"
import {$BoxedChemicalStack, $BoxedChemicalStack$Type} from "packages/mekanism/api/chemical/merged/$BoxedChemicalStack"
import {$IPigmentTank, $IPigmentTank$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentTank"
import {$IPigmentTracker, $IPigmentTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IPigmentTracker"
import {$ISlurryTracker, $ISlurryTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$ISlurryTracker"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BoxedChemicalHandler, $BoxedChemicalHandler$Type} from "packages/mekanism/common/capabilities/chemical/$BoxedChemicalHandler"
import {$IInfusionTracker, $IInfusionTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IInfusionTracker"
import {$IInfusionTank, $IInfusionTank$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionTank"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$MergedChemicalTank, $MergedChemicalTank$Type} from "packages/mekanism/api/chemical/merged/$MergedChemicalTank"

export class $BoxedChemicalNetwork extends $DynamicBufferedNetwork<($BoxedChemicalHandler), ($BoxedChemicalNetwork), ($BoxedChemicalStack), ($BoxedPressurizedTube)> implements $IGasTracker, $IInfusionTracker, $IPigmentTracker, $ISlurryTracker {
readonly "chemicalTank": $MergedChemicalTank
 "lastChemical": $BoxedChemical
 "currentScale": float

constructor(networkID: $UUID$Type)
constructor(networks: $Collection$Type<($BoxedChemicalNetwork$Type)>)

public "toString"(): string
public "isCompatibleWith"(other: $BoxedChemicalNetwork$Type): boolean
public "getBuffer"(): $BoxedChemicalStack
public "getPrevTransferAmount"(): long
public "onContentsChanged"(): void
public "adoptTransmittersAndAcceptorsFrom"(net: $BoxedChemicalNetwork$Type): $List<($BoxedPressurizedTube)>
public "getGasTank"(): $IGasTank
public "getSlurryTank"(): $ISlurryTank
public "getInfusionTank"(): $IInfusionTank
public "getPigmentTank"(): $IPigmentTank
public "onUpdate"(): void
public "isTankEmpty"(): boolean
public "setLastChemical"(chemical: $BoxedChemical$Type): void
public "absorbBuffer"(transmitter: $BoxedPressurizedTube$Type): void
public "getFlowInfo"(): $Component
public "getStoredInfo"(): $Component
public "clampBuffer"(): void
public "getNeededInfo"(): $Component
public "getTextComponent"(): $Component
public "getInfusionTanks"(side: $Direction$Type): $List<($IInfusionTank)>
public "getPigmentTanks"(side: $Direction$Type): $List<($IPigmentTank)>
public "getGasTanks"(side: $Direction$Type): $List<($IGasTank)>
public "getSlurryTanks"(side: $Direction$Type): $List<($ISlurryTank)>
get "buffer"(): $BoxedChemicalStack
get "prevTransferAmount"(): long
get "gasTank"(): $IGasTank
get "slurryTank"(): $ISlurryTank
get "infusionTank"(): $IInfusionTank
get "pigmentTank"(): $IPigmentTank
get "tankEmpty"(): boolean
set "lastChemical"(value: $BoxedChemical$Type)
get "flowInfo"(): $Component
get "storedInfo"(): $Component
get "neededInfo"(): $Component
get "textComponent"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoxedChemicalNetwork$Type = ($BoxedChemicalNetwork);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoxedChemicalNetwork_ = $BoxedChemicalNetwork$Type;
}}
declare module "packages/mekanism/common/lib/frequency/$IFrequencyHandler" {
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FrequencyType, $FrequencyType$Type} from "packages/mekanism/common/lib/frequency/$FrequencyType"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$Type} from "packages/mekanism/common/lib/frequency/$Frequency$FrequencyIdentity"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$TileComponentFrequency, $TileComponentFrequency$Type} from "packages/mekanism/common/lib/frequency/$TileComponentFrequency"
import {$List, $List$Type} from "packages/java/util/$List"

export interface $IFrequencyHandler {

 "getFrequencyComponent"(): $TileComponentFrequency
 "getFrequency"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): FREQ
 "setFrequency"(type: $FrequencyType$Type<(any)>, data: $Frequency$FrequencyIdentity$Type, player: $UUID$Type): void
 "setFrequency"(type: $FrequencyType$Type<(any)>, frequencyCompound: $CompoundTag$Type): void
 "removeFrequency"(type: $FrequencyType$Type<(any)>, data: $Frequency$FrequencyIdentity$Type, player: $UUID$Type): void
 "getPublicCache"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): $List<(FREQ)>
 "getPrivateCache"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): $List<(FREQ)>

(): $TileComponentFrequency
}

export namespace $IFrequencyHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFrequencyHandler$Type = ($IFrequencyHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFrequencyHandler_ = $IFrequencyHandler$Type;
}}
declare module "packages/mekanism/common/recipe/$MekanismRecipeType" {
import {$ItemStackGasToItemStackRecipe, $ItemStackGasToItemStackRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackGasToItemStackRecipe"
import {$InputRecipeCache$SingleItem, $InputRecipeCache$SingleItem$Type} from "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$SingleItem"
import {$InputRecipeCache$SingleFluid, $InputRecipeCache$SingleFluid$Type} from "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$SingleFluid"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$RecipeTypeRegistryObject, $RecipeTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$RecipeTypeRegistryObject"
import {$MetallurgicInfuserRecipe, $MetallurgicInfuserRecipe$Type} from "packages/mekanism/api/recipes/$MetallurgicInfuserRecipe"
import {$RecipeTypeDeferredRegister, $RecipeTypeDeferredRegister$Type} from "packages/mekanism/common/registration/impl/$RecipeTypeDeferredRegister"
import {$FluidToFluidRecipe, $FluidToFluidRecipe$Type} from "packages/mekanism/api/recipes/$FluidToFluidRecipe"
import {$IMekanismRecipeTypeProvider, $IMekanismRecipeTypeProvider$Type} from "packages/mekanism/common/recipe/$IMekanismRecipeTypeProvider"
import {$Slurry, $Slurry$Type} from "packages/mekanism/api/chemical/slurry/$Slurry"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStackToPigmentRecipe, $ItemStackToPigmentRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackToPigmentRecipe"
import {$InputRecipeCache$EitherSideChemical, $InputRecipeCache$EitherSideChemical$Type} from "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$EitherSideChemical"
import {$ChemicalCrystallizerRecipe, $ChemicalCrystallizerRecipe$Type} from "packages/mekanism/api/recipes/$ChemicalCrystallizerRecipe"
import {$ItemStackToInfuseTypeRecipe, $ItemStackToInfuseTypeRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackToInfuseTypeRecipe"
import {$ElectrolysisRecipe, $ElectrolysisRecipe$Type} from "packages/mekanism/api/recipes/$ElectrolysisRecipe"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$RotaryRecipe, $RotaryRecipe$Type} from "packages/mekanism/api/recipes/$RotaryRecipe"
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$SlurryStack, $SlurryStack$Type} from "packages/mekanism/api/chemical/slurry/$SlurryStack"
import {$GasToGasRecipe, $GasToGasRecipe$Type} from "packages/mekanism/api/recipes/$GasToGasRecipe"
import {$PressurizedReactionRecipe, $PressurizedReactionRecipe$Type} from "packages/mekanism/api/recipes/$PressurizedReactionRecipe"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$PigmentMixingRecipe, $PigmentMixingRecipe$Type} from "packages/mekanism/api/recipes/$PigmentMixingRecipe"
import {$RotaryInputRecipeCache, $RotaryInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$RotaryInputRecipeCache"
import {$Pigment, $Pigment$Type} from "packages/mekanism/api/chemical/pigment/$Pigment"
import {$ItemStackToItemStackRecipe, $ItemStackToItemStackRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackToItemStackRecipe"
import {$InputRecipeCache$SingleChemical, $InputRecipeCache$SingleChemical$Type} from "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$SingleChemical"
import {$ItemStackToEnergyRecipe, $ItemStackToEnergyRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackToEnergyRecipe"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$CombinerRecipe, $CombinerRecipe$Type} from "packages/mekanism/api/recipes/$CombinerRecipe"
import {$InfuseType, $InfuseType$Type} from "packages/mekanism/api/chemical/infuse/$InfuseType"
import {$NucleosynthesizingRecipe, $NucleosynthesizingRecipe$Type} from "packages/mekanism/api/recipes/$NucleosynthesizingRecipe"
import {$InputRecipeCache$ItemChemical, $InputRecipeCache$ItemChemical$Type} from "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$ItemChemical"
import {$SawmillRecipe, $SawmillRecipe$Type} from "packages/mekanism/api/recipes/$SawmillRecipe"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$Gas, $Gas$Type} from "packages/mekanism/api/chemical/gas/$Gas"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IInputRecipeCache, $IInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$IInputRecipeCache"
import {$PigmentStack, $PigmentStack$Type} from "packages/mekanism/api/chemical/pigment/$PigmentStack"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ChemicalInfuserRecipe, $ChemicalInfuserRecipe$Type} from "packages/mekanism/api/recipes/$ChemicalInfuserRecipe"
import {$InputRecipeCache$DoubleItem, $InputRecipeCache$DoubleItem$Type} from "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$DoubleItem"
import {$PaintingRecipe, $PaintingRecipe$Type} from "packages/mekanism/api/recipes/$PaintingRecipe"
import {$ItemStackToGasRecipe, $ItemStackToGasRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackToGasRecipe"
import {$InputRecipeCache$FluidChemical, $InputRecipeCache$FluidChemical$Type} from "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$FluidChemical"
import {$FluidSlurryToSlurryRecipe, $FluidSlurryToSlurryRecipe$Type} from "packages/mekanism/api/recipes/$FluidSlurryToSlurryRecipe"
import {$ChemicalCrystallizerInputRecipeCache, $ChemicalCrystallizerInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$ChemicalCrystallizerInputRecipeCache"
import {$InfusionStack, $InfusionStack$Type} from "packages/mekanism/api/chemical/infuse/$InfusionStack"
import {$InputRecipeCache$ItemFluidChemical, $InputRecipeCache$ItemFluidChemical$Type} from "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$ItemFluidChemical"
import {$ChemicalDissolutionRecipe, $ChemicalDissolutionRecipe$Type} from "packages/mekanism/api/recipes/$ChemicalDissolutionRecipe"

export class $MekanismRecipeType<RECIPE extends $MekanismRecipe, INPUT_CACHE extends $IInputRecipeCache> implements $RecipeType<(RECIPE)>, $IMekanismRecipeTypeProvider<(RECIPE), (INPUT_CACHE)> {
static readonly "RECIPE_TYPES": $RecipeTypeDeferredRegister
static readonly "CRUSHING": $RecipeTypeRegistryObject<($ItemStackToItemStackRecipe), ($InputRecipeCache$SingleItem<($ItemStackToItemStackRecipe)>)>
static readonly "ENRICHING": $RecipeTypeRegistryObject<($ItemStackToItemStackRecipe), ($InputRecipeCache$SingleItem<($ItemStackToItemStackRecipe)>)>
static readonly "SMELTING": $RecipeTypeRegistryObject<($ItemStackToItemStackRecipe), ($InputRecipeCache$SingleItem<($ItemStackToItemStackRecipe)>)>
static readonly "CHEMICAL_INFUSING": $RecipeTypeRegistryObject<($ChemicalInfuserRecipe), ($InputRecipeCache$EitherSideChemical<($Gas), ($GasStack), ($ChemicalInfuserRecipe)>)>
static readonly "COMBINING": $RecipeTypeRegistryObject<($CombinerRecipe), ($InputRecipeCache$DoubleItem<($CombinerRecipe)>)>
static readonly "SEPARATING": $RecipeTypeRegistryObject<($ElectrolysisRecipe), ($InputRecipeCache$SingleFluid<($ElectrolysisRecipe)>)>
static readonly "WASHING": $RecipeTypeRegistryObject<($FluidSlurryToSlurryRecipe), ($InputRecipeCache$FluidChemical<($Slurry), ($SlurryStack), ($FluidSlurryToSlurryRecipe)>)>
static readonly "EVAPORATING": $RecipeTypeRegistryObject<($FluidToFluidRecipe), ($InputRecipeCache$SingleFluid<($FluidToFluidRecipe)>)>
static readonly "ACTIVATING": $RecipeTypeRegistryObject<($GasToGasRecipe), ($InputRecipeCache$SingleChemical<($Gas), ($GasStack), ($GasToGasRecipe)>)>
static readonly "CENTRIFUGING": $RecipeTypeRegistryObject<($GasToGasRecipe), ($InputRecipeCache$SingleChemical<($Gas), ($GasStack), ($GasToGasRecipe)>)>
static readonly "CRYSTALLIZING": $RecipeTypeRegistryObject<($ChemicalCrystallizerRecipe), ($ChemicalCrystallizerInputRecipeCache)>
static readonly "DISSOLUTION": $RecipeTypeRegistryObject<($ChemicalDissolutionRecipe), ($InputRecipeCache$ItemChemical<($Gas), ($GasStack), ($ChemicalDissolutionRecipe)>)>
static readonly "COMPRESSING": $RecipeTypeRegistryObject<($ItemStackGasToItemStackRecipe), ($InputRecipeCache$ItemChemical<($Gas), ($GasStack), ($ItemStackGasToItemStackRecipe)>)>
static readonly "PURIFYING": $RecipeTypeRegistryObject<($ItemStackGasToItemStackRecipe), ($InputRecipeCache$ItemChemical<($Gas), ($GasStack), ($ItemStackGasToItemStackRecipe)>)>
static readonly "INJECTING": $RecipeTypeRegistryObject<($ItemStackGasToItemStackRecipe), ($InputRecipeCache$ItemChemical<($Gas), ($GasStack), ($ItemStackGasToItemStackRecipe)>)>
static readonly "NUCLEOSYNTHESIZING": $RecipeTypeRegistryObject<($NucleosynthesizingRecipe), ($InputRecipeCache$ItemChemical<($Gas), ($GasStack), ($NucleosynthesizingRecipe)>)>
static readonly "ENERGY_CONVERSION": $RecipeTypeRegistryObject<($ItemStackToEnergyRecipe), ($InputRecipeCache$SingleItem<($ItemStackToEnergyRecipe)>)>
static readonly "GAS_CONVERSION": $RecipeTypeRegistryObject<($ItemStackToGasRecipe), ($InputRecipeCache$SingleItem<($ItemStackToGasRecipe)>)>
static readonly "OXIDIZING": $RecipeTypeRegistryObject<($ItemStackToGasRecipe), ($InputRecipeCache$SingleItem<($ItemStackToGasRecipe)>)>
static readonly "INFUSION_CONVERSION": $RecipeTypeRegistryObject<($ItemStackToInfuseTypeRecipe), ($InputRecipeCache$SingleItem<($ItemStackToInfuseTypeRecipe)>)>
static readonly "PIGMENT_EXTRACTING": $RecipeTypeRegistryObject<($ItemStackToPigmentRecipe), ($InputRecipeCache$SingleItem<($ItemStackToPigmentRecipe)>)>
static readonly "PIGMENT_MIXING": $RecipeTypeRegistryObject<($PigmentMixingRecipe), ($InputRecipeCache$EitherSideChemical<($Pigment), ($PigmentStack), ($PigmentMixingRecipe)>)>
static readonly "METALLURGIC_INFUSING": $RecipeTypeRegistryObject<($MetallurgicInfuserRecipe), ($InputRecipeCache$ItemChemical<($InfuseType), ($InfusionStack), ($MetallurgicInfuserRecipe)>)>
static readonly "PAINTING": $RecipeTypeRegistryObject<($PaintingRecipe), ($InputRecipeCache$ItemChemical<($Pigment), ($PigmentStack), ($PaintingRecipe)>)>
static readonly "REACTION": $RecipeTypeRegistryObject<($PressurizedReactionRecipe), ($InputRecipeCache$ItemFluidChemical<($Gas), ($GasStack), ($PressurizedReactionRecipe)>)>
static readonly "ROTARY": $RecipeTypeRegistryObject<($RotaryRecipe), ($RotaryInputRecipeCache)>
static readonly "SAWING": $RecipeTypeRegistryObject<($SawmillRecipe), ($InputRecipeCache$SingleItem<($SawmillRecipe)>)>


public "toString"(): string
public static "clearCache"(): void
public "getRecipeType"(): $MekanismRecipeType<(RECIPE), (INPUT_CACHE)>
public "getRegistryName"(): $ResourceLocation
public static "byKey"(level: $Level$Type, id: $ResourceLocation$Type): $Optional<(any)>
public "getInputCache"(): INPUT_CACHE
public "getRecipes"(world: $Level$Type): $List<(RECIPE)>
public static "getRecipeFor"<C extends $Container, RECIPE_TYPE extends $Recipe<(C)>>(recipeType: $RecipeType$Type<(RECIPE_TYPE)>, inventory: C, level: $Level$Type): $Optional<(RECIPE_TYPE)>
public static "simple"<T extends $Recipe<(any)>>(arg0: $ResourceLocation$Type): $RecipeType<(RECIPE)>
public static "register"<T extends $Recipe<(any)>>(arg0: string): $RecipeType<(RECIPE)>
public "stream"(world: $Level$Type): $Stream<(RECIPE)>
public "contains"(world: $Level$Type, matchCriteria: $Predicate$Type<(RECIPE)>): boolean
public "findFirst"(world: $Level$Type, matchCriteria: $Predicate$Type<(RECIPE)>): RECIPE
get "recipeType"(): $MekanismRecipeType<(RECIPE), (INPUT_CACHE)>
get "registryName"(): $ResourceLocation
get "inputCache"(): INPUT_CACHE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismRecipeType$Type<RECIPE, INPUT_CACHE> = ($MekanismRecipeType<(RECIPE), (INPUT_CACHE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismRecipeType_<RECIPE, INPUT_CACHE> = $MekanismRecipeType$Type<(RECIPE), (INPUT_CACHE)>;
}}
declare module "packages/mekanism/common/tile/component/$TileComponentConfig" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$DataType, $DataType$Type} from "packages/mekanism/common/tile/component/config/$DataType"
import {$ISlotInfo, $ISlotInfo$Type} from "packages/mekanism/common/tile/component/config/slot/$ISlotInfo"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$ITileComponent, $ITileComponent$Type} from "packages/mekanism/common/tile/component/$ITileComponent"
import {$TransmissionType, $TransmissionType$Type} from "packages/mekanism/common/lib/transmitter/$TransmissionType"
import {$BaseSlotInfo, $BaseSlotInfo$Type} from "packages/mekanism/common/tile/component/config/slot/$BaseSlotInfo"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$RelativeSide, $RelativeSide$Type} from "packages/mekanism/api/$RelativeSide"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$ConfigInfo, $ConfigInfo$Type} from "packages/mekanism/common/tile/component/config/$ConfigInfo"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ISyncableData, $ISyncableData$Type} from "packages/mekanism/common/inventory/container/sync/$ISyncableData"
import {$MekanismContainer$ISpecificContainerTracker, $MekanismContainer$ISpecificContainerTracker$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer$ISpecificContainerTracker"

export class $TileComponentConfig implements $ITileComponent, $MekanismContainer$ISpecificContainerTracker {
readonly "tile": $TileEntityMekanism

constructor(tile: $TileEntityMekanism$Type, ...types: ($TransmissionType$Type)[])

public "write"(nbtTags: $CompoundTag$Type): void
public "read"(nbtTags: $CompoundTag$Type): void
public "readFromUpdateTag"(updateTag: $CompoundTag$Type): void
public "addToUpdateTag"(updateTag: $CompoundTag$Type): void
public "getDataType"(type: $TransmissionType$Type, side: $RelativeSide$Type): $DataType
public "supports"(type: $TransmissionType$Type): boolean
public "getSlotInfo"(type: $TransmissionType$Type, direction: $Direction$Type): $ISlotInfo
public "getConfig"(type: $TransmissionType$Type): $ConfigInfo
public "setupItemIOExtraConfig"(inputSlot: $IInventorySlot$Type, outputSlot: $IInventorySlot$Type, extraSlot: $IInventorySlot$Type, energySlot: $IInventorySlot$Type): $ConfigInfo
public static "createInfo"(type: $TransmissionType$Type, input: boolean, output: boolean, containers: $List$Type<(any)>): $BaseSlotInfo
public static "createInfo"(type: $TransmissionType$Type, input: boolean, output: boolean, ...containers: (any)[]): $BaseSlotInfo
public "isCapabilityDisabled"(capability: $Capability$Type<(any)>, side: $Direction$Type): boolean
public "getSpecificSyncableData"(): $List<($ISyncableData)>
public "sideChanged"(transmissionType: $TransmissionType$Type, side: $RelativeSide$Type): void
public "addDisabledSides"(...sides: ($RelativeSide$Type)[]): void
public "addSupported"(type: $TransmissionType$Type): void
public "setupItemIOConfig"(inputSlots: $List$Type<($IInventorySlot$Type)>, outputSlots: $List$Type<($IInventorySlot$Type)>, energySlot: $IInventorySlot$Type, alwaysAllow: boolean): $ConfigInfo
public "setupItemIOConfig"(inputSlot: $IInventorySlot$Type, outputSlot: $IInventorySlot$Type, energySlot: $IInventorySlot$Type): $ConfigInfo
public "setupInputConfig"(type: $TransmissionType$Type, container: any): $ConfigInfo
public "setupOutputConfig"(type: $TransmissionType$Type, container: any, ...sides: ($RelativeSide$Type)[]): $ConfigInfo
public "setupIOConfig"(type: $TransmissionType$Type, info: any, outputSide: $RelativeSide$Type): $ConfigInfo
public "setupIOConfig"(type: $TransmissionType$Type, info: any, outputSide: $RelativeSide$Type, alwaysAllow: boolean): $ConfigInfo
public "setupIOConfig"(type: $TransmissionType$Type, inputInfo: any, outputInfo: any, outputSide: $RelativeSide$Type): $ConfigInfo
public "setupIOConfig"(type: $TransmissionType$Type, inputContainer: any, outputContainer: any, outputSide: $RelativeSide$Type, alwaysAllow: boolean): $ConfigInfo
public "setupIOConfig"(type: $TransmissionType$Type, inputContainer: any, outputContainer: any, outputSide: $RelativeSide$Type, alwaysAllowInput: boolean, alwaysAllowOutput: boolean): $ConfigInfo
public "getTransmissions"(): $List<($TransmissionType)>
public "addConfigChangeListener"(transmissionType: $TransmissionType$Type, listener: $Consumer$Type<($Direction$Type)>): void
public "removed"(): void
public "invalidate"(): void
public "trackForMainContainer"(container: $MekanismContainer$Type): void
get "specificSyncableData"(): $List<($ISyncableData)>
get "transmissions"(): $List<($TransmissionType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileComponentConfig$Type = ($TileComponentConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileComponentConfig_ = $TileComponentConfig$Type;
}}
declare module "packages/mekanism/common/lib/multiblock/$MultiblockManager" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$MultiblockCache, $MultiblockCache$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockCache"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IStructureValidator, $IStructureValidator$Type} from "packages/mekanism/common/lib/multiblock/$IStructureValidator"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$MultiblockData, $MultiblockData$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockData"

export class $MultiblockManager<T extends $MultiblockData> {

constructor(name: string, cacheSupplier: $Supplier$Type<($MultiblockCache$Type<(T)>)>, validatorSupplier: $Supplier$Type<($IStructureValidator$Type<(T)>)>)

public "getName"(): string
public static "reset"(): void
public "getCache"(multiblockID: $UUID$Type): $MultiblockCache<(T)>
public "isCompatible"(tile: $BlockEntity$Type): boolean
public "getUniqueInventoryID"(): $UUID
public "handleDirtyMultiblock"(multiblock: T): void
public "createCache"(): $MultiblockCache<(T)>
public "trackCache"(id: $UUID$Type, cache: $MultiblockCache$Type<(T)>): void
public static "createOrLoadAll"(): void
public "replaceCaches"(staleIds: $Set$Type<($UUID$Type)>, id: $UUID$Type, cache: $MultiblockCache$Type<(T)>): void
public "getNameLower"(): string
public "createValidator"(): $IStructureValidator<(T)>
get "name"(): string
get "uniqueInventoryID"(): $UUID
get "nameLower"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockManager$Type<T> = ($MultiblockManager<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockManager_<T> = $MultiblockManager$Type<(T)>;
}}
declare module "packages/mekanism/common/item/block/$ItemBlockCardboardBox" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemBlockMekanism, $ItemBlockMekanism$Type} from "packages/mekanism/common/item/block/$ItemBlockMekanism"
import {$BlockCardboardBox$BlockData, $BlockCardboardBox$BlockData$Type} from "packages/mekanism/common/block/$BlockCardboardBox$BlockData"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$BlockCardboardBox, $BlockCardboardBox$Type} from "packages/mekanism/common/block/$BlockCardboardBox"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockCardboardBox extends $ItemBlockMekanism<($BlockCardboardBox)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockCardboardBox$Type)

public "getMaxStackSize"(stack: $ItemStack$Type): integer
public "placeBlock"(context: $BlockPlaceContext$Type, state: $BlockState$Type): boolean
public "getBlockData"(level: $Level$Type, stack: $ItemStack$Type): $BlockCardboardBox$BlockData
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "onItemUseFirst"(stack: $ItemStack$Type, context: $UseOnContext$Type): $InteractionResult
public "setBlockData"(stack: $ItemStack$Type, data: $BlockCardboardBox$BlockData$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockCardboardBox$Type = ($ItemBlockCardboardBox);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockCardboardBox_ = $ItemBlockCardboardBox$Type;
}}
declare module "packages/mekanism/common/tier/$FactoryTier" {
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"

export class $FactoryTier extends $Enum<($FactoryTier)> implements $ITier {
static readonly "BASIC": $FactoryTier
static readonly "ADVANCED": $FactoryTier
static readonly "ELITE": $FactoryTier
static readonly "ULTIMATE": $FactoryTier
readonly "processes": integer


public static "values"(): ($FactoryTier)[]
public static "valueOf"(name: string): $FactoryTier
public "getBaseTier"(): $BaseTier
get "baseTier"(): $BaseTier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryTier$Type = (("elite") | ("advanced") | ("ultimate") | ("basic")) | ($FactoryTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FactoryTier_ = $FactoryTier$Type;
}}
declare module "packages/mekanism/common/block/prefab/$BlockBase" {
import {$ITypeBlock, $ITypeBlock$Type} from "packages/mekanism/common/block/interfaces/$ITypeBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockType, $BlockType$Type} from "packages/mekanism/common/content/blocktype/$BlockType"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ILangEntry, $ILangEntry$Type} from "packages/mekanism/api/text/$ILangEntry"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$PathComputationType, $PathComputationType$Type} from "packages/net/minecraft/world/level/pathfinder/$PathComputationType"
import {$IHasDescription, $IHasDescription$Type} from "packages/mekanism/common/block/interfaces/$IHasDescription"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockMekanism, $BlockMekanism$Type} from "packages/mekanism/common/block/$BlockMekanism"

export class $BlockBase<TYPE extends $BlockType> extends $BlockMekanism implements $IHasDescription, $ITypeBlock {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(type: TYPE, propertyModifier: $UnaryOperator$Type<($BlockBehaviour$Properties$Type)>)
constructor(type: TYPE, properties: $BlockBehaviour$Properties$Type)

public "getType"(): $BlockType
public "getDescription"(): $ILangEntry
public "getName"(): $MutableComponent
public "getExplosionResistance"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, explosion: $Explosion$Type): float
/**
 * 
 * @deprecated
 */
public "isPathfindable"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, pathType: $PathComputationType$Type): boolean
/**
 * 
 * @deprecated
 */
public "use"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
/**
 * 
 * @deprecated
 */
public "getShape"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
get "type"(): $BlockType
get "description"(): $ILangEntry
get "name"(): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBase$Type<TYPE> = ($BlockBase<(TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBase_<TYPE> = $BlockBase$Type<(TYPE)>;
}}
declare module "packages/mekanism/common/world/$ResizableDiskConfig" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ConfiguredFeature, $ConfiguredFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$ConfiguredFeature"
import {$BlockPredicate, $BlockPredicate$Type} from "packages/net/minecraft/world/level/levelgen/blockpredicates/$BlockPredicate"
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntProvider, $IntProvider$Type} from "packages/net/minecraft/util/valueproviders/$IntProvider"
import {$DiskConfiguration, $DiskConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DiskConfiguration"
import {$FeatureConfiguration, $FeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$FeatureConfiguration"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$RuleBasedBlockStateProvider, $RuleBasedBlockStateProvider$Type} from "packages/net/minecraft/world/level/levelgen/feature/stateproviders/$RuleBasedBlockStateProvider"

export class $ResizableDiskConfig extends $Record implements $FeatureConfiguration {
static readonly "CODEC": $Codec<($ResizableDiskConfig)>

constructor(stateProvider: $RuleBasedBlockStateProvider$Type, target: $BlockPredicate$Type, radius: $IntProvider$Type)
constructor(stateProvider: $RuleBasedBlockStateProvider$Type, target: $BlockPredicate$Type, radius: $IntProvider$Type, halfHeight: $IntSupplier$Type)

public "equals"(o: any): boolean
public "target"(): $BlockPredicate
public "toString"(): string
public "hashCode"(): integer
public "stateProvider"(): $RuleBasedBlockStateProvider
public "radius"(): $IntProvider
public "halfHeight"(): $IntSupplier
public "asVanillaConfig"(): $DiskConfiguration
public "getFeatures"(): $Stream<($ConfiguredFeature<(any), (any)>)>
get "features"(): $Stream<($ConfiguredFeature<(any), (any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResizableDiskConfig$Type = ($ResizableDiskConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResizableDiskConfig_ = $ResizableDiskConfig$Type;
}}
declare module "packages/mekanism/common/lib/transmitter/$TransmissionType" {
import {$IHasTranslationKey, $IHasTranslationKey$Type} from "packages/mekanism/api/text/$IHasTranslationKey"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$ILangEntry, $ILangEntry$Type} from "packages/mekanism/api/text/$ILangEntry"
import {$Transmitter, $Transmitter$Type} from "packages/mekanism/common/content/network/transmitter/$Transmitter"

export class $TransmissionType extends $Enum<($TransmissionType)> implements $IHasTranslationKey {
static readonly "ENERGY": $TransmissionType
static readonly "FLUID": $TransmissionType
static readonly "GAS": $TransmissionType
static readonly "INFUSION": $TransmissionType
static readonly "PIGMENT": $TransmissionType
static readonly "SLURRY": $TransmissionType
static readonly "ITEM": $TransmissionType
static readonly "HEAT": $TransmissionType


public "getName"(): string
public static "values"(): ($TransmissionType)[]
public static "valueOf"(name: string): $TransmissionType
public "getTranslationKey"(): string
public "checkTransmissionType"(transmitter: $TileEntityTransmitter$Type): boolean
public "checkTransmissionType"(transmitter: $Transmitter$Type<(any), (any), (any)>): boolean
public "isChemical"(): boolean
public "getTransmission"(): string
public "getLangEntry"(): $ILangEntry
get "name"(): string
get "translationKey"(): string
get "chemical"(): boolean
get "transmission"(): string
get "langEntry"(): $ILangEntry
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransmissionType$Type = (("heat") | ("item") | ("infusion") | ("gas") | ("pigment") | ("fluid") | ("slurry") | ("energy")) | ($TransmissionType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransmissionType_ = $TransmissionType$Type;
}}
declare module "packages/mekanism/common/inventory/container/type/$MekanismContainerType$IMekanismSidedContainerFactory" {
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$MekanismContainerType$IMekanismContainerFactory, $MekanismContainerType$IMekanismContainerFactory$Type} from "packages/mekanism/common/inventory/container/type/$MekanismContainerType$IMekanismContainerFactory"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export interface $MekanismContainerType$IMekanismSidedContainerFactory<T, CONTAINER extends $AbstractContainerMenu> extends $MekanismContainerType$IMekanismContainerFactory<(T), (CONTAINER)> {

 "create"(id: integer, inv: $Inventory$Type, data: T, remote: boolean): CONTAINER
 "create"(id: integer, inv: $Inventory$Type, data: T): CONTAINER

(id: integer, inv: $Inventory$Type, data: T, remote: boolean): CONTAINER
}

export namespace $MekanismContainerType$IMekanismSidedContainerFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismContainerType$IMekanismSidedContainerFactory$Type<T, CONTAINER> = ($MekanismContainerType$IMekanismSidedContainerFactory<(T), (CONTAINER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismContainerType$IMekanismSidedContainerFactory_<T, CONTAINER> = $MekanismContainerType$IMekanismSidedContainerFactory$Type<(T), (CONTAINER)>;
}}
declare module "packages/mekanism/common/block/$BlockMekanism" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$PushReaction, $PushReaction$Type} from "packages/net/minecraft/world/level/material/$PushReaction"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IClientBlockExtensions, $IClientBlockExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientBlockExtensions"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$LootParams$Builder, $LootParams$Builder$Type} from "packages/net/minecraft/world/level/storage/loot/$LootParams$Builder"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"

export class $BlockMekanism extends $Block {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties


public "rotate"(state: $BlockState$Type, world: $LevelAccessor$Type, pos: $BlockPos$Type, rotation: $Rotation$Type): $BlockState
public "animateTick"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, random: $RandomSource$Type): void
public "getStateForPlacement"(context: $BlockPlaceContext$Type): $BlockState
public "setPlacedBy"(world: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, placer: $LivingEntity$Type, stack: $ItemStack$Type): void
public "initializeClient"(consumer: $Consumer$Type<($IClientBlockExtensions$Type)>): void
public "onBlockExploded"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, explosion: $Explosion$Type): void
public "getPistonPushReaction"(state: $BlockState$Type): $PushReaction
/**
 * 
 * @deprecated
 */
public "updateShape"(state: $BlockState$Type, facing: $Direction$Type, facingState: $BlockState$Type, world: $LevelAccessor$Type, currentPos: $BlockPos$Type, facingPos: $BlockPos$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "onRemove"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, newState: $BlockState$Type, isMoving: boolean): void
/**
 * 
 * @deprecated
 */
public "triggerEvent"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, id: integer, param: integer): boolean
/**
 * 
 * @deprecated
 */
public "onPlace"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, oldState: $BlockState$Type, isMoving: boolean): void
/**
 * 
 * @deprecated
 */
public "getFluidState"(state: $BlockState$Type): $FluidState
/**
 * 
 * @deprecated
 */
public "mirror"(state: $BlockState$Type, mirror: $Mirror$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "rotate"(state: $BlockState$Type, rotation: $Rotation$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "hasAnalogOutputSignal"(blockState: $BlockState$Type): boolean
/**
 * 
 * @deprecated
 */
public "getDrops"(state: $BlockState$Type, builder: $LootParams$Builder$Type): $List<($ItemStack)>
/**
 * 
 * @deprecated
 */
public "getAnalogOutputSignal"(blockState: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type): integer
/**
 * 
 * @deprecated
 */
public "getDestroyProgress"(state: $BlockState$Type, player: $Player$Type, world: $BlockGetter$Type, pos: $BlockPos$Type): float
public "getCloneItemStack"(state: $BlockState$Type, target: $HitResult$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, player: $Player$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockMekanism$Type = ($BlockMekanism);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockMekanism_ = $BlockMekanism$Type;
}}
declare module "packages/mekanism/common/inventory/container/$ISecurityContainer" {
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"

export interface $ISecurityContainer {

 "getSecurityObject"(): $ICapabilityProvider

(): $ICapabilityProvider
}

export namespace $ISecurityContainer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISecurityContainer$Type = ($ISecurityContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISecurityContainer_ = $ISecurityContainer$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$SingleItem" {
import {$ItemInputCache, $ItemInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$ItemInputCache"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$SingleInputRecipeCache, $SingleInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$SingleInputRecipeCache"
import {$MekanismRecipeType, $MekanismRecipeType$Type} from "packages/mekanism/common/recipe/$MekanismRecipeType"
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $InputRecipeCache$SingleItem<RECIPE extends ($MekanismRecipe) & ($Predicate<($ItemStack)>)> extends $SingleInputRecipeCache<($ItemStack), ($ItemStackIngredient), (RECIPE), ($ItemInputCache<(RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$Type<(RECIPE), (any)>, inputExtractor: $Function$Type<(RECIPE), ($ItemStackIngredient$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$SingleItem$Type<RECIPE> = ($InputRecipeCache$SingleItem<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$SingleItem_<RECIPE> = $InputRecipeCache$SingleItem$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/tile/component/config/$ConfigInfo" {
import {$DataType, $DataType$Type} from "packages/mekanism/common/tile/component/config/$DataType"
import {$ISlotInfo, $ISlotInfo$Type} from "packages/mekanism/common/tile/component/config/slot/$ISlotInfo"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$RelativeSide, $RelativeSide$Type} from "packages/mekanism/api/$RelativeSide"

export class $ConfigInfo {

constructor(facingSupplier: $Supplier$Type<($Direction$Type)>)

public "fill"(dataType: $DataType$Type): void
public "getAllOutputtingSides"(): $Set<($Direction)>
public "getDataType"(side: $RelativeSide$Type): $DataType
public "getSlotInfo"(side: $RelativeSide$Type): $ISlotInfo
public "getSlotInfo"(dataType: $DataType$Type): $ISlotInfo
public "isSideEnabled"(side: $RelativeSide$Type): boolean
public "setDataType"(dataType: $DataType$Type, ...sides: ($RelativeSide$Type)[]): void
public "addSlotInfo"(dataType: $DataType$Type, info: $ISlotInfo$Type): void
public "setCanEject"(canEject: boolean): void
public "setDefaults"(): void
public "getDataTypeForContainer"(container: any): $List<($DataType)>
public "getSupportedDataTypes"(): $Set<($DataType)>
public "decrementDataType"(relativeSide: $RelativeSide$Type): $DataType
public "incrementDataType"(relativeSide: $RelativeSide$Type): $DataType
public "addDisabledSides"(...sides: ($RelativeSide$Type)[]): void
public "setEjecting"(ejecting: boolean): void
public "getSides"(predicate: $Predicate$Type<($DataType$Type)>): $Set<($Direction)>
public "isEjecting"(): boolean
public "canEject"(): boolean
public "getSidesForOutput"(outputType: $DataType$Type): $Set<($Direction)>
public "getSidesForData"(dataType: $DataType$Type): $Set<($Direction)>
get "allOutputtingSides"(): $Set<($Direction)>
get "supportedDataTypes"(): $Set<($DataType)>
set "ejecting"(value: boolean)
get "ejecting"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigInfo$Type = ($ConfigInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigInfo_ = $ConfigInfo$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$SawmillRecipeSerializer$IFactory" {
import {$SawmillRecipe, $SawmillRecipe$Type} from "packages/mekanism/api/recipes/$SawmillRecipe"
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $SawmillRecipeSerializer$IFactory<RECIPE extends $SawmillRecipe> {

 "create"(id: $ResourceLocation$Type, input: $ItemStackIngredient$Type, mainOutput: $ItemStack$Type, secondaryOutput: $ItemStack$Type, secondaryChance: double): RECIPE

(id: $ResourceLocation$Type, input: $ItemStackIngredient$Type, mainOutput: $ItemStack$Type, secondaryOutput: $ItemStack$Type, secondaryChance: double): RECIPE
}

export namespace $SawmillRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SawmillRecipeSerializer$IFactory$Type<RECIPE> = ($SawmillRecipeSerializer$IFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SawmillRecipeSerializer$IFactory_<RECIPE> = $SawmillRecipeSerializer$IFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/tile/base/$TileEntityUpdateable" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Connection, $Connection$Type} from "packages/net/minecraft/network/$Connection"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$ITileWrapper, $ITileWrapper$Type} from "packages/mekanism/common/tile/interfaces/$ITileWrapper"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$Type} from "packages/net/minecraft/network/protocol/game/$ClientboundBlockEntityDataPacket"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"

export class $TileEntityUpdateable extends $BlockEntity implements $ITileWrapper {
 "blockState": $BlockState

constructor(type: $TileEntityTypeRegistryObject$Type<(any)>, pos: $BlockPos$Type, state: $BlockState$Type)

public "load"(nbt: $CompoundTag$Type): void
public "setLevel"(world: $Level$Type): void
public "getUpdateTag"(): $CompoundTag
public "onDataPacket"(net: $Connection$Type, pkt: $ClientboundBlockEntityDataPacket$Type): void
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "getTilePos"(): $BlockPos
public "isRemote"(): boolean
public "markForSave"(): void
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "markDirtyComparator"(): void
public "sendUpdatePacket"(tracking: $BlockEntity$Type): void
public "sendUpdatePacket"(): void
public "getTileWorld"(): $Level
public "handleUpdatePacket"(tag: $CompoundTag$Type): void
public "getTileCoord"(): $Coord4D
public "blockRemoved"(): void
public "getTileChunk"(): $Chunk3D
public "setChanged"(): void
public "getReducedUpdateTag"(): $CompoundTag
set "level"(value: $Level$Type)
get "updateTag"(): $CompoundTag
get "tilePos"(): $BlockPos
get "remote"(): boolean
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
get "reducedUpdateTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityUpdateable$Type = ($TileEntityUpdateable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityUpdateable_ = $TileEntityUpdateable$Type;
}}
declare module "packages/mekanism/common/item/interfaces/$IGasItem" {
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IGasItem {

 "hasGas"(stack: $ItemStack$Type): boolean
 "useGas"(stack: $ItemStack$Type, amount: long): $GasStack
}

export namespace $IGasItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGasItem$Type = ($IGasItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGasItem_ = $IGasItem$Type;
}}
declare module "packages/mekanism/common/tile/$TileEntityChargepad" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"

export class $TileEntityChargepad extends $TileEntityMekanism {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "setActive"(active: boolean): void
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
set "active"(value: boolean)
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityChargepad$Type = ($TileEntityChargepad);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityChargepad_ = $TileEntityChargepad$Type;
}}
declare module "packages/mekanism/common/upgrade/$ChemicalTankUpgradeData" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$MergedChemicalInventorySlot, $MergedChemicalInventorySlot$Type} from "packages/mekanism/common/inventory/slot/chemical/$MergedChemicalInventorySlot"
import {$ITileComponent, $ITileComponent$Type} from "packages/mekanism/common/tile/component/$ITileComponent"
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$TileEntityChemicalTank$GasMode, $TileEntityChemicalTank$GasMode$Type} from "packages/mekanism/common/tile/$TileEntityChemicalTank$GasMode"
import {$SlurryStack, $SlurryStack$Type} from "packages/mekanism/api/chemical/slurry/$SlurryStack"
import {$IRedstoneControl$RedstoneControl, $IRedstoneControl$RedstoneControl$Type} from "packages/mekanism/common/tile/interfaces/$IRedstoneControl$RedstoneControl"
import {$List, $List$Type} from "packages/java/util/$List"
import {$InfusionStack, $InfusionStack$Type} from "packages/mekanism/api/chemical/infuse/$InfusionStack"
import {$PigmentStack, $PigmentStack$Type} from "packages/mekanism/api/chemical/pigment/$PigmentStack"
import {$IUpgradeData, $IUpgradeData$Type} from "packages/mekanism/common/upgrade/$IUpgradeData"
import {$MergedChemicalTank, $MergedChemicalTank$Type} from "packages/mekanism/api/chemical/merged/$MergedChemicalTank"

export class $ChemicalTankUpgradeData implements $IUpgradeData {
readonly "redstone": boolean
readonly "controlType": $IRedstoneControl$RedstoneControl
readonly "drainSlot": $MergedChemicalInventorySlot<($MergedChemicalTank)>
readonly "fillSlot": $MergedChemicalInventorySlot<($MergedChemicalTank)>
readonly "dumping": $TileEntityChemicalTank$GasMode
readonly "storedGas": $GasStack
readonly "storedInfusion": $InfusionStack
readonly "storedPigment": $PigmentStack
readonly "storedSlurry": $SlurryStack
readonly "components": $CompoundTag

constructor(redstone: boolean, controlType: $IRedstoneControl$RedstoneControl$Type, drainSlot: $MergedChemicalInventorySlot$Type<($MergedChemicalTank$Type)>, fillSlot: $MergedChemicalInventorySlot$Type<($MergedChemicalTank$Type)>, dumping: $TileEntityChemicalTank$GasMode$Type, storedGas: $GasStack$Type, storedInfusion: $InfusionStack$Type, storedPigment: $PigmentStack$Type, storedSlurry: $SlurryStack$Type, components: $List$Type<($ITileComponent$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalTankUpgradeData$Type = ($ChemicalTankUpgradeData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalTankUpgradeData_ = $ChemicalTankUpgradeData$Type;
}}
declare module "packages/mekanism/common/block/transmitter/$BlockRestrictiveTransporter" {
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$IHasTileEntity, $IHasTileEntity$Type} from "packages/mekanism/common/block/interfaces/$IHasTileEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockLargeTransmitter, $BlockLargeTransmitter$Type} from "packages/mekanism/common/block/transmitter/$BlockLargeTransmitter"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$TileEntityRestrictiveTransporter, $TileEntityRestrictiveTransporter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityRestrictiveTransporter"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export class $BlockRestrictiveTransporter extends $BlockLargeTransmitter implements $IHasTileEntity<($TileEntityRestrictiveTransporter)> {
static readonly "CENTER": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor()

public "getTileType"(): $TileEntityTypeRegistryObject<($TileEntityRestrictiveTransporter)>
public "createDummyBlockEntity"(state: $BlockState$Type): $TileEntityRestrictiveTransporter
public "createDummyBlockEntity"(): $TileEntityRestrictiveTransporter
public "triggerBlockEntityEvent"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, id: integer, param: integer): boolean
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $TileEntityRestrictiveTransporter
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
get "tileType"(): $TileEntityTypeRegistryObject<($TileEntityRestrictiveTransporter)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRestrictiveTransporter$Type = ($BlockRestrictiveTransporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockRestrictiveTransporter_ = $BlockRestrictiveTransporter$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ChemicalDissolutionRecipeSerializer$IFactory" {
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$ChemicalStackIngredient$GasStackIngredient, $ChemicalStackIngredient$GasStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient$GasStackIngredient"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ChemicalDissolutionRecipe, $ChemicalDissolutionRecipe$Type} from "packages/mekanism/api/recipes/$ChemicalDissolutionRecipe"

export interface $ChemicalDissolutionRecipeSerializer$IFactory<RECIPE extends $ChemicalDissolutionRecipe> {

 "create"(id: $ResourceLocation$Type, itemInput: $ItemStackIngredient$Type, gasInput: $ChemicalStackIngredient$GasStackIngredient$Type, output: $ChemicalStack$Type<(any)>): RECIPE

(id: $ResourceLocation$Type, itemInput: $ItemStackIngredient$Type, gasInput: $ChemicalStackIngredient$GasStackIngredient$Type, output: $ChemicalStack$Type<(any)>): RECIPE
}

export namespace $ChemicalDissolutionRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalDissolutionRecipeSerializer$IFactory$Type<RECIPE> = ($ChemicalDissolutionRecipeSerializer$IFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalDissolutionRecipeSerializer$IFactory_<RECIPE> = $ChemicalDissolutionRecipeSerializer$IFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/capabilities/fluid/$VariableCapacityFluidTank" {
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$BasicFluidTank, $BasicFluidTank$Type} from "packages/mekanism/common/capabilities/fluid/$BasicFluidTank"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$MultiblockData, $MultiblockData$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockData"

export class $VariableCapacityFluidTank extends $BasicFluidTank {
static readonly "alwaysTrue": $Predicate<($FluidStack)>
static readonly "alwaysFalse": $Predicate<($FluidStack)>
static readonly "alwaysTrueBi": $BiPredicate<($FluidStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($FluidStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($FluidStack), ($AutomationType)>


public static "create"(capacity: $IntSupplier$Type, canExtract: $BiPredicate$Type<($FluidStack$Type), ($AutomationType$Type)>, canInsert: $BiPredicate$Type<($FluidStack$Type), ($AutomationType$Type)>, validator: $Predicate$Type<($FluidStack$Type)>, listener: $IContentsListener$Type): $VariableCapacityFluidTank
public static "create"(multiblock: $MultiblockData$Type, capacity: $IntSupplier$Type, validator: $Predicate$Type<($FluidStack$Type)>, listener: $IContentsListener$Type): $VariableCapacityFluidTank
public static "input"(capacity: $IntSupplier$Type, validator: $Predicate$Type<($FluidStack$Type)>, listener: $IContentsListener$Type): $VariableCapacityFluidTank
public static "input"(multiblock: $MultiblockData$Type, capacity: $IntSupplier$Type, validator: $Predicate$Type<($FluidStack$Type)>, listener: $IContentsListener$Type): $VariableCapacityFluidTank
public static "output"(capacity: $IntSupplier$Type, validator: $Predicate$Type<($FluidStack$Type)>, listener: $IContentsListener$Type): $VariableCapacityFluidTank
public static "output"(multiblock: $MultiblockData$Type, capacity: $IntSupplier$Type, validator: $Predicate$Type<($FluidStack$Type)>, listener: $IContentsListener$Type): $VariableCapacityFluidTank
public "getCapacity"(): integer
public "setStackSize"(amount: integer, action: $Action$Type): integer
get "capacity"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariableCapacityFluidTank$Type = ($VariableCapacityFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariableCapacityFluidTank_ = $VariableCapacityFluidTank$Type;
}}
declare module "packages/mekanism/common/lib/chunkloading/$IChunkLoader" {
import {$ChunkPos, $ChunkPos$Type} from "packages/net/minecraft/world/level/$ChunkPos"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TileComponentChunkLoader, $TileComponentChunkLoader$Type} from "packages/mekanism/common/tile/component/$TileComponentChunkLoader"

export interface $IChunkLoader {

 "getChunkSet"(): $Set<($ChunkPos)>
 "getChunkLoader"(): $TileComponentChunkLoader<(any)>
}

export namespace $IChunkLoader {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IChunkLoader$Type = ($IChunkLoader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IChunkLoader_ = $IChunkLoader$Type;
}}
declare module "packages/mekanism/common/inventory/container/type/$MekanismContainerType" {
import {$LecternMenu, $LecternMenu$Type} from "packages/net/minecraft/world/inventory/$LecternMenu"
import {$DispenserMenu, $DispenserMenu$Type} from "packages/net/minecraft/world/inventory/$DispenserMenu"
import {$BaseMekanismContainerType, $BaseMekanismContainerType$Type} from "packages/mekanism/common/inventory/container/type/$BaseMekanismContainerType"
import {$SmithingMenu, $SmithingMenu$Type} from "packages/net/minecraft/world/inventory/$SmithingMenu"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$IContainerFactory, $IContainerFactory$Type} from "packages/net/minecraftforge/network/$IContainerFactory"
import {$GrindstoneMenu, $GrindstoneMenu$Type} from "packages/net/minecraft/world/inventory/$GrindstoneMenu"
import {$LoomMenu, $LoomMenu$Type} from "packages/net/minecraft/world/inventory/$LoomMenu"
import {$MerchantMenu, $MerchantMenu$Type} from "packages/net/minecraft/world/inventory/$MerchantMenu"
import {$MenuConstructor, $MenuConstructor$Type} from "packages/net/minecraft/world/inventory/$MenuConstructor"
import {$BeaconMenu, $BeaconMenu$Type} from "packages/net/minecraft/world/inventory/$BeaconMenu"
import {$StonecutterMenu, $StonecutterMenu$Type} from "packages/net/minecraft/world/inventory/$StonecutterMenu"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$ChestMenu, $ChestMenu$Type} from "packages/net/minecraft/world/inventory/$ChestMenu"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$IEntityContainer, $IEntityContainer$Type} from "packages/mekanism/common/inventory/container/entity/$IEntityContainer"
import {$SmokerMenu, $SmokerMenu$Type} from "packages/net/minecraft/world/inventory/$SmokerMenu"
import {$FurnaceMenu, $FurnaceMenu$Type} from "packages/net/minecraft/world/inventory/$FurnaceMenu"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$AnvilMenu, $AnvilMenu$Type} from "packages/net/minecraft/world/inventory/$AnvilMenu"
import {$CraftingMenu, $CraftingMenu$Type} from "packages/net/minecraft/world/inventory/$CraftingMenu"
import {$MekanismContainerType$IMekanismContainerFactory, $MekanismContainerType$IMekanismContainerFactory$Type} from "packages/mekanism/common/inventory/container/type/$MekanismContainerType$IMekanismContainerFactory"
import {$CartographyTableMenu, $CartographyTableMenu$Type} from "packages/net/minecraft/world/inventory/$CartographyTableMenu"
import {$ShulkerBoxMenu, $ShulkerBoxMenu$Type} from "packages/net/minecraft/world/inventory/$ShulkerBoxMenu"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$EnchantmentMenu, $EnchantmentMenu$Type} from "packages/net/minecraft/world/inventory/$EnchantmentMenu"
import {$HopperMenu, $HopperMenu$Type} from "packages/net/minecraft/world/inventory/$HopperMenu"
import {$BrewingStandMenu, $BrewingStandMenu$Type} from "packages/net/minecraft/world/inventory/$BrewingStandMenu"
import {$MekanismContainerType$IMekanismSidedContainerFactory, $MekanismContainerType$IMekanismSidedContainerFactory$Type} from "packages/mekanism/common/inventory/container/type/$MekanismContainerType$IMekanismSidedContainerFactory"
import {$BlastFurnaceMenu, $BlastFurnaceMenu$Type} from "packages/net/minecraft/world/inventory/$BlastFurnaceMenu"

export class $MekanismContainerType<T, CONTAINER extends $AbstractContainerMenu> extends $BaseMekanismContainerType<(T), (CONTAINER), ($MekanismContainerType$IMekanismContainerFactory<(T), (CONTAINER)>)> {
static readonly "GENERIC_9x1": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x2": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x3": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x4": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x5": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x6": $MenuType<($ChestMenu)>
static readonly "GENERIC_3x3": $MenuType<($DispenserMenu)>
static readonly "ANVIL": $MenuType<($AnvilMenu)>
static readonly "BEACON": $MenuType<($BeaconMenu)>
static readonly "BLAST_FURNACE": $MenuType<($BlastFurnaceMenu)>
static readonly "BREWING_STAND": $MenuType<($BrewingStandMenu)>
static readonly "CRAFTING": $MenuType<($CraftingMenu)>
static readonly "ENCHANTMENT": $MenuType<($EnchantmentMenu)>
static readonly "FURNACE": $MenuType<($FurnaceMenu)>
static readonly "GRINDSTONE": $MenuType<($GrindstoneMenu)>
static readonly "HOPPER": $MenuType<($HopperMenu)>
static readonly "LECTERN": $MenuType<($LecternMenu)>
static readonly "LOOM": $MenuType<($LoomMenu)>
static readonly "MERCHANT": $MenuType<($MerchantMenu)>
static readonly "SHULKER_BOX": $MenuType<($ShulkerBoxMenu)>
static readonly "SMITHING": $MenuType<($SmithingMenu)>
static readonly "SMOKER": $MenuType<($SmokerMenu)>
static readonly "CARTOGRAPHY_TABLE": $MenuType<($CartographyTableMenu)>
static readonly "STONECUTTER": $MenuType<($StonecutterMenu)>


public "create"(id: integer, inv: $Inventory$Type, data: any): CONTAINER
public "create"(data: any): $MenuConstructor
public static "entity"<ENTITY extends $Entity, CONTAINER extends ($AbstractContainerMenu) & ($IEntityContainer<(ENTITY)>)>(type: $Class$Type<(ENTITY)>, arg1: $MekanismContainerType$IMekanismSidedContainerFactory$Type<(ENTITY), (CONTAINER)>): $MekanismContainerType<(ENTITY), (CONTAINER)>
public static "entity"<ENTITY extends $Entity, CONTAINER extends ($AbstractContainerMenu) & ($IEntityContainer<(ENTITY)>)>(type: $Class$Type<(ENTITY)>, arg1: $MekanismContainerType$IMekanismContainerFactory$Type<(ENTITY), (CONTAINER)>): $MekanismContainerType<(ENTITY), (CONTAINER)>
public static "tile"<TILE extends $TileEntityMekanism, CONTAINER extends $AbstractContainerMenu>(type: $Class$Type<(TILE)>, arg1: $MekanismContainerType$IMekanismContainerFactory$Type<(TILE), (CONTAINER)>): $MekanismContainerType<(TILE), (CONTAINER)>
public static "tile"<TILE extends $TileEntityMekanism, CONTAINER extends $AbstractContainerMenu>(type: $Class$Type<(TILE)>, arg1: $MekanismContainerType$IMekanismSidedContainerFactory$Type<(TILE), (CONTAINER)>): $MekanismContainerType<(TILE), (CONTAINER)>
public static "create"<T extends $AbstractContainerMenu>(arg0: $IContainerFactory$Type<(T)>): $MenuType<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismContainerType$Type<T, CONTAINER> = ($MekanismContainerType<(T), (CONTAINER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismContainerType_<T, CONTAINER> = $MekanismContainerType$Type<(T), (CONTAINER)>;
}}
declare module "packages/mekanism/common/integration/computer/$MethodData" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ComputerMethodFactory$ComputerFunctionCaller, $ComputerMethodFactory$ComputerFunctionCaller$Type} from "packages/mekanism/common/integration/computer/$ComputerMethodFactory$ComputerFunctionCaller"
import {$MethodData$Builder, $MethodData$Builder$Type} from "packages/mekanism/common/integration/computer/$MethodData$Builder"
import {$MethodRestriction, $MethodRestriction$Type} from "packages/mekanism/common/integration/computer/$MethodRestriction"

export class $MethodData<T> extends $Record {

constructor(name: string, restriction: $MethodRestriction$Type, requiredMods: (string)[], threadSafe: boolean, argumentNames: (string)[], argClasses: ($Class$Type<(any)>)[], returnType: $Class$Type<(any)>, returnExtra: ($Class$Type<(any)>)[], handler: $ComputerMethodFactory$ComputerFunctionCaller$Type<(T)>, methodDescription: string, requiresPublicSecurity: boolean)

public "returnType"(): $Class<(any)>
public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "builder"<T>(methodName: string, handler: $ComputerMethodFactory$ComputerFunctionCaller$Type<(T)>): $MethodData$Builder<(T)>
public "handler"(): $ComputerMethodFactory$ComputerFunctionCaller<(T)>
public "argClasses"(): ($Class<(any)>)[]
public "methodDescription"(): string
public "restriction"(): $MethodRestriction
public "requiresPublicSecurity"(): boolean
public "requiredMods"(): (string)[]
public "supports"(subject: T): boolean
public "threadSafe"(): boolean
public "argumentNames"(): (string)[]
public "returnExtra"(): ($Class<(any)>)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodData$Type<T> = ($MethodData<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodData_<T> = $MethodData$Type<(T)>;
}}
declare module "packages/mekanism/common/block/states/$TransmitterType" {
import {$TransmitterType$Size, $TransmitterType$Size$Type} from "packages/mekanism/common/block/states/$TransmitterType$Size"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $TransmitterType extends $Enum<($TransmitterType)> {
static readonly "UNIVERSAL_CABLE": $TransmitterType
static readonly "MECHANICAL_PIPE": $TransmitterType
static readonly "PRESSURIZED_TUBE": $TransmitterType
static readonly "LOGISTICAL_TRANSPORTER": $TransmitterType
static readonly "RESTRICTIVE_TRANSPORTER": $TransmitterType
static readonly "DIVERSION_TRANSPORTER": $TransmitterType
static readonly "THERMODYNAMIC_CONDUCTOR": $TransmitterType


public static "values"(): ($TransmitterType)[]
public static "valueOf"(name: string): $TransmitterType
public "getSize"(): $TransmitterType$Size
public static "byIndexStatic"(index: integer): $TransmitterType
get "size"(): $TransmitterType$Size
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransmitterType$Type = (("thermodynamic_conductor") | ("pressurized_tube") | ("mechanical_pipe") | ("logistical_transporter") | ("universal_cable") | ("diversion_transporter") | ("restrictive_transporter")) | ($TransmitterType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransmitterType_ = $TransmitterType$Type;
}}
declare module "packages/mekanism/common/content/qio/$QIOCraftingWindow" {
import {$IQIOCraftingWindowHolder, $IQIOCraftingWindowHolder$Type} from "packages/mekanism/common/content/qio/$IQIOCraftingWindowHolder"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CraftingWindowOutputInventorySlot, $CraftingWindowOutputInventorySlot$Type} from "packages/mekanism/common/inventory/slot/$CraftingWindowOutputInventorySlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingWindowInventorySlot, $CraftingWindowInventorySlot$Type} from "packages/mekanism/common/inventory/slot/$CraftingWindowInventorySlot"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$MainInventorySlot, $MainInventorySlot$Type} from "packages/mekanism/common/inventory/container/slot/$MainInventorySlot"
import {$SelectedWindowData, $SelectedWindowData$Type} from "packages/mekanism/common/inventory/container/$SelectedWindowData"
import {$HotBarSlot, $HotBarSlot$Type} from "packages/mekanism/common/inventory/container/slot/$HotBarSlot"

export class $QIOCraftingWindow implements $IContentsListener {

constructor(holder: $IQIOCraftingWindowHolder$Type, windowIndex: byte)

public "onContentsChanged"(): void
public "getOutputSlot"(): $CraftingWindowOutputInventorySlot
public "isOutput"(stack: $ItemStack$Type): boolean
public "canViewRecipe"(player: $ServerPlayer$Type): boolean
public "performCraft"(player: $Player$Type, hotBarSlots: $List$Type<($HotBarSlot$Type)>, mainInventorySlots: $List$Type<($MainInventorySlot$Type)>): void
public "performCraft"(player: $Player$Type, result: $ItemStack$Type, amountCrafted: integer): $ItemStack
public "getWindowIndex"(): byte
public "getWindowData"(): $SelectedWindowData
public "getInputSlot"(slot: integer): $CraftingWindowInventorySlot
public "invalidateRecipe"(): void
public "emptyTo"(toPlayerInv: boolean, hotBarSlots: $List$Type<($HotBarSlot$Type)>, mainInventorySlots: $List$Type<($MainInventorySlot$Type)>): void
get "outputSlot"(): $CraftingWindowOutputInventorySlot
get "windowIndex"(): byte
get "windowData"(): $SelectedWindowData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOCraftingWindow$Type = ($QIOCraftingWindow);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOCraftingWindow_ = $QIOCraftingWindow$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$ITileActive" {
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"

export interface $ITileActive {

 "setActive"(active: boolean): void
 "isActivatable"(): boolean
 "getActive"(): boolean
}

export namespace $ITileActive {
const NO_DELAY: $IntSupplier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileActive$Type = ($ITileActive);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileActive_ = $ITileActive$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemScubaTank" {
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemGasArmor, $ItemGasArmor$Type} from "packages/mekanism/common/item/gear/$ItemGasArmor"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$IModeItem, $IModeItem$Type} from "packages/mekanism/common/item/interfaces/$IModeItem"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$DispenseItemBehavior, $DispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DispenseItemBehavior"
import {$IItemHUDProvider, $IItemHUDProvider$Type} from "packages/mekanism/common/item/interfaces/$IItemHUDProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemScubaTank extends $ItemGasArmor implements $IItemHUDProvider, $IModeItem {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "initializeClient"(consumer: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "getDefaultTooltipHideFlags"(stack: $ItemStack$Type): integer
public "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "addHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): void
public "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
public "getFlowing"(stack: $ItemStack$Type): boolean
public "setFlowing"(stack: $ItemStack$Type, flowing: boolean): void
public "addCurioHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type): void
public static "displayModeChange"(player: $Player$Type): void
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
public "getScrollTextComponent"(stack: $ItemStack$Type): $Component
public static "get"(arg0: $ItemStack$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemScubaTank$Type = ($ItemScubaTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemScubaTank_ = $ItemScubaTank$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$ITileUpgradable" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IUpgradeTile, $IUpgradeTile$Type} from "packages/mekanism/common/tile/interfaces/$IUpgradeTile"
import {$Upgrade$IUpgradeInfoHandler, $Upgrade$IUpgradeInfoHandler$Type} from "packages/mekanism/api/$Upgrade$IUpgradeInfoHandler"
import {$Upgrade, $Upgrade$Type} from "packages/mekanism/api/$Upgrade"
import {$TileComponentUpgrade, $TileComponentUpgrade$Type} from "packages/mekanism/common/tile/component/$TileComponentUpgrade"

export interface $ITileUpgradable extends $IUpgradeTile, $Upgrade$IUpgradeInfoHandler {

 "getInfo"(upgrade: $Upgrade$Type): $List<($Component)>
 "getSupportedUpgrade"(): $Set<($Upgrade)>
 "recalculateUpgrades"(upgradeType: $Upgrade$Type): void
 "supportsUpgrades"(): boolean
 "supportsUpgrade"(upgradeType: $Upgrade$Type): boolean
 "getComponent"(): $TileComponentUpgrade
}

export namespace $ITileUpgradable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileUpgradable$Type = ($ITileUpgradable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileUpgradable_ = $ITileUpgradable$Type;
}}
declare module "packages/mekanism/common/lib/multiblock/$IStructuralMultiblock" {
import {$MultiblockManager, $MultiblockManager$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockManager"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Structure, $Structure$Type} from "packages/mekanism/common/lib/multiblock/$Structure"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MultiblockData, $MultiblockData$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockData"
import {$IMultiblockBase, $IMultiblockBase$Type} from "packages/mekanism/common/lib/multiblock/$IMultiblockBase"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IStructuralMultiblock extends $IMultiblockBase {

 "getStructureMap"(): $Map<($MultiblockManager<(any)>), ($Structure)>
 "structuralGuiAccessAllowed"(): boolean
 "hasFormedMultiblock"(): boolean
 "canInterface"(manager: $MultiblockManager$Type<(any)>): boolean
 "onActivate"(player: $Player$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type): $InteractionResult
 "getStructure"(manager: $MultiblockManager$Type<(any)>): $Structure
 "setStructure"(manager: $MultiblockManager$Type<(any)>, structure: $Structure$Type): void
 "getDefaultData"(): $MultiblockData
 "resetForFormed"(): void
 "hasStructure"(structure: $Structure$Type): boolean
 "getMultiblockData"(manager: $MultiblockManager$Type<(any)>): $MultiblockData
 "resetStructure"(manager: $MultiblockManager$Type<(any)>): $Structure
 "setMultiblockData"(manager: $MultiblockManager$Type<(any)>, multiblockData: $MultiblockData$Type): void
 "getTilePos"(): $BlockPos
 "getTileWorld"(): $Level
 "getTileCoord"(): $Coord4D
 "getTileChunk"(): $Chunk3D
}

export namespace $IStructuralMultiblock {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IStructuralMultiblock$Type = ($IStructuralMultiblock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IStructuralMultiblock_ = $IStructuralMultiblock$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ItemStackGasToItemStackRecipeSerializer" {
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$ItemStackGasToItemStackRecipe, $ItemStackGasToItemStackRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackGasToItemStackRecipe"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$ItemStackChemicalToItemStackRecipeSerializer, $ItemStackChemicalToItemStackRecipeSerializer$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackChemicalToItemStackRecipeSerializer"
import {$Gas, $Gas$Type} from "packages/mekanism/api/chemical/gas/$Gas"
import {$ChemicalStackIngredient$GasStackIngredient, $ChemicalStackIngredient$GasStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient$GasStackIngredient"
import {$ItemStackChemicalToItemStackRecipeSerializer$IFactory, $ItemStackChemicalToItemStackRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackChemicalToItemStackRecipeSerializer$IFactory"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ItemStackGasToItemStackRecipeSerializer<RECIPE extends $ItemStackGasToItemStackRecipe> extends $ItemStackChemicalToItemStackRecipeSerializer<($Gas), ($GasStack), ($ChemicalStackIngredient$GasStackIngredient), (RECIPE)> {

constructor(factory: $ItemStackChemicalToItemStackRecipeSerializer$IFactory$Type<($Gas$Type), ($GasStack$Type), ($ChemicalStackIngredient$GasStackIngredient$Type), (RECIPE)>)

public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackGasToItemStackRecipeSerializer$Type<RECIPE> = ($ItemStackGasToItemStackRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackGasToItemStackRecipeSerializer_<RECIPE> = $ItemStackGasToItemStackRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/recipe/serializer/$ItemStackToItemStackRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$ItemStackToItemStackRecipeSerializer$IFactory, $ItemStackToItemStackRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackToItemStackRecipeSerializer$IFactory"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ItemStackToItemStackRecipe, $ItemStackToItemStackRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackToItemStackRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ItemStackToItemStackRecipeSerializer<RECIPE extends $ItemStackToItemStackRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(factory: $ItemStackToItemStackRecipeSerializer$IFactory$Type<(RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackToItemStackRecipeSerializer$Type<RECIPE> = ($ItemStackToItemStackRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackToItemStackRecipeSerializer_<RECIPE> = $ItemStackToItemStackRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/item/block/$ItemBlockBin" {
import {$BinTier, $BinTier$Type} from "packages/mekanism/common/tier/$BinTier"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ListTag, $ListTag$Type} from "packages/net/minecraft/nbt/$ListTag"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemBlockTooltip, $ItemBlockTooltip$Type} from "packages/mekanism/common/item/block/$ItemBlockTooltip"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockBin, $BlockBin$Type} from "packages/mekanism/common/block/basic/$BlockBin"
import {$IItemSustainedInventory, $IItemSustainedInventory$Type} from "packages/mekanism/common/item/interfaces/$IItemSustainedInventory"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockBin extends $ItemBlockTooltip<($BlockBin)> implements $IItemSustainedInventory {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockBin$Type)

public "getTier"(): $BinTier
public "canContentsDrop"(stack: $ItemStack$Type): boolean
public "getSustainedInventory"(stack: $ItemStack$Type): $ListTag
public "getSustainedInventory"(): $ListTag
public "setSustainedInventory"(nbtTags: $ListTag$Type): void
public "setSustainedInventory"(nbtTags: $ListTag$Type, stack: $ItemStack$Type): void
public "getDroppedSlots"(stack: $ItemStack$Type): $List<($IInventorySlot)>
public "hasSustainedInventory"(stack: $ItemStack$Type): boolean
public "hasSustainedInventory"(): boolean
get "tier"(): $BinTier
get "sustainedInventory"(): $ListTag
set "sustainedInventory"(value: $ListTag$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockBin$Type = ($ItemBlockBin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockBin_ = $ItemBlockBin$Type;
}}
declare module "packages/mekanism/common/capabilities/chemical/dynamic/$IPigmentTracker" {
import {$IPigmentTank, $IPigmentTank$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentTank"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"

export interface $IPigmentTracker extends $IContentsListener {

 "getPigmentTanks"(side: $Direction$Type): $List<($IPigmentTank)>
 "onContentsChanged"(): void
}

export namespace $IPigmentTracker {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IPigmentTracker$Type = ($IPigmentTracker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IPigmentTracker_ = $IPigmentTracker$Type;
}}
declare module "packages/mekanism/common/world/$OreRetrogenFeature" {
import {$BonusChestFeature, $BonusChestFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$BonusChestFeature"
import {$RandomFeatureConfiguration, $RandomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomFeatureConfiguration"
import {$SpikeConfiguration, $SpikeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SpikeConfiguration"
import {$LakeFeature$Configuration, $LakeFeature$Configuration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$LakeFeature$Configuration"
import {$BlockColumnConfiguration, $BlockColumnConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockColumnConfiguration"
import {$MultifaceGrowthConfiguration, $MultifaceGrowthConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$MultifaceGrowthConfiguration"
import {$RootSystemConfiguration, $RootSystemConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RootSystemConfiguration"
import {$UnderwaterMagmaConfiguration, $UnderwaterMagmaConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$UnderwaterMagmaConfiguration"
import {$RandomPatchConfiguration, $RandomPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomPatchConfiguration"
import {$ProbabilityFeatureConfiguration, $ProbabilityFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ProbabilityFeatureConfiguration"
import {$TreeConfiguration, $TreeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$TreeConfiguration"
import {$ResizableOreFeature, $ResizableOreFeature$Type} from "packages/mekanism/common/world/$ResizableOreFeature"
import {$TwistingVinesConfig, $TwistingVinesConfig$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$TwistingVinesConfig"
import {$DripstoneClusterConfiguration, $DripstoneClusterConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DripstoneClusterConfiguration"
import {$LayerConfiguration, $LayerConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$LayerConfiguration"
import {$HugeMushroomFeatureConfiguration, $HugeMushroomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$HugeMushroomFeatureConfiguration"
import {$ReplaceBlockConfiguration, $ReplaceBlockConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ReplaceBlockConfiguration"
import {$BlockStateConfiguration, $BlockStateConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockStateConfiguration"
import {$SimpleBlockConfiguration, $SimpleBlockConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SimpleBlockConfiguration"
import {$HugeFungusConfiguration, $HugeFungusConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$HugeFungusConfiguration"
import {$DiskConfiguration, $DiskConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DiskConfiguration"
import {$SeagrassFeature, $SeagrassFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$SeagrassFeature"
import {$ReplaceSphereConfiguration, $ReplaceSphereConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ReplaceSphereConfiguration"
import {$FossilFeatureConfiguration, $FossilFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$FossilFeatureConfiguration"
import {$DeltaFeatureConfiguration, $DeltaFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DeltaFeatureConfiguration"
import {$PointedDripstoneConfiguration, $PointedDripstoneConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$PointedDripstoneConfiguration"
import {$SpringConfiguration, $SpringConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SpringConfiguration"
import {$BlockPileConfiguration, $BlockPileConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockPileConfiguration"
import {$OreConfiguration, $OreConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration"
import {$SimpleRandomFeatureConfiguration, $SimpleRandomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SimpleRandomFeatureConfiguration"
import {$SculkPatchConfiguration, $SculkPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SculkPatchConfiguration"
import {$NetherForestVegetationConfig, $NetherForestVegetationConfig$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$NetherForestVegetationConfig"
import {$GeodeConfiguration, $GeodeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$GeodeConfiguration"
import {$LargeDripstoneConfiguration, $LargeDripstoneConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$LargeDripstoneConfiguration"
import {$RandomBooleanFeatureConfiguration, $RandomBooleanFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomBooleanFeatureConfiguration"
import {$ColumnFeatureConfiguration, $ColumnFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ColumnFeatureConfiguration"
import {$CountConfiguration, $CountConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$CountConfiguration"
import {$VegetationPatchConfiguration, $VegetationPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$VegetationPatchConfiguration"
import {$Feature, $Feature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$Feature"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$NoneFeatureConfiguration"
import {$EndGatewayConfiguration, $EndGatewayConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$EndGatewayConfiguration"

export class $OreRetrogenFeature extends $ResizableOreFeature {
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreRetrogenFeature$Type = ($OreRetrogenFeature);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OreRetrogenFeature_ = $OreRetrogenFeature$Type;
}}
declare module "packages/mekanism/common/lib/math/voxel/$VoxelCuboid" {
import {$IShape, $IShape$Type} from "packages/mekanism/common/lib/math/voxel/$IShape"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$VoxelPlane, $VoxelPlane$Type} from "packages/mekanism/common/lib/math/voxel/$VoxelPlane"
import {$VoxelCuboid$CuboidRelative, $VoxelCuboid$CuboidRelative$Type} from "packages/mekanism/common/lib/math/voxel/$VoxelCuboid$CuboidRelative"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$VoxelCuboid$WallRelative, $VoxelCuboid$WallRelative$Type} from "packages/mekanism/common/lib/math/voxel/$VoxelCuboid$WallRelative"

export class $VoxelCuboid implements $IShape {

constructor(minPos: $BlockPos$Type, maxPos: $BlockPos$Type)
constructor(length: integer, height: integer, width: integer)

public "equals"(obj: any): boolean
public "length"(): integer
public "toString"(): string
public "hashCode"(): integer
public static "from"(p1: $VoxelPlane$Type, p2: $VoxelPlane$Type, p1Pos: integer, p2Pos: integer): $VoxelCuboid
public "height"(): integer
public "width"(): integer
public "getSide"(pos: $BlockPos$Type): $Direction
public "greaterOrEqual"(other: $VoxelCuboid$Type): boolean
public "getRelativeLocation"(pos: $BlockPos$Type): $VoxelCuboid$CuboidRelative
public "setMaxPos"(maxPos: $BlockPos$Type): void
public "setMinPos"(minPos: $BlockPos$Type): void
public "getMaxPos"(): $BlockPos
public "getMatches"(pos: $BlockPos$Type): integer
public "getMinPos"(): $BlockPos
public "getWallRelative"(pos: $BlockPos$Type): $VoxelCuboid$WallRelative
public "isOnEdge"(pos: $BlockPos$Type): boolean
public "isOnCorner"(pos: $BlockPos$Type): boolean
public "getCenter"(): $BlockPos
public "isOnSide"(pos: $BlockPos$Type): boolean
set "maxPos"(value: $BlockPos$Type)
set "minPos"(value: $BlockPos$Type)
get "maxPos"(): $BlockPos
get "minPos"(): $BlockPos
get "center"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VoxelCuboid$Type = ($VoxelCuboid);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VoxelCuboid_ = $VoxelCuboid$Type;
}}
declare module "packages/mekanism/common/resource/ore/$OreAnchor" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$AnchorType, $AnchorType$Type} from "packages/mekanism/common/world/height/$AnchorType"

export class $OreAnchor extends $Record {

constructor(type: $AnchorType$Type, value: integer)

public "type"(): $AnchorType
public "value"(): integer
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "absolute"(value: integer): $OreAnchor
public static "belowTop"(value: integer): $OreAnchor
public static "aboveBottom"(value: integer): $OreAnchor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreAnchor$Type = ($OreAnchor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OreAnchor_ = $OreAnchor$Type;
}}
declare module "packages/mekanism/common/item/$ItemPortableTeleporter" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$Type} from "packages/mekanism/common/lib/frequency/$Frequency$FrequencyIdentity"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ContainerTypeRegistryObject, $ContainerTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$ContainerTypeRegistryObject"
import {$IGuiItem, $IGuiItem$Type} from "packages/mekanism/common/item/interfaces/$IGuiItem"
import {$ItemEnergized, $ItemEnergized$Type} from "packages/mekanism/common/item/$ItemEnergized"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IFrequencyItem, $IFrequencyItem$Type} from "packages/mekanism/common/lib/frequency/$IFrequencyItem"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$FrequencyType, $FrequencyType$Type} from "packages/mekanism/common/lib/frequency/$FrequencyType"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemPortableTeleporter extends $ItemEnergized implements $IFrequencyItem, $IGuiItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "getFrequencyType"(): $FrequencyType<(any)>
public "getContainerType"(): $ContainerTypeRegistryObject<(any)>
public "getFrequency"(stack: $ItemStack$Type): $Frequency
public "setFrequency"(stack: $ItemStack$Type, frequency: $Frequency$Type): void
public "getFrequencyIdentity"(stack: $ItemStack$Type): $Frequency$FrequencyIdentity
public "hasFrequency"(stack: $ItemStack$Type): boolean
get "frequencyType"(): $FrequencyType<(any)>
get "containerType"(): $ContainerTypeRegistryObject<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPortableTeleporter$Type = ($ItemPortableTeleporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPortableTeleporter_ = $ItemPortableTeleporter$Type;
}}
declare module "packages/mekanism/common/tier/$TransporterTier" {
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"
import {$CachedIntValue, $CachedIntValue$Type} from "packages/mekanism/common/config/value/$CachedIntValue"

export class $TransporterTier extends $Enum<($TransporterTier)> implements $ITier {
static readonly "BASIC": $TransporterTier
static readonly "ADVANCED": $TransporterTier
static readonly "ELITE": $TransporterTier
static readonly "ULTIMATE": $TransporterTier


public static "get"(tier: $BaseTier$Type): $TransporterTier
public static "values"(): ($TransporterTier)[]
public static "valueOf"(name: string): $TransporterTier
public "getSpeed"(): integer
public "getBaseTier"(): $BaseTier
public "setConfigReference"(pullReference: $CachedIntValue$Type, speedReference: $CachedIntValue$Type): void
public "getBaseSpeed"(): integer
public "getBasePull"(): integer
public "getPullAmount"(): integer
get "speed"(): integer
get "baseTier"(): $BaseTier
get "baseSpeed"(): integer
get "basePull"(): integer
get "pullAmount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransporterTier$Type = (("elite") | ("advanced") | ("ultimate") | ("basic")) | ($TransporterTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransporterTier_ = $TransporterTier$Type;
}}
declare module "packages/mekanism/common/content/qio/$QIOFrequency$QIOItemTypeData" {
import {$HashedItem, $HashedItem$Type} from "packages/mekanism/common/lib/inventory/$HashedItem"
import {$QIOFrequency, $QIOFrequency$Type} from "packages/mekanism/common/content/qio/$QIOFrequency"

export class $QIOFrequency$QIOItemTypeData {

constructor(this$0: $QIOFrequency$Type, itemType: $HashedItem$Type)

public "getCount"(): long
get "count"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOFrequency$QIOItemTypeData$Type = ($QIOFrequency$QIOItemTypeData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOFrequency$QIOItemTypeData_ = $QIOFrequency$QIOItemTypeData$Type;
}}
declare module "packages/mekanism/common/lib/multiblock/$MultiblockData" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$IMekanismInventory, $IMekanismInventory$Type} from "packages/mekanism/api/inventory/$IMekanismInventory"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$IGasTracker, $IGasTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IGasTracker"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$IEnergyContainer, $IEnergyContainer$Type} from "packages/mekanism/api/energy/$IEnergyContainer"
import {$IPigmentTank, $IPigmentTank$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentTank"
import {$IPigmentTracker, $IPigmentTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IPigmentTracker"
import {$VoxelCuboid, $VoxelCuboid$Type} from "packages/mekanism/common/lib/math/voxel/$VoxelCuboid"
import {$IHeatCapacitor, $IHeatCapacitor$Type} from "packages/mekanism/api/heat/$IHeatCapacitor"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMekanismFluidHandler, $IMekanismFluidHandler$Type} from "packages/mekanism/api/fluid/$IMekanismFluidHandler"
import {$IHeatHandler, $IHeatHandler$Type} from "packages/mekanism/api/heat/$IHeatHandler"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IInfusionTank, $IInfusionTank$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionTank"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$IExtendedFluidTank, $IExtendedFluidTank$Type} from "packages/mekanism/api/fluid/$IExtendedFluidTank"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IShape, $IShape$Type} from "packages/mekanism/common/lib/math/voxel/$IShape"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$HeatAPI$HeatTransfer, $HeatAPI$HeatTransfer$Type} from "packages/mekanism/api/heat/$HeatAPI$HeatTransfer"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Structure, $Structure$Type} from "packages/mekanism/common/lib/multiblock/$Structure"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$ISlurryTank, $ISlurryTank$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryTank"
import {$IMekanismStrictEnergyHandler, $IMekanismStrictEnergyHandler$Type} from "packages/mekanism/api/energy/$IMekanismStrictEnergyHandler"
import {$IValveHandler$ValveData, $IValveHandler$ValveData$Type} from "packages/mekanism/common/lib/multiblock/$IValveHandler$ValveData"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ISlurryTracker, $ISlurryTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$ISlurryTracker"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$ITileHeatHandler, $ITileHeatHandler$Type} from "packages/mekanism/common/capabilities/heat/$ITileHeatHandler"
import {$IInfusionTracker, $IInfusionTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IInfusionTracker"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"

export class $MultiblockData implements $IMekanismInventory, $IMekanismFluidHandler, $IMekanismStrictEnergyHandler, $ITileHeatHandler, $IGasTracker, $IInfusionTracker, $IPigmentTracker, $ISlurryTracker {
 "locations": $Set<($BlockPos)>
 "internalLocations": $Set<($BlockPos)>
 "valves": $Set<($IValveHandler$ValveData)>
 "inventoryID": $UUID
 "hasMaster": boolean
 "renderLocation": $BlockPos
 "recheckStructure": boolean

constructor(tile: $BlockEntity$Type)

public "remove"(world: $Level$Type): void
public "equals"(obj: any): boolean
public "length"(): integer
public "hashCode"(): integer
public "getBounds"(): $VoxelCuboid
public "height"(): integer
public "isDirty"(): boolean
public "width"(): integer
public "markDirty"(): void
public "onContentsChanged"(): void
public "tick"(world: $Level$Type): boolean
public "isFormed"(): boolean
public "setShape"(shape: $IShape$Type): boolean
public "getEnergyContainers"(side: $Direction$Type): $List<($IEnergyContainer)>
public "isPositionInsideBounds"<T extends $MultiblockData>(structure: $Structure$Type, pos: $BlockPos$Type): boolean
public "getCurrentRedstoneLevel"(): integer
public "notExternalFormedBiPred"<T>(): $BiPredicate<(T), ($AutomationType)>
public "getDirectionsToEmit"(pos: $BlockPos$Type): $Set<($Direction)>
public "notifyAllUpdateComparator"(world: $Level$Type): void
public "markDirtyComparator"(world: $Level$Type): void
public "isPositionOutsideBounds"(pos: $BlockPos$Type): boolean
public "forceUpdateComparatorLevel"(): void
public "getMaxPos"(): $BlockPos
public "resetDirty"(): void
public "getInventorySlots"(side: $Direction$Type): $List<($IInventorySlot)>
public "getFluidTanks"(side: $Direction$Type): $List<($IExtendedFluidTank)>
public "getInfusionTanks"(side: $Direction$Type): $List<($IInfusionTank)>
public "getPigmentTanks"(side: $Direction$Type): $List<($IPigmentTank)>
public "getGasTanks"(side: $Direction$Type): $List<($IGasTank)>
public "getHeatCapacitors"(side: $Direction$Type): $List<($IHeatCapacitor)>
public "getSlurryTanks"(side: $Direction$Type): $List<($ISlurryTank)>
public "formedBiPred"<T>(): $BiPredicate<(T), ($AutomationType)>
public "getVolume"(): integer
public "setVolume"(volume: integer): void
public "onCreated"(world: $Level$Type): void
public "getMinPos"(): $BlockPos
public "meltdownHappened"(world: $Level$Type): void
public "writeUpdateTag"(tag: $CompoundTag$Type): void
public "readUpdateTag"(tag: $CompoundTag$Type): void
public "setFormedForce"(formed: boolean): void
public "getOutsideSide"(pos: $BlockPos$Type): $Direction
public "getValveData"(): $Collection<($IValveHandler$ValveData)>
public "isKnownLocation"(pos: $BlockPos$Type): boolean
public "getSlots"(arg0: $Direction$Type): integer
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: $Direction$Type, arg3: $Action$Type): $ItemStack
public "getStackInSlot"(arg0: integer, arg1: $Direction$Type): $ItemStack
public "getSlotLimit"(arg0: integer, arg1: $Direction$Type): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type, arg2: $Direction$Type): boolean
public "extractItem"(arg0: integer, arg1: integer, arg2: $Direction$Type, arg3: $Action$Type): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type, arg2: $Direction$Type): void
public "getInventorySlot"(arg0: integer, arg1: $Direction$Type): $IInventorySlot
public "hasInventory"(): boolean
public "isInventoryEmpty"(arg0: $Direction$Type): boolean
public "isInventoryEmpty"(): boolean
public "getTanks"(arg0: $Direction$Type): integer
public "getTankCapacity"(arg0: integer, arg1: $Direction$Type): integer
public "getFluidInTank"(arg0: integer, arg1: $Direction$Type): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type): boolean
public "getFluidTank"(arg0: integer, arg1: $Direction$Type): $IExtendedFluidTank
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type): void
public "insertFluid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type, arg3: $Action$Type): $FluidStack
public "canHandleFluid"(): boolean
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Direction$Type, arg3: $Action$Type): $FluidStack
public "getEnergyContainer"(arg0: integer, arg1: $Direction$Type): $IEnergyContainer
public "getEnergyContainerCount"(arg0: $Direction$Type): integer
public "extractEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type, arg3: $Action$Type): $FloatingLong
public "getEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "setEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type): void
public "canHandleEnergy"(): boolean
public "getMaxEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "getNeededEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "insertEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type, arg3: $Action$Type): $FloatingLong
public "simulate"(): $HeatAPI$HeatTransfer
public "getAmbientTemperature"(side: $Direction$Type): double
public "simulateEnvironment"(): double
public "updateHeatCapacitors"(side: $Direction$Type): void
public "incrementAdjacentTransfer"(currentAdjacentTransfer: double, tempToTransfer: double, side: $Direction$Type): double
public "getAdjacent"(side: $Direction$Type): $IHeatHandler
public "simulateAdjacent"(): double
public "getSlots"(): integer
public "getInventorySideFor"(): $Direction
public "insertItem"(arg0: integer, arg1: $ItemStack$Type, arg2: boolean): $ItemStack
public "getStackInSlot"(arg0: integer): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$Type): boolean
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$Type): void
public "getTanks"(): integer
public "getTankCapacity"(arg0: integer): integer
public "getFluidInTank"(arg0: integer): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$Type): void
public "insertFluid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Action$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$Type, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "getFluidSideFor"(): $Direction
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Action$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$Type, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "getEnergyContainerCount"(): integer
public "extractEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Action$Type): $FloatingLong
public "extractEnergy"(arg0: $FloatingLong$Type, arg1: $Direction$Type, arg2: $Action$Type): $FloatingLong
public "getEnergy"(arg0: integer): $FloatingLong
public "setEnergy"(arg0: integer, arg1: $FloatingLong$Type): void
public "getMaxEnergy"(arg0: integer): $FloatingLong
public "getNeededEnergy"(arg0: integer): $FloatingLong
public "insertEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Action$Type): $FloatingLong
public "insertEnergy"(arg0: $FloatingLong$Type, arg1: $Direction$Type, arg2: $Action$Type): $FloatingLong
public "getEnergySideFor"(): $Direction
public "canHandleHeat"(): boolean
public "getHeatCapacity"(arg0: integer, arg1: $Direction$Type): double
public "getHeatCapacitor"(arg0: integer, arg1: $Direction$Type): $IHeatCapacitor
public "handleHeat"(arg0: integer, arg1: double, arg2: $Direction$Type): void
public "getTemperature"(arg0: integer, arg1: $Direction$Type): double
public "getHeatCapacitorCount"(arg0: $Direction$Type): integer
public "getTotalInverseInsulation"(arg0: $Direction$Type): double
public "getInverseConduction"(arg0: integer, arg1: $Direction$Type): double
public "getInverseInsulation"(arg0: integer, arg1: $Direction$Type): double
/**
 * 
 * @deprecated
 */
public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
/**
 * 
 * @deprecated
 */
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$Type, arg1: $Action$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Action$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$Type, arg1: $Action$Type): $FluidStack
public "extractEnergy"(arg0: $FloatingLong$Type, arg1: $Action$Type): $FloatingLong
public "insertEnergy"(arg0: $FloatingLong$Type, arg1: $Action$Type): $FloatingLong
public "getHeatCapacity"(arg0: integer): double
public "handleHeat"(arg0: double, arg1: $Direction$Type): void
public "handleHeat"(arg0: integer, arg1: double): void
public "getHeatSideFor"(): $Direction
public "getTotalInverseConductionCoefficient"(arg0: $Direction$Type): double
public "getTemperature"(arg0: integer): double
public "getTotalHeatCapacity"(arg0: $Direction$Type): double
public "getHeatCapacitorCount"(): integer
public "getInverseConduction"(arg0: integer): double
public "getTotalTemperature"(arg0: $Direction$Type): double
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "isMutable"(): boolean
public "getSlots"(): integer
public "getStackInSlot"(i: integer): $ItemStack
public "extractItem"(i: integer, i1: integer, b: boolean): $ItemStack
public "insertItem"(i: integer, itemStack: $ItemStack$Type, b: boolean): $ItemStack
public "getSlotLimit"(i: integer): integer
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "isItemValid"(i: integer, itemStack: $ItemStack$Type): boolean
public "kjs$self"(): $IItemHandler
public "handleHeat"(arg0: double): void
public "getTotalHeatCapacity"(): double
public "getTotalInverseConduction"(): double
public "getTotalTemperature"(): double
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "asContainer"(): $Container
public "getWidth"(): integer
public "find"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "clear"(ingredient: $Ingredient$Type): void
public "clear"(): void
public "setChanged"(): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "getHeight"(): integer
get "bounds"(): $VoxelCuboid
get "dirty"(): boolean
get "formed"(): boolean
set "shape"(value: $IShape$Type)
get "currentRedstoneLevel"(): integer
get "maxPos"(): $BlockPos
get "volume"(): integer
set "volume"(value: integer)
get "minPos"(): $BlockPos
set "formedForce"(value: boolean)
get "valveData"(): $Collection<($IValveHandler$ValveData)>
get "inventoryEmpty"(): boolean
get "slots"(): integer
get "inventorySideFor"(): $Direction
get "tanks"(): integer
get "fluidSideFor"(): $Direction
get "energyContainerCount"(): integer
get "energySideFor"(): $Direction
get "heatSideFor"(): $Direction
get "heatCapacitorCount"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "totalHeatCapacity"(): double
get "totalInverseConduction"(): double
get "totalTemperature"(): double
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockData$Type = ($MultiblockData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockData_ = $MultiblockData$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/chemical/$IGasTile" {
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$Gas, $Gas$Type} from "packages/mekanism/api/chemical/gas/$Gas"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ChemicalHandlerManager$GasHandlerManager, $ChemicalHandlerManager$GasHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager$GasHandlerManager"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$IChemicalTankHolder, $IChemicalTankHolder$Type} from "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder"
import {$IGasTracker, $IGasTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IGasTracker"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export interface $IGasTile extends $IGasTracker {

 "getInitialGasManager"(listener: $IContentsListener$Type): $ChemicalHandlerManager$GasHandlerManager
 "getInitialGasTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($Gas), ($GasStack), ($IGasTank)>
 "extractGasCheck"(tank: integer, side: $Direction$Type): boolean
 "insertGasCheck"(tank: integer, side: $Direction$Type): boolean
 "getGasManager"(): $ChemicalHandlerManager$GasHandlerManager
 "getGasTanks"(side: $Direction$Type): $List<($IGasTank)>
 "canHandleGas"(): boolean
 "onContentsChanged"(): void
}

export namespace $IGasTile {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGasTile$Type = ($IGasTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGasTile_ = $IGasTile$Type;
}}
declare module "packages/mekanism/common/capabilities/energy/$VariableCapacityEnergyContainer" {
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$FloatingLongSupplier, $FloatingLongSupplier$Type} from "packages/mekanism/api/math/$FloatingLongSupplier"
import {$BasicEnergyContainer, $BasicEnergyContainer$Type} from "packages/mekanism/common/capabilities/energy/$BasicEnergyContainer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"

export class $VariableCapacityEnergyContainer extends $BasicEnergyContainer {
static readonly "alwaysTrue": $Predicate<($AutomationType)>
static readonly "alwaysFalse": $Predicate<($AutomationType)>
static readonly "internalOnly": $Predicate<($AutomationType)>
static readonly "manualOnly": $Predicate<($AutomationType)>
static readonly "notExternal": $Predicate<($AutomationType)>


public static "create"(maxEnergy: $FloatingLongSupplier$Type, canExtract: $Predicate$Type<($AutomationType$Type)>, canInsert: $Predicate$Type<($AutomationType$Type)>, listener: $IContentsListener$Type): $VariableCapacityEnergyContainer
public static "input"(maxEnergy: $FloatingLongSupplier$Type, listener: $IContentsListener$Type): $VariableCapacityEnergyContainer
public static "output"(maxEnergy: $FloatingLongSupplier$Type, listener: $IContentsListener$Type): $VariableCapacityEnergyContainer
public "getMaxEnergy"(): $FloatingLong
get "maxEnergy"(): $FloatingLong
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariableCapacityEnergyContainer$Type = ($VariableCapacityEnergyContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariableCapacityEnergyContainer_ = $VariableCapacityEnergyContainer$Type;
}}
declare module "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$WrappedRegistryObject, $WrappedRegistryObject$Type} from "packages/mekanism/common/registration/$WrappedRegistryObject"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"

export class $TileEntityTypeRegistryObject<BE extends $BlockEntity> extends $WrappedRegistryObject<($BlockEntityType<(BE)>)> {

constructor(registryObject: $RegistryObject$Type<($BlockEntityType$Type<(BE)>)>)

public "getTicker"(isClient: boolean): $BlockEntityTicker<(BE)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityTypeRegistryObject$Type<BE> = ($TileEntityTypeRegistryObject<(BE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityTypeRegistryObject_<BE> = $TileEntityTypeRegistryObject$Type<(BE)>;
}}
declare module "packages/mekanism/common/tier/$QIODriveTier" {
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"

export class $QIODriveTier extends $Enum<($QIODriveTier)> implements $ITier {
static readonly "BASE": $QIODriveTier
static readonly "HYPER_DENSE": $QIODriveTier
static readonly "TIME_DILATING": $QIODriveTier
static readonly "SUPERMASSIVE": $QIODriveTier


public static "values"(): ($QIODriveTier)[]
public static "valueOf"(name: string): $QIODriveTier
public "getBaseTier"(): $BaseTier
public "getMaxCount"(): long
public "getMaxTypes"(): integer
get "baseTier"(): $BaseTier
get "maxCount"(): long
get "maxTypes"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIODriveTier$Type = (("hyper_dense") | ("supermassive") | ("time_dilating") | ("base")) | ($QIODriveTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIODriveTier_ = $QIODriveTier$Type;
}}
declare module "packages/mekanism/common/inventory/$ISlotClickHandler" {
import {$ISlotClickHandler$IScrollableSlot, $ISlotClickHandler$IScrollableSlot$Type} from "packages/mekanism/common/inventory/$ISlotClickHandler$IScrollableSlot"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $ISlotClickHandler {

 "onClick"(slotProvider: $Supplier$Type<($ISlotClickHandler$IScrollableSlot$Type)>, button: integer, hasShiftDown: boolean, heldItem: $ItemStack$Type): void

(slotProvider: $Supplier$Type<($ISlotClickHandler$IScrollableSlot$Type)>, button: integer, hasShiftDown: boolean, heldItem: $ItemStack$Type): void
}

export namespace $ISlotClickHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISlotClickHandler$Type = ($ISlotClickHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISlotClickHandler_ = $ISlotClickHandler$Type;
}}
declare module "packages/mekanism/common/item/$ItemQIODrive" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$QIODriveData, $QIODriveData$Type} from "packages/mekanism/common/content/qio/$QIODriveData"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IQIODriveItem, $IQIODriveItem$Type} from "packages/mekanism/common/content/qio/$IQIODriveItem"
import {$QIODriveTier, $QIODriveTier$Type} from "packages/mekanism/common/tier/$QIODriveTier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemQIODrive extends $Item implements $IQIODriveItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(tier: $QIODriveTier$Type, properties: $Item$Properties$Type)

public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "getName"(stack: $ItemStack$Type): $Component
public "getCountCapacity"(stack: $ItemStack$Type): long
public "getTypeCapacity"(stack: $ItemStack$Type): integer
public "loadItemMap"(stack: $ItemStack$Type, data: $QIODriveData$Type): void
public "hasStoredItemMap"(stack: $ItemStack$Type): boolean
public "writeItemMap"(stack: $ItemStack$Type, map: $QIODriveData$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemQIODrive$Type = ($ItemQIODrive);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemQIODrive_ = $ItemQIODrive$Type;
}}
declare module "packages/mekanism/common/inventory/container/$MekanismContainer$ISpecificContainerTracker" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$ISyncableData, $ISyncableData$Type} from "packages/mekanism/common/inventory/container/sync/$ISyncableData"

export interface $MekanismContainer$ISpecificContainerTracker {

 "getSpecificSyncableData"(): $List<($ISyncableData)>

(): $List<($ISyncableData)>
}

export namespace $MekanismContainer$ISpecificContainerTracker {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismContainer$ISpecificContainerTracker$Type = ($MekanismContainer$ISpecificContainerTracker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismContainer$ISpecificContainerTracker_ = $MekanismContainer$ISpecificContainerTracker$Type;
}}
declare module "packages/mekanism/common/item/$ItemAlloy" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$AlloyTier, $AlloyTier$Type} from "packages/mekanism/api/tier/$AlloyTier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemAlloy extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(tier: $AlloyTier$Type, properties: $Item$Properties$Type)

public "getTier"(): $AlloyTier
public "useOn"(context: $UseOnContext$Type): $InteractionResult
get "tier"(): $AlloyTier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemAlloy$Type = ($ItemAlloy);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemAlloy_ = $ItemAlloy$Type;
}}
declare module "packages/mekanism/common/block/transmitter/$BlockPressurizedTube" {
import {$TubeTier, $TubeTier$Type} from "packages/mekanism/common/tier/$TubeTier"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$ITypeBlock, $ITypeBlock$Type} from "packages/mekanism/common/block/interfaces/$ITypeBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockType, $BlockType$Type} from "packages/mekanism/common/content/blocktype/$BlockType"
import {$IHasTileEntity, $IHasTileEntity$Type} from "packages/mekanism/common/block/interfaces/$IHasTileEntity"
import {$BlockSmallTransmitter, $BlockSmallTransmitter$Type} from "packages/mekanism/common/block/transmitter/$BlockSmallTransmitter"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$TileEntityPressurizedTube, $TileEntityPressurizedTube$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityPressurizedTube"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export class $BlockPressurizedTube extends $BlockSmallTransmitter implements $ITypeBlock, $IHasTileEntity<($TileEntityPressurizedTube)> {
static readonly "CENTER": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(tier: $TubeTier$Type)

public "getType"(): $BlockType
public "getTileType"(): $TileEntityTypeRegistryObject<($TileEntityPressurizedTube)>
public "createDummyBlockEntity"(state: $BlockState$Type): $TileEntityPressurizedTube
public "createDummyBlockEntity"(): $TileEntityPressurizedTube
public "triggerBlockEntityEvent"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, id: integer, param: integer): boolean
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $TileEntityPressurizedTube
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
get "type"(): $BlockType
get "tileType"(): $TileEntityTypeRegistryObject<($TileEntityPressurizedTube)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPressurizedTube$Type = ($BlockPressurizedTube);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPressurizedTube_ = $BlockPressurizedTube$Type;
}}
declare module "packages/mekanism/common/lib/radial/$IRadialModeItem" {
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IGenericRadialModeItem, $IGenericRadialModeItem$Type} from "packages/mekanism/common/lib/radial/$IGenericRadialModeItem"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IRadialMode, $IRadialMode$Type} from "packages/mekanism/api/radial/mode/$IRadialMode"
import {$RadialData, $RadialData$Type} from "packages/mekanism/api/radial/$RadialData"

export interface $IRadialModeItem<MODE extends $IRadialMode> extends $IGenericRadialModeItem {

 "setMode"<M extends $IRadialMode>(stack: $ItemStack$Type, player: $Player$Type, radialData: $RadialData$Type<(M)>, mode: M): void
 "setMode"(stack: $ItemStack$Type, player: $Player$Type, mode: MODE): void
 "getMode"<M extends $IRadialMode>(stack: $ItemStack$Type, radialData: $RadialData$Type<(M)>): M
 "getMode"(stack: $ItemStack$Type): MODE
 "getRadialData"(stack: $ItemStack$Type): $RadialData<(MODE)>
 "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
 "getScrollTextComponent"(stack: $ItemStack$Type): $Component
 "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
}

export namespace $IRadialModeItem {
function displayModeChange(player: $Player$Type): void
function isModeItem(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
function isModeItem(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
function isModeItem(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRadialModeItem$Type<MODE> = ($IRadialModeItem<(MODE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRadialModeItem_<MODE> = $IRadialModeItem$Type<(MODE)>;
}}
declare module "packages/mekanism/common/registration/impl/$CreativeTabDeferredRegister$MekanismCreativeTab" {
import {$CreativeModeTab$DisplayItemsGenerator, $CreativeModeTab$DisplayItemsGenerator$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$DisplayItemsGenerator"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $CreativeTabDeferredRegister$MekanismCreativeTab extends $CreativeModeTab {
readonly "displayItemsGenerator": $CreativeModeTab$DisplayItemsGenerator
readonly "tabsBefore": $List<($ResourceLocation)>
readonly "tabsAfter": $List<($ResourceLocation)>


public "getLabelColor"(): integer
get "labelColor"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabDeferredRegister$MekanismCreativeTab$Type = ($CreativeTabDeferredRegister$MekanismCreativeTab);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabDeferredRegister$MekanismCreativeTab_ = $CreativeTabDeferredRegister$MekanismCreativeTab$Type;
}}
declare module "packages/mekanism/common/inventory/container/sync/$ISyncableData$DirtyType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ISyncableData$DirtyType extends $Enum<($ISyncableData$DirtyType)> {
static readonly "CLEAN": $ISyncableData$DirtyType
static readonly "SIZE": $ISyncableData$DirtyType
static readonly "DIRTY": $ISyncableData$DirtyType


public static "get"(dirty: boolean): $ISyncableData$DirtyType
public static "values"(): ($ISyncableData$DirtyType)[]
public static "valueOf"(name: string): $ISyncableData$DirtyType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISyncableData$DirtyType$Type = (("dirty") | ("size") | ("clean")) | ($ISyncableData$DirtyType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISyncableData$DirtyType_ = $ISyncableData$DirtyType$Type;
}}
declare module "packages/mekanism/common/resource/$BlockResourceInfo" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$IResource, $IResource$Type} from "packages/mekanism/common/resource/$IResource"
import {$MapColor, $MapColor$Type} from "packages/net/minecraft/world/level/material/$MapColor"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"

export class $BlockResourceInfo extends $Enum<($BlockResourceInfo)> implements $IResource {
static readonly "OSMIUM": $BlockResourceInfo
static readonly "RAW_OSMIUM": $BlockResourceInfo
static readonly "TIN": $BlockResourceInfo
static readonly "RAW_TIN": $BlockResourceInfo
static readonly "LEAD": $BlockResourceInfo
static readonly "RAW_LEAD": $BlockResourceInfo
static readonly "URANIUM": $BlockResourceInfo
static readonly "RAW_URANIUM": $BlockResourceInfo
static readonly "CHARCOAL": $BlockResourceInfo
static readonly "FLUORITE": $BlockResourceInfo
static readonly "BRONZE": $BlockResourceInfo
static readonly "STEEL": $BlockResourceInfo
static readonly "REFINED_OBSIDIAN": $BlockResourceInfo
static readonly "REFINED_GLOWSTONE": $BlockResourceInfo


public static "values"(): ($BlockResourceInfo)[]
public static "valueOf"(name: string): $BlockResourceInfo
public "isPortalFrame"(): boolean
public "getMapColor"(): $MapColor
public "modifyProperties"(properties: $BlockBehaviour$Properties$Type): $BlockBehaviour$Properties
public "getRegistrySuffix"(): string
public "getBurnTime"(): integer
public "burnsInFire"(): boolean
get "portalFrame"(): boolean
get "mapColor"(): $MapColor
get "registrySuffix"(): string
get "burnTime"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockResourceInfo$Type = (("raw_osmium") | ("steel") | ("raw_tin") | ("osmium") | ("lead") | ("bronze") | ("raw_lead") | ("raw_uranium") | ("refined_glowstone") | ("tin") | ("fluorite") | ("charcoal") | ("uranium") | ("refined_obsidian")) | ($BlockResourceInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockResourceInfo_ = $BlockResourceInfo$Type;
}}
declare module "packages/mekanism/common/item/$ItemModule" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IModuleItem, $IModuleItem$Type} from "packages/mekanism/common/content/gear/$IModuleItem"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$IModuleDataProvider, $IModuleDataProvider$Type} from "packages/mekanism/api/providers/$IModuleDataProvider"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$ModuleData, $ModuleData$Type} from "packages/mekanism/api/gear/$ModuleData"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemModule extends $Item implements $IModuleItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(moduleData: $IModuleDataProvider$Type<(any)>, properties: $Item$Properties$Type)

public "getDescriptionId"(): string
public "getMaxStackSize"(stack: $ItemStack$Type): integer
public "getModuleData"(): $ModuleData<(any)>
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "getRarity"(stack: $ItemStack$Type): $Rarity
get "descriptionId"(): string
get "moduleData"(): $ModuleData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModule$Type = ($ItemModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemModule_ = $ItemModule$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ItemStackToGasRecipeSerializer" {
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$ItemStackToChemicalRecipeSerializer, $ItemStackToChemicalRecipeSerializer$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackToChemicalRecipeSerializer"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$Gas, $Gas$Type} from "packages/mekanism/api/chemical/gas/$Gas"
import {$ItemStackToGasRecipe, $ItemStackToGasRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackToGasRecipe"
import {$ItemStackToChemicalRecipeSerializer$IFactory, $ItemStackToChemicalRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackToChemicalRecipeSerializer$IFactory"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ItemStackToGasRecipeSerializer<RECIPE extends $ItemStackToGasRecipe> extends $ItemStackToChemicalRecipeSerializer<($Gas), ($GasStack), (RECIPE)> {

constructor(factory: $ItemStackToChemicalRecipeSerializer$IFactory$Type<($Gas$Type), ($GasStack$Type), (RECIPE)>)

public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackToGasRecipeSerializer$Type<RECIPE> = ($ItemStackToGasRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackToGasRecipeSerializer_<RECIPE> = $ItemStackToGasRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/tile/$TileEntityCardboardBox" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$TileEntityUpdateable, $TileEntityUpdateable$Type} from "packages/mekanism/common/tile/base/$TileEntityUpdateable"
import {$BlockCardboardBox$BlockData, $BlockCardboardBox$BlockData$Type} from "packages/mekanism/common/block/$BlockCardboardBox$BlockData"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $TileEntityCardboardBox extends $TileEntityUpdateable {
 "storedData": $BlockCardboardBox$BlockData
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "load"(nbt: $CompoundTag$Type): void
public "m_183515_"(nbtTags: $CompoundTag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityCardboardBox$Type = ($TileEntityCardboardBox);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityCardboardBox_ = $TileEntityCardboardBox$Type;
}}
declare module "packages/mekanism/common/tile/$TileEntityBoundingBlock" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IUpgradeTile, $IUpgradeTile$Type} from "packages/mekanism/common/tile/interfaces/$IUpgradeTile"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$TileComponentUpgrade, $TileComponentUpgrade$Type} from "packages/mekanism/common/tile/component/$TileComponentUpgrade"
import {$TileEntityUpdateable, $TileEntityUpdateable$Type} from "packages/mekanism/common/tile/base/$TileEntityUpdateable"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Upgrade, $Upgrade$Type} from "packages/mekanism/api/$Upgrade"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Nameable, $Nameable$Type} from "packages/net/minecraft/world/$Nameable"

export class $TileEntityBoundingBlock extends $TileEntityUpdateable implements $IUpgradeTile, $Nameable {
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "onNeighborChange"(block: $Block$Type, neighborPos: $BlockPos$Type): void
public "load"(nbt: $CompoundTag$Type): void
public "m_183515_"(nbtTags: $CompoundTag$Type): void
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "recalculateUpgrades"(upgradeType: $Upgrade$Type): void
public "supportsUpgrades"(): boolean
public "getComponent"(): $TileComponentUpgrade
public "getCapability"<T>(capability: $Capability$Type<(T)>, side: $Direction$Type): $LazyOptional<(T)>
public "triggerEvent"(id: integer, param: integer): boolean
public "getName"(): $Component
public "hasCustomName"(): boolean
public "getReducedUpdateTag"(): $CompoundTag
public "getMainTile"(): $BlockEntity
public "getDisplayName"(): $Component
public "getCustomName"(): $Component
public "getComparatorSignal"(): integer
public "setMainLocation"(pos: $BlockPos$Type): void
public "getMainPos"(): $BlockPos
public "hasReceivedCoords"(): boolean
public "supportsUpgrade"(upgradeType: $Upgrade$Type): boolean
get "component"(): $TileComponentUpgrade
get "name"(): $Component
get "reducedUpdateTag"(): $CompoundTag
get "mainTile"(): $BlockEntity
get "displayName"(): $Component
get "customName"(): $Component
get "comparatorSignal"(): integer
set "mainLocation"(value: $BlockPos$Type)
get "mainPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityBoundingBlock$Type = ($TileEntityBoundingBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityBoundingBlock_ = $TileEntityBoundingBlock$Type;
}}
declare module "packages/mekanism/common/content/network/transmitter/$LogisticalTransporterBase" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$AcceptorCache, $AcceptorCache$Type} from "packages/mekanism/common/lib/transmitter/acceptor/$AcceptorCache"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest$TransitResponse"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$InventoryNetwork, $InventoryNetwork$Type} from "packages/mekanism/common/content/network/$InventoryNetwork"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$TransitRequest, $TransitRequest$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest"
import {$TransporterTier, $TransporterTier$Type} from "packages/mekanism/common/tier/$TransporterTier"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$TransporterStack, $TransporterStack$Type} from "packages/mekanism/common/content/transporter/$TransporterStack"
import {$TileEntityLogisticalSorter, $TileEntityLogisticalSorter$Type} from "packages/mekanism/common/tile/$TileEntityLogisticalSorter"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"
import {$Transmitter, $Transmitter$Type} from "packages/mekanism/common/content/network/transmitter/$Transmitter"

export class $LogisticalTransporterBase extends $Transmitter<($IItemHandler), ($InventoryNetwork), ($LogisticalTransporterBase)> {
readonly "tier": $TransporterTier
 "currentTransmitterConnections": byte


public "remove"(): void
public "insert"(outputter: $BlockEntity$Type, request: $TransitRequest$Type, color: $EnumColor$Type, doEmit: boolean, min: integer): $TransitRequest$TransitResponse
public "write"(nbtTags: $CompoundTag$Type): $CompoundTag
public "read"(nbtTags: $CompoundTag$Type): void
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "writeToNBT"(nbtTags: $CompoundTag$Type): void
public "getColor"(): $EnumColor
public "addStack"(id: integer, s: $TransporterStack$Type): void
public "onUpdateServer"(): void
public "onUpdateClient"(): void
public "takeShare"(): void
public "getReducedUpdateTag"(updateTag: $CompoundTag$Type): $CompoundTag
public "getCost"(): double
public "insertRR"(outputter: $TileEntityLogisticalSorter$Type, request: $TransitRequest$Type, color: $EnumColor$Type, doEmit: boolean, min: integer): $TransitRequest$TransitResponse
public "createEmptyNetworkWithID"(networkID: $UUID$Type): $InventoryNetwork
public "createNetworkByMerging"(networks: $Collection$Type<($InventoryNetwork$Type)>): $InventoryNetwork
public "isValidTransmitterBasic"(transmitter: $TileEntityTransmitter$Type, side: $Direction$Type): boolean
public "getTransit"(): $Collection<($TransporterStack)>
public "getAcceptorCache"(): $AcceptorCache<($IItemHandler)>
public "isValidAcceptor"(tile: $BlockEntity$Type, side: $Direction$Type): boolean
public "handlesRedstone"(): boolean
public "canReceiveFrom"(side: $Direction$Type): boolean
public "canEmitTo"(side: $Direction$Type): boolean
public "exposesInsertCap"(side: $Direction$Type): boolean
public "deleteStack"(id: integer): void
public "createInsertStack"(outputterCoord: $BlockPos$Type, color: $EnumColor$Type): $TransporterStack
public "insertUnchecked"(outputterPos: $BlockPos$Type, request: $TransitRequest$Type, color: $EnumColor$Type, doEmit: boolean, min: integer): $TransitRequest$TransitResponse
get "color"(): $EnumColor
get "cost"(): double
get "transit"(): $Collection<($TransporterStack)>
get "acceptorCache"(): $AcceptorCache<($IItemHandler)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogisticalTransporterBase$Type = ($LogisticalTransporterBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LogisticalTransporterBase_ = $LogisticalTransporterBase$Type;
}}
declare module "packages/mekanism/common/content/network/$InventoryNetwork" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ChunkAccess, $ChunkAccess$Type} from "packages/net/minecraft/world/level/chunk/$ChunkAccess"
import {$LogisticalTransporterBase, $LogisticalTransporterBase$Type} from "packages/mekanism/common/content/network/transmitter/$LogisticalTransporterBase"
import {$InventoryNetwork$AcceptorData, $InventoryNetwork$AcceptorData$Type} from "packages/mekanism/common/content/network/$InventoryNetwork$AcceptorData"
import {$IItemHandler, $IItemHandler$Type} from "packages/net/minecraftforge/items/$IItemHandler"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Long2ObjectMap, $Long2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap"
import {$TransitRequest, $TransitRequest$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest"
import {$DynamicNetwork, $DynamicNetwork$Type} from "packages/mekanism/common/lib/transmitter/$DynamicNetwork"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TransporterStack, $TransporterStack$Type} from "packages/mekanism/common/content/transporter/$TransporterStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $InventoryNetwork extends $DynamicNetwork<($IItemHandler), ($InventoryNetwork), ($LogisticalTransporterBase)> {

constructor(networkID: $UUID$Type)
constructor(networks: $Collection$Type<($InventoryNetwork$Type)>)

public "toString"(): string
public "commit"(): void
public "adoptTransmittersAndAcceptorsFrom"(net: $InventoryNetwork$Type): $List<($LogisticalTransporterBase)>
public "deregister"(): void
public "addTransmitter"(transmitter: $LogisticalTransporterBase$Type): void
public "removeTransmitter"(transmitter: $LogisticalTransporterBase$Type): void
public "getTransmitter"(pos: $BlockPos$Type): $LogisticalTransporterBase
public "getTextComponent"(): $Component
public "calculateAcceptors"(request: $TransitRequest$Type, stack: $TransporterStack$Type, chunkMap: $Long2ObjectMap$Type<($ChunkAccess$Type)>, additionalFlowingStacks: $Map$Type<($Coord4D$Type), ($Set$Type<($TransporterStack$Type)>)>): $List<($InventoryNetwork$AcceptorData)>
get "textComponent"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryNetwork$Type = ($InventoryNetwork);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryNetwork_ = $InventoryNetwork$Type;
}}
declare module "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager$InfusionHandlerManager" {
import {$ChemicalHandlerManager, $ChemicalHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager"
import {$IInfusionHandler, $IInfusionHandler$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionHandler"
import {$InfuseType, $InfuseType$Type} from "packages/mekanism/api/chemical/infuse/$InfuseType"
import {$IInfusionHandler$ISidedInfusionHandler, $IInfusionHandler$ISidedInfusionHandler$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionHandler$ISidedInfusionHandler"
import {$InfusionStack, $InfusionStack$Type} from "packages/mekanism/api/chemical/infuse/$InfusionStack"
import {$IInfusionTank, $IInfusionTank$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionTank"
import {$IChemicalTankHolder, $IChemicalTankHolder$Type} from "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder"

export class $ChemicalHandlerManager$InfusionHandlerManager extends $ChemicalHandlerManager<($InfuseType), ($InfusionStack), ($IInfusionTank), ($IInfusionHandler), ($IInfusionHandler$ISidedInfusionHandler)> {

constructor(holder: $IChemicalTankHolder$Type<($InfuseType$Type), ($InfusionStack$Type), ($IInfusionTank$Type)>, baseHandler: $IInfusionHandler$ISidedInfusionHandler$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalHandlerManager$InfusionHandlerManager$Type = ($ChemicalHandlerManager$InfusionHandlerManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalHandlerManager$InfusionHandlerManager_ = $ChemicalHandlerManager$InfusionHandlerManager$Type;
}}
declare module "packages/mekanism/common/inventory/container/slot/$MainInventorySlot" {
import {$InsertableSlot, $InsertableSlot$Type} from "packages/mekanism/common/inventory/container/slot/$InsertableSlot"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $MainInventorySlot extends $InsertableSlot {
readonly "slot": integer
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(inventory: $Container$Type, index: integer, x: integer, y: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MainInventorySlot$Type = ($MainInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MainInventorySlot_ = $MainInventorySlot$Type;
}}
declare module "packages/mekanism/common/item/$ItemConfigurationCard" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemConfigurationCard extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "hasData"(stack: $ItemStack$Type): boolean
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemConfigurationCard$Type = ($ItemConfigurationCard);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemConfigurationCard_ = $ItemConfigurationCard$Type;
}}
declare module "packages/mekanism/common/inventory/container/$IGUIWindow" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IGUIWindow {

}

export namespace $IGUIWindow {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGUIWindow$Type = ($IGUIWindow);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGUIWindow_ = $IGUIWindow$Type;
}}
declare module "packages/mekanism/common/content/filter/$BaseFilter" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$FilterType, $FilterType$Type} from "packages/mekanism/common/content/filter/$FilterType"
import {$IFilter, $IFilter$Type} from "packages/mekanism/common/content/filter/$IFilter"

export class $BaseFilter<FILTER extends $BaseFilter<(FILTER)>> implements $IFilter<(FILTER)> {

constructor()

public "equals"(o: any): boolean
public "hashCode"(): integer
public "write"(buffer: $FriendlyByteBuf$Type): void
public "write"(nbtTags: $CompoundTag$Type): $CompoundTag
public "read"(buffer: $FriendlyByteBuf$Type): void
public "read"(nbtTags: $CompoundTag$Type): void
public static "fromType"(filterType: $FilterType$Type): $IFilter<(any)>
public "isEnabled"(): boolean
public "setEnabled"(enabled: boolean): void
public static "readFromNBT"(nbt: $CompoundTag$Type): $IFilter<(any)>
public static "readFromPacket"(dataStream: $FriendlyByteBuf$Type): $IFilter<(any)>
public "hasFilter"(): boolean
public "getFilterType"(): $FilterType
get "enabled"(): boolean
set "enabled"(value: boolean)
get "filterType"(): $FilterType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseFilter$Type<FILTER> = ($BaseFilter<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseFilter_<FILTER> = $BaseFilter$Type<(FILTER)>;
}}
declare module "packages/mekanism/common/item/$ItemRobit" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ListTag, $ListTag$Type} from "packages/net/minecraft/nbt/$ListTag"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$ItemEnergized, $ItemEnergized$Type} from "packages/mekanism/common/item/$ItemEnergized"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IItemSustainedInventory, $IItemSustainedInventory$Type} from "packages/mekanism/common/item/interfaces/$IItemSustainedInventory"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$RobitSkin, $RobitSkin$Type} from "packages/mekanism/api/robit/$RobitSkin"

export class $ItemRobit extends $ItemEnergized implements $IItemSustainedInventory {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "setName"(stack: $ItemStack$Type, name: $Component$Type): void
public "onDestroyed"(item: $ItemEntity$Type, damageSource: $DamageSource$Type): void
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "setSkin"(stack: $ItemStack$Type, skin: $ResourceKey$Type<($RobitSkin$Type)>): void
public "getRobitSkin"(stack: $ItemStack$Type): $ResourceKey<($RobitSkin)>
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "getSustainedInventory"(stack: $ItemStack$Type): $ListTag
public "getSustainedInventory"(): $ListTag
public "setSustainedInventory"(nbtTags: $ListTag$Type): void
public "setSustainedInventory"(nbtTags: $ListTag$Type, stack: $ItemStack$Type): void
public "getDroppedSlots"(stack: $ItemStack$Type): $List<($IInventorySlot)>
public "hasSustainedInventory"(stack: $ItemStack$Type): boolean
public "hasSustainedInventory"(): boolean
public "canContentsDrop"(stack: $ItemStack$Type): boolean
get "sustainedInventory"(): $ListTag
set "sustainedInventory"(value: $ListTag$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemRobit$Type = ($ItemRobit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemRobit_ = $ItemRobit$Type;
}}
declare module "packages/mekanism/common/item/interfaces/$IJetpackItem$JetpackMode" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IIncrementalEnum, $IIncrementalEnum$Type} from "packages/mekanism/api/$IIncrementalEnum"
import {$IHasTextComponent, $IHasTextComponent$Type} from "packages/mekanism/api/text/$IHasTextComponent"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $IJetpackItem$JetpackMode extends $Enum<($IJetpackItem$JetpackMode)> implements $IIncrementalEnum<($IJetpackItem$JetpackMode)>, $IHasTextComponent {
static readonly "NORMAL": $IJetpackItem$JetpackMode
static readonly "HOVER": $IJetpackItem$JetpackMode
static readonly "DISABLED": $IJetpackItem$JetpackMode


public static "values"(): ($IJetpackItem$JetpackMode)[]
public static "valueOf"(name: string): $IJetpackItem$JetpackMode
public "getHUDIcon"(): $ResourceLocation
public "getTextComponent"(): $Component
public static "byIndexStatic"(index: integer): $IJetpackItem$JetpackMode
public "ordinal"(): integer
public "adjust"(arg0: integer): $IJetpackItem$JetpackMode
public "adjust"(arg0: integer, arg1: $Predicate$Type<($IJetpackItem$JetpackMode$Type)>): $IJetpackItem$JetpackMode
public "getNext"(arg0: $Predicate$Type<($IJetpackItem$JetpackMode$Type)>): $IJetpackItem$JetpackMode
public "getNext"(): $IJetpackItem$JetpackMode
public "getPrevious"(): $IJetpackItem$JetpackMode
public "getPrevious"(arg0: $Predicate$Type<($IJetpackItem$JetpackMode$Type)>): $IJetpackItem$JetpackMode
get "hUDIcon"(): $ResourceLocation
get "textComponent"(): $Component
get "next"(): $IJetpackItem$JetpackMode
get "previous"(): $IJetpackItem$JetpackMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IJetpackItem$JetpackMode$Type = (("normal") | ("hover") | ("disabled")) | ($IJetpackItem$JetpackMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IJetpackItem$JetpackMode_ = $IJetpackItem$JetpackMode$Type;
}}
declare module "packages/mekanism/common/content/qio/$QIODriveData$QIODriveKey" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$QIODriveData, $QIODriveData$Type} from "packages/mekanism/common/content/qio/$QIODriveData"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IQIODriveHolder, $IQIODriveHolder$Type} from "packages/mekanism/common/content/qio/$IQIODriveHolder"

export class $QIODriveData$QIODriveKey extends $Record {

constructor(holder: $IQIODriveHolder$Type, driveSlot: integer)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "save"(data: $QIODriveData$Type): void
public "holder"(): $IQIODriveHolder
public "driveSlot"(): integer
public "dataUpdate"(): void
public "updateMetadata"(data: $QIODriveData$Type): void
public "getDriveStack"(): $ItemStack
get "driveStack"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIODriveData$QIODriveKey$Type = ($QIODriveData$QIODriveKey);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIODriveData$QIODriveKey_ = $QIODriveData$QIODriveKey$Type;
}}
declare module "packages/mekanism/common/block/transmitter/$BlockMechanicalPipe" {
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$ITypeBlock, $ITypeBlock$Type} from "packages/mekanism/common/block/interfaces/$ITypeBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockType, $BlockType$Type} from "packages/mekanism/common/content/blocktype/$BlockType"
import {$IHasTileEntity, $IHasTileEntity$Type} from "packages/mekanism/common/block/interfaces/$IHasTileEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$BlockLargeTransmitter, $BlockLargeTransmitter$Type} from "packages/mekanism/common/block/transmitter/$BlockLargeTransmitter"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$TileEntityMechanicalPipe, $TileEntityMechanicalPipe$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityMechanicalPipe"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$PipeTier, $PipeTier$Type} from "packages/mekanism/common/tier/$PipeTier"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export class $BlockMechanicalPipe extends $BlockLargeTransmitter implements $ITypeBlock, $IHasTileEntity<($TileEntityMechanicalPipe)> {
static readonly "CENTER": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(tier: $PipeTier$Type)

public "getType"(): $BlockType
public "getTileType"(): $TileEntityTypeRegistryObject<($TileEntityMechanicalPipe)>
public "createDummyBlockEntity"(state: $BlockState$Type): $TileEntityMechanicalPipe
public "createDummyBlockEntity"(): $TileEntityMechanicalPipe
public "triggerBlockEntityEvent"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, id: integer, param: integer): boolean
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $TileEntityMechanicalPipe
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
get "type"(): $BlockType
get "tileType"(): $TileEntityTypeRegistryObject<($TileEntityMechanicalPipe)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockMechanicalPipe$Type = ($BlockMechanicalPipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockMechanicalPipe_ = $BlockMechanicalPipe$Type;
}}
declare module "packages/mekanism/common/capabilities/chemical/dynamic/$IInfusionTracker" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IInfusionTank, $IInfusionTank$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionTank"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"

export interface $IInfusionTracker extends $IContentsListener {

 "getInfusionTanks"(side: $Direction$Type): $List<($IInfusionTank)>
 "onContentsChanged"(): void
}

export namespace $IInfusionTracker {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInfusionTracker$Type = ($IInfusionTracker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInfusionTracker_ = $IInfusionTracker$Type;
}}
declare module "packages/mekanism/common/item/$ItemDictionary" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemDictionary extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "interactLivingEntity"(stack: $ItemStack$Type, player: $Player$Type, entity: $LivingEntity$Type, hand: $InteractionHand$Type): $InteractionResult
public "use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDictionary$Type = ($ItemDictionary);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDictionary_ = $ItemDictionary$Type;
}}
declare module "packages/mekanism/common/content/blocktype/$BlockType" {
import {$Attribute, $Attribute$Type} from "packages/mekanism/common/block/attribute/$Attribute"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ILangEntry, $ILangEntry$Type} from "packages/mekanism/api/text/$ILangEntry"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $BlockType {

constructor(description: $ILangEntry$Type)

public "add"(...attrs: ($Attribute$Type)[]): void
public "remove"(...attrs: ($Class$Type<(any)>)[]): void
public static "get"(block: $Block$Type): $BlockType
public "get"<ATTRIBUTE extends $Attribute>(type: $Class$Type<(ATTRIBUTE)>): ATTRIBUTE
public static "is"(block: $Block$Type, ...types: ($BlockType$Type)[]): boolean
public "has"(type: $Class$Type<(any)>): boolean
public "getAll"(): $Collection<($Attribute)>
public "getDescription"(): $ILangEntry
get "all"(): $Collection<($Attribute)>
get "description"(): $ILangEntry
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockType$Type = ($BlockType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockType_ = $BlockType$Type;
}}
declare module "packages/mekanism/common/capabilities/fluid/item/$RateLimitMultiTankFluidHandler$FluidTankSpec" {
import {$TriPredicate, $TriPredicate$Type} from "packages/net/minecraftforge/common/util/$TriPredicate"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$GenericTankSpec, $GenericTankSpec$Type} from "packages/mekanism/common/capabilities/$GenericTankSpec"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $RateLimitMultiTankFluidHandler$FluidTankSpec extends $GenericTankSpec<($FluidStack)> {
readonly "isValid": $Predicate<(TYPE)>
readonly "canExtract": $BiPredicate<(TYPE), ($AutomationType)>
readonly "canInsert": $TriPredicate<(TYPE), ($AutomationType), ($ItemStack)>

constructor(rate: $IntSupplier$Type, capacity: $IntSupplier$Type, canExtract: $BiPredicate$Type<($FluidStack$Type), ($AutomationType$Type)>, canInsert: $TriPredicate$Type<($FluidStack$Type), ($AutomationType$Type), ($ItemStack$Type)>, isValid: $Predicate$Type<($FluidStack$Type)>, supportsStack: $Predicate$Type<($ItemStack$Type)>)

public static "createFillOnly"(rate: $IntSupplier$Type, capacity: $IntSupplier$Type, isValid: $Predicate$Type<($FluidStack$Type)>): $RateLimitMultiTankFluidHandler$FluidTankSpec
public static "createFillOnly"(rate: $IntSupplier$Type, capacity: $IntSupplier$Type, isValid: $Predicate$Type<($FluidStack$Type)>, supportsStack: $Predicate$Type<($ItemStack$Type)>): $RateLimitMultiTankFluidHandler$FluidTankSpec
public static "create"(rate: $IntSupplier$Type, capacity: $IntSupplier$Type): $RateLimitMultiTankFluidHandler$FluidTankSpec
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RateLimitMultiTankFluidHandler$FluidTankSpec$Type = ($RateLimitMultiTankFluidHandler$FluidTankSpec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RateLimitMultiTankFluidHandler$FluidTankSpec_ = $RateLimitMultiTankFluidHandler$FluidTankSpec$Type;
}}
declare module "packages/mekanism/common/block/basic/$BlockLogisticalSorter" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$Type} from "packages/mekanism/common/block/prefab/$BlockTile$BlockTileModel"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Machine, $Machine$Type} from "packages/mekanism/common/content/blocktype/$Machine"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$TileEntityLogisticalSorter, $TileEntityLogisticalSorter$Type} from "packages/mekanism/common/tile/$TileEntityLogisticalSorter"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"

export class $BlockLogisticalSorter extends $BlockTile$BlockTileModel<($TileEntityLogisticalSorter), ($Machine<($TileEntityLogisticalSorter)>)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor()

public "getStateForPlacement"(context: $BlockPlaceContext$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "updateShape"(state: $BlockState$Type, dir: $Direction$Type, facingState: $BlockState$Type, world: $LevelAccessor$Type, pos: $BlockPos$Type, neighborPos: $BlockPos$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "use"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockLogisticalSorter$Type = ($BlockLogisticalSorter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockLogisticalSorter_ = $BlockLogisticalSorter$Type;
}}
declare module "packages/mekanism/common/world/height/$HeightShape" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $HeightShape extends $Enum<($HeightShape)> {
static readonly "TRAPEZOID": $HeightShape
static readonly "UNIFORM": $HeightShape


public static "values"(): ($HeightShape)[]
public static "valueOf"(name: string): $HeightShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeightShape$Type = (("uniform") | ("trapezoid")) | ($HeightShape);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeightShape_ = $HeightShape$Type;
}}
declare module "packages/mekanism/common/item/block/machine/$ItemBlockQIOComponent" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemBlockTooltip, $ItemBlockTooltip$Type} from "packages/mekanism/common/item/block/$ItemBlockTooltip"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$BlockTile, $BlockTile$Type} from "packages/mekanism/common/block/prefab/$BlockTile"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IColoredItem, $IColoredItem$Type} from "packages/mekanism/common/item/interfaces/$IColoredItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ItemBlockQIOComponent extends $ItemBlockTooltip<($BlockTile<(any), (any)>)> implements $IColoredItem {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockTile$Type<(any), (any)>)

public "inventoryTick"(stack: $ItemStack$Type, level: $Level$Type, entity: $Entity$Type, slotId: integer, isSelected: boolean): void
public "setColor"(stack: $ItemStack$Type, color: $EnumColor$Type): void
public "getColor"(stack: $ItemStack$Type): $EnumColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockQIOComponent$Type = ($ItemBlockQIOComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockQIOComponent_ = $ItemBlockQIOComponent$Type;
}}
declare module "packages/mekanism/common/config/value/$CachedValue" {
import {$CachedValue$IConfigValueInvalidationListener, $CachedValue$IConfigValueInvalidationListener$Type} from "packages/mekanism/common/config/value/$CachedValue$IConfigValueInvalidationListener"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export class $CachedValue<T> {


public "clearCache"(unloading: boolean): void
public "hasInvalidationListeners"(): boolean
public "removeInvalidationListener"(listener: $CachedValue$IConfigValueInvalidationListener$Type): void
public "removeInvalidationListenersMatching"(checker: $Predicate$Type<($CachedValue$IConfigValueInvalidationListener$Type)>): boolean
public "addInvalidationListener"(listener: $CachedValue$IConfigValueInvalidationListener$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedValue$Type<T> = ($CachedValue<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedValue_<T> = $CachedValue$Type<(T)>;
}}
declare module "packages/mekanism/common/block/prefab/$BlockFactoryMachine$BlockFactory" {
import {$BlockFactoryMachine$BlockFactoryMachineModel, $BlockFactoryMachine$BlockFactoryMachineModel$Type} from "packages/mekanism/common/block/prefab/$BlockFactoryMachine$BlockFactoryMachineModel"
import {$TileEntityFactory, $TileEntityFactory$Type} from "packages/mekanism/common/tile/factory/$TileEntityFactory"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Factory, $Factory$Type} from "packages/mekanism/common/content/blocktype/$Factory"

export class $BlockFactoryMachine$BlockFactory<TILE extends $TileEntityFactory<(any)>> extends $BlockFactoryMachine$BlockFactoryMachineModel<(TILE), ($Factory<(TILE)>)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(factoryType: $Factory$Type<(TILE)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockFactoryMachine$BlockFactory$Type<TILE> = ($BlockFactoryMachine$BlockFactory<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockFactoryMachine$BlockFactory_<TILE> = $BlockFactoryMachine$BlockFactory$Type<(TILE)>;
}}
declare module "packages/mekanism/common/block/$BlockIndustrialAlarm" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$Type} from "packages/mekanism/common/block/prefab/$BlockTile$BlockTileModel"
import {$TileEntityIndustrialAlarm, $TileEntityIndustrialAlarm$Type} from "packages/mekanism/common/tile/$TileEntityIndustrialAlarm"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockIndustrialAlarm extends $BlockTile$BlockTileModel<($TileEntityIndustrialAlarm), ($BlockTypeTile<($TileEntityIndustrialAlarm)>)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor()

/**
 * 
 * @deprecated
 */
public "updateShape"(state: $BlockState$Type, facing: $Direction$Type, facingState: $BlockState$Type, world: $LevelAccessor$Type, currentPos: $BlockPos$Type, facingPos: $BlockPos$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "canSurvive"(state: $BlockState$Type, world: $LevelReader$Type, pos: $BlockPos$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIndustrialAlarm$Type = ($BlockIndustrialAlarm);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockIndustrialAlarm_ = $BlockIndustrialAlarm$Type;
}}
declare module "packages/mekanism/common/tile/multiblock/$TileEntityInductionCell" {
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$TileEntityInternalMultiblock, $TileEntityInternalMultiblock$Type} from "packages/mekanism/common/tile/prefab/$TileEntityInternalMultiblock"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$InductionCellTier, $InductionCellTier$Type} from "packages/mekanism/common/tier/$InductionCellTier"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$MachineEnergyContainer, $MachineEnergyContainer$Type} from "packages/mekanism/common/capabilities/energy/$MachineEnergyContainer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export class $TileEntityInductionCell extends $TileEntityInternalMultiblock {
 "tier": $InductionCellTier
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "getEnergyContainer"(): $MachineEnergyContainer<($TileEntityInductionCell)>
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "energyContainer"(): $MachineEnergyContainer<($TileEntityInductionCell)>
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityInductionCell$Type = ($TileEntityInductionCell);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityInductionCell_ = $TileEntityInductionCell$Type;
}}
declare module "packages/mekanism/common/content/blocktype/$Machine" {
import {$MekanismLang, $MekanismLang$Type} from "packages/mekanism/common/$MekanismLang"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $Machine<TILE extends $TileEntityMekanism> extends $BlockTypeTile<(TILE)> {

constructor(tileEntityRegistrar: $Supplier$Type<($TileEntityTypeRegistryObject$Type<(TILE)>)>, description: $MekanismLang$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Machine$Type<TILE> = ($Machine<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Machine_<TILE> = $Machine$Type<(TILE)>;
}}
declare module "packages/mekanism/common/content/qio/$IQIOFrequencyHolder" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$Type} from "packages/mekanism/common/lib/frequency/$Frequency$FrequencyIdentity"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$TileComponentFrequency, $TileComponentFrequency$Type} from "packages/mekanism/common/lib/frequency/$TileComponentFrequency"
import {$IFrequencyHandler, $IFrequencyHandler$Type} from "packages/mekanism/common/lib/frequency/$IFrequencyHandler"
import {$QIOFrequency, $QIOFrequency$Type} from "packages/mekanism/common/content/qio/$QIOFrequency"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$IQIOComponent, $IQIOComponent$Type} from "packages/mekanism/api/inventory/qio/$IQIOComponent"
import {$FrequencyType, $FrequencyType$Type} from "packages/mekanism/common/lib/frequency/$FrequencyType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ITileWrapper, $ITileWrapper$Type} from "packages/mekanism/common/tile/interfaces/$ITileWrapper"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IQIOFrequencyHolder extends $IFrequencyHandler, $ITileWrapper, $IQIOComponent {

 "getPrivateFrequencies"(): $List<($QIOFrequency)>
 "getPublicFrequencies"(): $List<($QIOFrequency)>
 "getFrequencyComponent"(): $TileComponentFrequency
 "getFrequency"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): FREQ
 "setFrequency"(type: $FrequencyType$Type<(any)>, data: $Frequency$FrequencyIdentity$Type, player: $UUID$Type): void
 "setFrequency"(type: $FrequencyType$Type<(any)>, frequencyCompound: $CompoundTag$Type): void
 "removeFrequency"(type: $FrequencyType$Type<(any)>, data: $Frequency$FrequencyIdentity$Type, player: $UUID$Type): void
 "getPublicCache"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): $List<(FREQ)>
 "getPrivateCache"<FREQ extends $Frequency>(type: $FrequencyType$Type<(FREQ)>): $List<(FREQ)>
 "getTilePos"(): $BlockPos
 "getTileWorld"(): $Level
 "getTileCoord"(): $Coord4D
 "getTileChunk"(): $Chunk3D
}

export namespace $IQIOFrequencyHolder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IQIOFrequencyHolder$Type = ($IQIOFrequencyHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IQIOFrequencyHolder_ = $IQIOFrequencyHolder$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$ISustainedData" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ISustainedData {

 "readSustainedData"(dataMap: $CompoundTag$Type): void
 "writeSustainedData"(dataMap: $CompoundTag$Type): void
 "getTileDataRemap"(): $Map<(string), (string)>
}

export namespace $ISustainedData {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISustainedData$Type = ($ISustainedData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISustainedData_ = $ISustainedData$Type;
}}
declare module "packages/mekanism/common/inventory/slot/$CraftingWindowInventorySlot" {
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$BasicInventorySlot, $BasicInventorySlot$Type} from "packages/mekanism/common/inventory/slot/$BasicInventorySlot"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$VirtualInventoryContainerSlot, $VirtualInventoryContainerSlot$Type} from "packages/mekanism/common/inventory/container/slot/$VirtualInventoryContainerSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$QIOCraftingWindow, $QIOCraftingWindow$Type} from "packages/mekanism/common/content/qio/$QIOCraftingWindow"

export class $CraftingWindowInventorySlot extends $BasicInventorySlot {
static readonly "alwaysTrue": $Predicate<($ItemStack)>
static readonly "alwaysFalse": $Predicate<($ItemStack)>
static readonly "alwaysTrueBi": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "DEFAULT_LIMIT": integer


public static "input"(window: $QIOCraftingWindow$Type, saveListener: $IContentsListener$Type): $CraftingWindowInventorySlot
public "onContentsChanged"(): void
public "createContainerSlot"(): $VirtualInventoryContainerSlot
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingWindowInventorySlot$Type = ($CraftingWindowInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingWindowInventorySlot_ = $CraftingWindowInventorySlot$Type;
}}
declare module "packages/mekanism/common/lib/radial/$IGenericRadialModeItem" {
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IModeItem, $IModeItem$Type} from "packages/mekanism/common/item/interfaces/$IModeItem"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IRadialMode, $IRadialMode$Type} from "packages/mekanism/api/radial/mode/$IRadialMode"
import {$RadialData, $RadialData$Type} from "packages/mekanism/api/radial/$RadialData"

export interface $IGenericRadialModeItem extends $IModeItem {

 "setMode"<M extends $IRadialMode>(stack: $ItemStack$Type, player: $Player$Type, radialData: $RadialData$Type<(M)>, mode: M): void
 "getMode"<M extends $IRadialMode>(stack: $ItemStack$Type, radialData: $RadialData$Type<(M)>): M
 "getRadialData"(stack: $ItemStack$Type): $RadialData<(any)>
 "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
 "getScrollTextComponent"(stack: $ItemStack$Type): $Component
 "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
}

export namespace $IGenericRadialModeItem {
function displayModeChange(player: $Player$Type): void
function isModeItem(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
function isModeItem(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
function isModeItem(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGenericRadialModeItem$Type = ($IGenericRadialModeItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGenericRadialModeItem_ = $IGenericRadialModeItem$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$ITierUpgradable" {
import {$IUpgradeData, $IUpgradeData$Type} from "packages/mekanism/common/upgrade/$IUpgradeData"

export interface $ITierUpgradable {

 "getUpgradeData"(): $IUpgradeData
 "canBeUpgraded"(): boolean

(): $IUpgradeData
}

export namespace $ITierUpgradable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITierUpgradable$Type = ($ITierUpgradable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITierUpgradable_ = $ITierUpgradable$Type;
}}
declare module "packages/mekanism/common/content/filter/$IFilter" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$FilterType, $FilterType$Type} from "packages/mekanism/common/content/filter/$FilterType"

export interface $IFilter<FILTER extends $IFilter<(FILTER)>> {

 "clone"(): FILTER
 "write"(buffer: $FriendlyByteBuf$Type): void
 "write"(nbtTags: $CompoundTag$Type): $CompoundTag
 "read"(dataStream: $FriendlyByteBuf$Type): void
 "read"(nbtTags: $CompoundTag$Type): void
 "isEnabled"(): boolean
 "hasFilter"(): boolean
 "setEnabled"(enabled: boolean): void
 "getFilterType"(): $FilterType
}

export namespace $IFilter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFilter$Type<FILTER> = ($IFilter<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFilter_<FILTER> = $IFilter$Type<(FILTER)>;
}}
declare module "packages/mekanism/common/tile/interfaces/chemical/$IPigmentTile" {
import {$IPigmentTank, $IPigmentTank$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentTank"
import {$IPigmentTracker, $IPigmentTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IPigmentTracker"
import {$ChemicalHandlerManager$PigmentHandlerManager, $ChemicalHandlerManager$PigmentHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager$PigmentHandlerManager"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Pigment, $Pigment$Type} from "packages/mekanism/api/chemical/pigment/$Pigment"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$IChemicalTankHolder, $IChemicalTankHolder$Type} from "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder"
import {$PigmentStack, $PigmentStack$Type} from "packages/mekanism/api/chemical/pigment/$PigmentStack"

export interface $IPigmentTile extends $IPigmentTracker {

 "getInitialPigmentManager"(listener: $IContentsListener$Type): $ChemicalHandlerManager$PigmentHandlerManager
 "getInitialPigmentTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($Pigment), ($PigmentStack), ($IPigmentTank)>
 "extractPigmentCheck"(tank: integer, side: $Direction$Type): boolean
 "insertPigmentCheck"(tank: integer, side: $Direction$Type): boolean
 "getPigmentManager"(): $ChemicalHandlerManager$PigmentHandlerManager
 "getPigmentTanks"(side: $Direction$Type): $List<($IPigmentTank)>
 "canHandlePigment"(): boolean
 "onContentsChanged"(): void
}

export namespace $IPigmentTile {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IPigmentTile$Type = ($IPigmentTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IPigmentTile_ = $IPigmentTile$Type;
}}
declare module "packages/mekanism/common/item/block/machine/$ItemBlockFactory" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemBlockMachine, $ItemBlockMachine$Type} from "packages/mekanism/common/item/block/machine/$ItemBlockMachine"
import {$BlockFactoryMachine$BlockFactory, $BlockFactoryMachine$BlockFactory$Type} from "packages/mekanism/common/block/prefab/$BlockFactoryMachine$BlockFactory"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockFactory extends $ItemBlockMachine {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockFactoryMachine$BlockFactory$Type<(any)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockFactory$Type = ($ItemBlockFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockFactory_ = $ItemBlockFactory$Type;
}}
declare module "packages/mekanism/common/content/transporter/$TransporterPathfinder$Destination" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest$TransitResponse"
import {$TransporterStack$Path, $TransporterStack$Path$Type} from "packages/mekanism/common/content/transporter/$TransporterStack$Path"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $TransporterPathfinder$Destination implements $Comparable<($TransporterPathfinder$Destination)> {

constructor(list: $List$Type<($BlockPos$Type)>, inv: boolean, ret: $TransitRequest$TransitResponse$Type, gScore: double)

public "equals"(o: any): boolean
public "hashCode"(): integer
public "compareTo"(dest: $TransporterPathfinder$Destination$Type): integer
public "getPath"(): $List<($BlockPos)>
public "getResponse"(): $TransitRequest$TransitResponse
public "getPathType"(): $TransporterStack$Path
public "setPathType"(type: $TransporterStack$Path$Type): $TransporterPathfinder$Destination
get "path"(): $List<($BlockPos)>
get "response"(): $TransitRequest$TransitResponse
get "pathType"(): $TransporterStack$Path
set "pathType"(value: $TransporterStack$Path$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransporterPathfinder$Destination$Type = ($TransporterPathfinder$Destination);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransporterPathfinder$Destination_ = $TransporterPathfinder$Destination$Type;
}}
declare module "packages/mekanism/common/block/$BlockCardboardBox" {
import {$IStateStorage, $IStateStorage$Type} from "packages/mekanism/common/block/states/$IStateStorage"
import {$TileEntityCardboardBox, $TileEntityCardboardBox$Type} from "packages/mekanism/common/tile/$TileEntityCardboardBox"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$IHasTileEntity, $IHasTileEntity$Type} from "packages/mekanism/common/block/interfaces/$IHasTileEntity"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$BlockMekanism, $BlockMekanism$Type} from "packages/mekanism/common/block/$BlockMekanism"

export class $BlockCardboardBox extends $BlockMekanism implements $IStateStorage, $IHasTileEntity<($TileEntityCardboardBox)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor()

/**
 * 
 * @deprecated
 */
public "use"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
public "getTileType"(): $TileEntityTypeRegistryObject<($TileEntityCardboardBox)>
public "getCloneItemStack"(state: $BlockState$Type, target: $HitResult$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, player: $Player$Type): $ItemStack
public "createDummyBlockEntity"(state: $BlockState$Type): $TileEntityCardboardBox
public "createDummyBlockEntity"(): $TileEntityCardboardBox
public "triggerBlockEntityEvent"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, id: integer, param: integer): boolean
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $TileEntityCardboardBox
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
get "tileType"(): $TileEntityTypeRegistryObject<($TileEntityCardboardBox)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockCardboardBox$Type = ($BlockCardboardBox);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockCardboardBox_ = $BlockCardboardBox$Type;
}}
declare module "packages/mekanism/common/lib/inventory/$TransitRequest$TransitResponse" {
import {$TransitRequest$ItemData, $TransitRequest$ItemData$Type} from "packages/mekanism/common/lib/inventory/$TransitRequest$ItemData"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $TransitRequest$TransitResponse {

constructor(inserted: $ItemStack$Type, slotData: $TransitRequest$ItemData$Type)

public "equals"(o: any): boolean
public "hashCode"(): integer
public "isEmpty"(): boolean
public "getStack"(): $ItemStack
public "use"(amount: integer): $ItemStack
public "useAll"(): $ItemStack
public "getSendingAmount"(): integer
public "getRejected"(): $ItemStack
public "getSlotData"(): $TransitRequest$ItemData
get "empty"(): boolean
get "stack"(): $ItemStack
get "sendingAmount"(): integer
get "rejected"(): $ItemStack
get "slotData"(): $TransitRequest$ItemData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransitRequest$TransitResponse$Type = ($TransitRequest$TransitResponse);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransitRequest$TransitResponse_ = $TransitRequest$TransitResponse$Type;
}}
declare module "packages/mekanism/common/inventory/container/slot/$SlotOverlay" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $SlotOverlay extends $Enum<($SlotOverlay)> {
static readonly "MINUS": $SlotOverlay
static readonly "PLUS": $SlotOverlay
static readonly "POWER": $SlotOverlay
static readonly "INPUT": $SlotOverlay
static readonly "OUTPUT": $SlotOverlay
static readonly "CHECK": $SlotOverlay
static readonly "X": $SlotOverlay
static readonly "FORMULA": $SlotOverlay
static readonly "UPGRADE": $SlotOverlay
static readonly "SELECT": $SlotOverlay
static readonly "MODULE": $SlotOverlay


public static "values"(): ($SlotOverlay)[]
public static "valueOf"(name: string): $SlotOverlay
public "getTexture"(): $ResourceLocation
public "getWidth"(): integer
public "getHeight"(): integer
get "texture"(): $ResourceLocation
get "width"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotOverlay$Type = (("output") | ("minus") | ("input") | ("select") | ("upgrade") | ("module") | ("x") | ("formula") | ("power") | ("check") | ("plus")) | ($SlotOverlay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotOverlay_ = $SlotOverlay$Type;
}}
declare module "packages/mekanism/common/tile/component/config/slot/$BaseSlotInfo" {
import {$ISlotInfo, $ISlotInfo$Type} from "packages/mekanism/common/tile/component/config/slot/$ISlotInfo"

export class $BaseSlotInfo implements $ISlotInfo {


public "canInput"(): boolean
public "canOutput"(): boolean
public "isEnabled"(): boolean
get "enabled"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseSlotInfo$Type = ($BaseSlotInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseSlotInfo_ = $BaseSlotInfo$Type;
}}
declare module "packages/mekanism/common/item/block/$ItemBlockTooltip" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemBlockMekanism, $ItemBlockMekanism$Type} from "packages/mekanism/common/item/block/$ItemBlockMekanism"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IHasDescription, $IHasDescription$Type} from "packages/mekanism/common/block/interfaces/$IHasDescription"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockTooltip<BLOCK extends ($Block) & ($IHasDescription)> extends $ItemBlockMekanism<(BLOCK)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: BLOCK)
constructor(block: BLOCK, properties: $Item$Properties$Type)

public "placeBlock"(context: $BlockPlaceContext$Type, state: $BlockState$Type): boolean
public "onDestroyed"(item: $ItemEntity$Type, damageSource: $DamageSource$Type): void
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockTooltip$Type<BLOCK> = ($ItemBlockTooltip<(BLOCK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockTooltip_<BLOCK> = $ItemBlockTooltip$Type<(BLOCK)>;
}}
declare module "packages/mekanism/common/item/block/$ItemBlockResource" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemBlockMekanism, $ItemBlockMekanism$Type} from "packages/mekanism/common/item/block/$ItemBlockMekanism"
import {$BlockResource, $BlockResource$Type} from "packages/mekanism/common/block/basic/$BlockResource"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockResource extends $ItemBlockMekanism<($BlockResource)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockResource$Type, properties: $Item$Properties$Type)

public "getBurnTime"(itemStack: $ItemStack$Type, recipeType: $RecipeType$Type<(any)>): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockResource$Type = ($ItemBlockResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockResource_ = $ItemBlockResource$Type;
}}
declare module "packages/mekanism/common/lib/radial/$IRadialEnumModeItem" {
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IIncrementalEnum, $IIncrementalEnum$Type} from "packages/mekanism/api/$IIncrementalEnum"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$IRadialModeItem, $IRadialModeItem$Type} from "packages/mekanism/common/lib/radial/$IRadialModeItem"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IRadialMode, $IRadialMode$Type} from "packages/mekanism/api/radial/mode/$IRadialMode"
import {$RadialData, $RadialData$Type} from "packages/mekanism/api/radial/$RadialData"

export interface $IRadialEnumModeItem<MODE extends ($Enum<(MODE)>) & ($IIncrementalEnum<(MODE)>) & ($IRadialMode)> extends $IRadialModeItem<(MODE)> {

 "setMode"(stack: $ItemStack$Type, player: $Player$Type, mode: MODE): void
 "getModeSaveKey"(): string
 "getModeByIndex"(ordinal: integer): MODE
 "setMode"<M extends $IRadialMode>(stack: $ItemStack$Type, player: $Player$Type, radialData: $RadialData$Type<(M)>, mode: M): void
 "getMode"<M extends $IRadialMode>(stack: $ItemStack$Type, radialData: $RadialData$Type<(M)>): M
 "getRadialData"(stack: $ItemStack$Type): $RadialData<(MODE)>
 "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
 "getScrollTextComponent"(stack: $ItemStack$Type): $Component
 "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
}

export namespace $IRadialEnumModeItem {
function displayModeChange(player: $Player$Type): void
function isModeItem(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
function isModeItem(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
function isModeItem(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRadialEnumModeItem$Type<MODE> = ($IRadialEnumModeItem<(MODE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRadialEnumModeItem_<MODE> = $IRadialEnumModeItem$Type<(MODE)>;
}}
declare module "packages/mekanism/common/tile/interfaces/$IUpgradeTile" {
import {$Upgrade, $Upgrade$Type} from "packages/mekanism/api/$Upgrade"
import {$TileComponentUpgrade, $TileComponentUpgrade$Type} from "packages/mekanism/common/tile/component/$TileComponentUpgrade"

export interface $IUpgradeTile {

 "recalculateUpgrades"(upgradeType: $Upgrade$Type): void
 "supportsUpgrades"(): boolean
 "supportsUpgrade"(upgradeType: $Upgrade$Type): boolean
 "getComponent"(): $TileComponentUpgrade
}

export namespace $IUpgradeTile {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IUpgradeTile$Type = ($IUpgradeTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IUpgradeTile_ = $IUpgradeTile$Type;
}}
declare module "packages/mekanism/common/capabilities/fluid/$FluidTankFluidTank" {
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$BasicFluidTank, $BasicFluidTank$Type} from "packages/mekanism/common/capabilities/fluid/$BasicFluidTank"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$TileEntityFluidTank, $TileEntityFluidTank$Type} from "packages/mekanism/common/tile/$TileEntityFluidTank"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"

export class $FluidTankFluidTank extends $BasicFluidTank {
static readonly "alwaysTrue": $Predicate<($FluidStack)>
static readonly "alwaysFalse": $Predicate<($FluidStack)>
static readonly "alwaysTrueBi": $BiPredicate<($FluidStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($FluidStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($FluidStack), ($AutomationType)>


public "extract"(amount: integer, action: $Action$Type, automationType: $AutomationType$Type): $FluidStack
public "insert"(stack: $FluidStack$Type, action: $Action$Type, automationType: $AutomationType$Type): $FluidStack
public static "create"(tile: $TileEntityFluidTank$Type, listener: $IContentsListener$Type): $FluidTankFluidTank
public "growStack"(amount: integer, action: $Action$Type): integer
public "setStackSize"(amount: integer, action: $Action$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankFluidTank$Type = ($FluidTankFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTankFluidTank_ = $FluidTankFluidTank$Type;
}}
declare module "packages/mekanism/common/item/block/$ItemBlockLaserAmplifier" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemBlockTooltip, $ItemBlockTooltip$Type} from "packages/mekanism/common/item/block/$ItemBlockTooltip"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$Type} from "packages/mekanism/common/block/prefab/$BlockTile$BlockTileModel"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$TileEntityLaserAmplifier, $TileEntityLaserAmplifier$Type} from "packages/mekanism/common/tile/laser/$TileEntityLaserAmplifier"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockLaserAmplifier extends $ItemBlockTooltip<($BlockTile$BlockTileModel<($TileEntityLaserAmplifier), ($BlockTypeTile<($TileEntityLaserAmplifier)>)>)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockTile$BlockTileModel$Type<($TileEntityLaserAmplifier$Type), ($BlockTypeTile$Type<($TileEntityLaserAmplifier$Type)>)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockLaserAmplifier$Type = ($ItemBlockLaserAmplifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockLaserAmplifier_ = $ItemBlockLaserAmplifier$Type;
}}
declare module "packages/mekanism/common/item/$ItemNetworkReader" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$ItemEnergized, $ItemEnergized$Type} from "packages/mekanism/common/item/$ItemEnergized"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemNetworkReader extends $ItemEnergized {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "useOn"(context: $UseOnContext$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemNetworkReader$Type = ($ItemNetworkReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemNetworkReader_ = $ItemNetworkReader$Type;
}}
declare module "packages/mekanism/common/content/network/transmitter/$DiversionTransporter" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$TransporterTier, $TransporterTier$Type} from "packages/mekanism/common/tier/$TransporterTier"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$LogisticalTransporterBase, $LogisticalTransporterBase$Type} from "packages/mekanism/common/content/network/transmitter/$LogisticalTransporterBase"
import {$DiversionTransporter$DiversionControl, $DiversionTransporter$DiversionControl$Type} from "packages/mekanism/common/content/network/transmitter/$DiversionTransporter$DiversionControl"

export class $DiversionTransporter extends $LogisticalTransporterBase {
readonly "modes": ($DiversionTransporter$DiversionControl)[]
readonly "tier": $TransporterTier
 "currentTransmitterConnections": byte

constructor(tile: $TileEntityTransmitter$Type)

public "write"(nbtTags: $CompoundTag$Type): $CompoundTag
public "read"(nbtTags: $CompoundTag$Type): void
public "canConnect"(side: $Direction$Type): boolean
public "onNeighborBlockChange"(side: $Direction$Type): void
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "onRightClick"(player: $Player$Type, side: $Direction$Type): $InteractionResult
public "getReducedUpdateTag"(updateTag: $CompoundTag$Type): $CompoundTag
public "updateMode"(side: $Direction$Type, mode: $DiversionTransporter$DiversionControl$Type): void
public "exposesInsertCap"(side: $Direction$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiversionTransporter$Type = ($DiversionTransporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DiversionTransporter_ = $DiversionTransporter$Type;
}}
declare module "packages/mekanism/common/item/interfaces/$IJetpackItem" {
import {$IJetpackItem$JetpackMode, $IJetpackItem$JetpackMode$Type} from "packages/mekanism/common/item/interfaces/$IJetpackItem$JetpackMode"
import {$BooleanSupplier, $BooleanSupplier$Type} from "packages/java/util/function/$BooleanSupplier"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export interface $IJetpackItem {

 "canUseJetpack"(stack: $ItemStack$Type): boolean
 "useJetpackFuel"(stack: $ItemStack$Type): void
 "getJetpackMode"(stack: $ItemStack$Type): $IJetpackItem$JetpackMode
}

export namespace $IJetpackItem {
function getPlayerJetpackMode(player: $Player$Type, mode: $IJetpackItem$JetpackMode$Type, ascendingSupplier: $BooleanSupplier$Type): $IJetpackItem$JetpackMode
function getActiveJetpack(entity: $LivingEntity$Type): $ItemStack
function getPrimaryJetpack(entity: $LivingEntity$Type): $ItemStack
function handleJetpackMotion(player: $Player$Type, mode: $IJetpackItem$JetpackMode$Type, ascendingSupplier: $BooleanSupplier$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IJetpackItem$Type = ($IJetpackItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IJetpackItem_ = $IJetpackItem$Type;
}}
declare module "packages/mekanism/common/content/qio/$IQIOCraftingWindowHolder" {
import {$QIOFrequency, $QIOFrequency$Type} from "packages/mekanism/common/content/qio/$QIOFrequency"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$QIOCraftingWindow, $QIOCraftingWindow$Type} from "packages/mekanism/common/content/qio/$QIOCraftingWindow"

export interface $IQIOCraftingWindowHolder extends $IContentsListener {

 "getFrequency"(): $QIOFrequency
 "getCraftingWindows"(): ($QIOCraftingWindow)[]
 "getHolderWorld"(): $Level
 "onContentsChanged"(): void
}

export namespace $IQIOCraftingWindowHolder {
const MAX_CRAFTING_WINDOWS: byte
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IQIOCraftingWindowHolder$Type = ($IQIOCraftingWindowHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IQIOCraftingWindowHolder_ = $IQIOCraftingWindowHolder$Type;
}}
declare module "packages/mekanism/common/tile/$TileEntityIndustrialAlarm" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"

export class $TileEntityIndustrialAlarm extends $TileEntityMekanism {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "getRenderBoundingBox"(): $AABB
public "onPowerChange"(): void
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "renderBoundingBox"(): $AABB
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityIndustrialAlarm$Type = ($TileEntityIndustrialAlarm);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityIndustrialAlarm_ = $TileEntityIndustrialAlarm$Type;
}}
declare module "packages/mekanism/common/capabilities/fluid/$BasicFluidTank" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$IExtendedFluidTank, $IExtendedFluidTank$Type} from "packages/mekanism/api/fluid/$IExtendedFluidTank"

export class $BasicFluidTank implements $IExtendedFluidTank {
static readonly "alwaysTrue": $Predicate<($FluidStack)>
static readonly "alwaysFalse": $Predicate<($FluidStack)>
static readonly "alwaysTrueBi": $BiPredicate<($FluidStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($FluidStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($FluidStack), ($AutomationType)>


public "extract"(amount: integer, action: $Action$Type, automationType: $AutomationType$Type): $FluidStack
public "insert"(stack: $FluidStack$Type, action: $Action$Type, automationType: $AutomationType$Type): $FluidStack
public "isEmpty"(): boolean
public static "create"(capacity: integer, validator: $Predicate$Type<($FluidStack$Type)>, listener: $IContentsListener$Type): $BasicFluidTank
public static "create"(capacity: integer, canExtract: $Predicate$Type<($FluidStack$Type)>, canInsert: $Predicate$Type<($FluidStack$Type)>, listener: $IContentsListener$Type): $BasicFluidTank
public static "create"(capacity: integer, canExtract: $Predicate$Type<($FluidStack$Type)>, canInsert: $Predicate$Type<($FluidStack$Type)>, validator: $Predicate$Type<($FluidStack$Type)>, listener: $IContentsListener$Type): $BasicFluidTank
public static "create"(capacity: integer, canExtract: $BiPredicate$Type<($FluidStack$Type), ($AutomationType$Type)>, canInsert: $BiPredicate$Type<($FluidStack$Type), ($AutomationType$Type)>, validator: $Predicate$Type<($FluidStack$Type)>, listener: $IContentsListener$Type): $BasicFluidTank
public static "create"(capacity: integer, listener: $IContentsListener$Type): $BasicFluidTank
public static "input"(capacity: integer, validator: $Predicate$Type<($FluidStack$Type)>, listener: $IContentsListener$Type): $BasicFluidTank
public static "input"(capacity: integer, canInsert: $Predicate$Type<($FluidStack$Type)>, validator: $Predicate$Type<($FluidStack$Type)>, listener: $IContentsListener$Type): $BasicFluidTank
public static "output"(capacity: integer, listener: $IContentsListener$Type): $BasicFluidTank
public "getCapacity"(): integer
public "setStack"(stack: $FluidStack$Type): void
public "isFluidValid"(stack: $FluidStack$Type): boolean
public "onContentsChanged"(): void
public "isFluidEqual"(other: $FluidStack$Type): boolean
public "deserializeNBT"(nbt: $CompoundTag$Type): void
public "getFluid"(): $FluidStack
public "growStack"(amount: integer, action: $Action$Type): integer
public "getFluidAmount"(): integer
public "setStackUnchecked"(stack: $FluidStack$Type): void
public "setStackSize"(amount: integer, action: $Action$Type): integer
/**
 * 
 * @deprecated
 */
public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
/**
 * 
 * @deprecated
 */
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "setEmpty"(): void
public "shrinkStack"(arg0: integer, arg1: $Action$Type): integer
public "getNeeded"(): integer
get "empty"(): boolean
get "capacity"(): integer
set "stack"(value: $FluidStack$Type)
get "fluid"(): $FluidStack
get "fluidAmount"(): integer
set "stackUnchecked"(value: $FluidStack$Type)
get "needed"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicFluidTank$Type = ($BasicFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicFluidTank_ = $BasicFluidTank$Type;
}}
declare module "packages/mekanism/common/lib/transmitter/acceptor/$AcceptorCache" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$AcceptorCache$AcceptorInfo, $AcceptorCache$AcceptorInfo$Type} from "packages/mekanism/common/lib/transmitter/acceptor/$AcceptorCache$AcceptorInfo"
import {$AbstractAcceptorCache, $AbstractAcceptorCache$Type} from "packages/mekanism/common/lib/transmitter/acceptor/$AbstractAcceptorCache"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$Transmitter, $Transmitter$Type} from "packages/mekanism/common/content/network/transmitter/$Transmitter"

export class $AcceptorCache<ACCEPTOR> extends $AbstractAcceptorCache<(ACCEPTOR), ($AcceptorCache$AcceptorInfo<(ACCEPTOR)>)> {
 "currentAcceptorConnections": byte

constructor(transmitter: $Transmitter$Type<(ACCEPTOR), (any), (any)>, transmitterTile: $TileEntityTransmitter$Type)

public "isAcceptorAndListen"(tile: $BlockEntity$Type, side: $Direction$Type, capability: $Capability$Type<(ACCEPTOR)>): boolean
public "getConnectedAcceptorTile"(side: $Direction$Type): $BlockEntity
public "getConnectedAcceptor"(side: $Direction$Type): $LazyOptional<(ACCEPTOR)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AcceptorCache$Type<ACCEPTOR> = ($AcceptorCache<(ACCEPTOR)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AcceptorCache_<ACCEPTOR> = $AcceptorCache$Type<(ACCEPTOR)>;
}}
declare module "packages/mekanism/common/integration/computer/$Convertable" {
import {$BaseComputerHelper, $BaseComputerHelper$Type} from "packages/mekanism/common/integration/computer/$BaseComputerHelper"
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export class $Convertable<RAW> {


public "convert"(helper: $BaseComputerHelper$Type): any
public static "of"(value: $FluidStack$Type): $Convertable<($FluidStack)>
public static "of"(value: $ChemicalStack$Type<(any)>): $Convertable<($ChemicalStack<(any)>)>
public static "of"<RAW>(value: RAW, converter: $BiFunction$Type<($BaseComputerHelper$Type), (RAW), (any)>): $Convertable<(RAW)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Convertable$Type<RAW> = ($Convertable<(RAW)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Convertable_<RAW> = $Convertable$Type<(RAW)>;
}}
declare module "packages/mekanism/common/inventory/container/slot/$IVirtualSlot" {
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IGUIWindow, $IGUIWindow$Type} from "packages/mekanism/common/inventory/container/$IGUIWindow"

export interface $IVirtualSlot {

 "getSlot"(): $Slot
 "updatePosition"(window: $IGUIWindow$Type, xPositionSupplier: $IntSupplier$Type, yPositionSupplier: $IntSupplier$Type): void
 "getActualX"(): integer
 "shouldDrawOverlay"(): boolean
 "getActualY"(): integer
 "getLinkedWindow"(): $IGUIWindow
 "updateRenderInfo"(stackToRender: $ItemStack$Type, shouldDrawOverlay: boolean, tooltipOverride: string): void
 "getTooltipOverride"(): string
 "getStackToRender"(): $ItemStack
}

export namespace $IVirtualSlot {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IVirtualSlot$Type = ($IVirtualSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IVirtualSlot_ = $IVirtualSlot$Type;
}}
declare module "packages/mekanism/common/tier/$FluidTankTier" {
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"
import {$CachedIntValue, $CachedIntValue$Type} from "packages/mekanism/common/config/value/$CachedIntValue"

export class $FluidTankTier extends $Enum<($FluidTankTier)> implements $ITier {
static readonly "BASIC": $FluidTankTier
static readonly "ADVANCED": $FluidTankTier
static readonly "ELITE": $FluidTankTier
static readonly "ULTIMATE": $FluidTankTier
static readonly "CREATIVE": $FluidTankTier


public static "values"(): ($FluidTankTier)[]
public static "valueOf"(name: string): $FluidTankTier
public "getOutput"(): integer
public "getBaseStorage"(): integer
public "getBaseTier"(): $BaseTier
public "getStorage"(): integer
public "getBaseOutput"(): integer
public "setConfigReference"(storageReference: $CachedIntValue$Type, outputReference: $CachedIntValue$Type): void
get "output"(): integer
get "baseStorage"(): integer
get "baseTier"(): $BaseTier
get "storage"(): integer
get "baseOutput"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankTier$Type = (("elite") | ("advanced") | ("ultimate") | ("basic") | ("creative")) | ($FluidTankTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTankTier_ = $FluidTankTier$Type;
}}
declare module "packages/mekanism/common/lib/math/voxel/$BlockPosBuilder" {
import {$Structure$Axis, $Structure$Axis$Type} from "packages/mekanism/common/lib/multiblock/$Structure$Axis"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockPosBuilder {

constructor()

public "get"(axis: $Structure$Axis$Type): integer
public "set"(axis: $Structure$Axis$Type, value: integer): void
public "isSet"(axis: $Structure$Axis$Type): boolean
public "build"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPosBuilder$Type = ($BlockPosBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPosBuilder_ = $BlockPosBuilder$Type;
}}
declare module "packages/mekanism/common/inventory/container/type/$MekanismContainerType$IMekanismContainerFactory" {
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export interface $MekanismContainerType$IMekanismContainerFactory<T, CONTAINER extends $AbstractContainerMenu> {

 "create"(id: integer, inv: $Inventory$Type, data: T): CONTAINER

(id: integer, inv: $Inventory$Type, data: T): CONTAINER
}

export namespace $MekanismContainerType$IMekanismContainerFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismContainerType$IMekanismContainerFactory$Type<T, CONTAINER> = ($MekanismContainerType$IMekanismContainerFactory<(T), (CONTAINER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismContainerType$IMekanismContainerFactory_<T, CONTAINER> = $MekanismContainerType$IMekanismContainerFactory$Type<(T), (CONTAINER)>;
}}
declare module "packages/mekanism/common/tier/$InductionCellTier" {
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"
import {$CachedFloatingLongValue, $CachedFloatingLongValue$Type} from "packages/mekanism/common/config/value/$CachedFloatingLongValue"

export class $InductionCellTier extends $Enum<($InductionCellTier)> implements $ITier {
static readonly "BASIC": $InductionCellTier
static readonly "ADVANCED": $InductionCellTier
static readonly "ELITE": $InductionCellTier
static readonly "ULTIMATE": $InductionCellTier


public static "values"(): ($InductionCellTier)[]
public static "valueOf"(name: string): $InductionCellTier
public "getBaseMaxEnergy"(): $FloatingLong
public "getBaseTier"(): $BaseTier
public "setConfigReference"(storageReference: $CachedFloatingLongValue$Type): void
public "getMaxEnergy"(): $FloatingLong
get "baseMaxEnergy"(): $FloatingLong
get "baseTier"(): $BaseTier
set "configReference"(value: $CachedFloatingLongValue$Type)
get "maxEnergy"(): $FloatingLong
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InductionCellTier$Type = (("elite") | ("advanced") | ("ultimate") | ("basic")) | ($InductionCellTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InductionCellTier_ = $InductionCellTier$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemJetpack" {
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BooleanSupplier, $BooleanSupplier$Type} from "packages/java/util/function/$BooleanSupplier"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$IJetpackItem, $IJetpackItem$Type} from "packages/mekanism/common/item/interfaces/$IJetpackItem"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$IJetpackItem$JetpackMode, $IJetpackItem$JetpackMode$Type} from "packages/mekanism/common/item/interfaces/$IJetpackItem$JetpackMode"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemGasArmor, $ItemGasArmor$Type} from "packages/mekanism/common/item/gear/$ItemGasArmor"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$IModeItem, $IModeItem$Type} from "packages/mekanism/common/item/interfaces/$IModeItem"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$DispenseItemBehavior, $DispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DispenseItemBehavior"
import {$IItemHUDProvider, $IItemHUDProvider$Type} from "packages/mekanism/common/item/interfaces/$IItemHUDProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemJetpack extends $ItemGasArmor implements $IItemHUDProvider, $IModeItem, $IJetpackItem {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)
constructor(material: $ArmorMaterial$Type, properties: $Item$Properties$Type)

public "setMode"(stack: $ItemStack$Type, mode: $IJetpackItem$JetpackMode$Type): void
public "initializeClient"(consumer: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "getDefaultTooltipHideFlags"(stack: $ItemStack$Type): integer
public "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "addHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): void
public "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
public "canUseJetpack"(stack: $ItemStack$Type): boolean
public "useJetpackFuel"(stack: $ItemStack$Type): void
public "getJetpackMode"(stack: $ItemStack$Type): $IJetpackItem$JetpackMode
public "addCurioHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type): void
public static "displayModeChange"(player: $Player$Type): void
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
public "getScrollTextComponent"(stack: $ItemStack$Type): $Component
public static "getPlayerJetpackMode"(player: $Player$Type, mode: $IJetpackItem$JetpackMode$Type, ascendingSupplier: $BooleanSupplier$Type): $IJetpackItem$JetpackMode
public static "getActiveJetpack"(entity: $LivingEntity$Type): $ItemStack
public static "getPrimaryJetpack"(entity: $LivingEntity$Type): $ItemStack
public static "handleJetpackMotion"(player: $Player$Type, mode: $IJetpackItem$JetpackMode$Type, ascendingSupplier: $BooleanSupplier$Type): boolean
public static "get"(arg0: $ItemStack$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemJetpack$Type = ($ItemJetpack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemJetpack_ = $ItemJetpack$Type;
}}
declare module "packages/mekanism/common/config/value/$CachedIntValue" {
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$IMekanismConfig, $IMekanismConfig$Type} from "packages/mekanism/common/config/$IMekanismConfig"
import {$ForgeConfigSpec$ConfigValue, $ForgeConfigSpec$ConfigValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue"
import {$CachedValue, $CachedValue$Type} from "packages/mekanism/common/config/value/$CachedValue"

export class $CachedIntValue extends $CachedValue<(integer)> implements $IntSupplier {


public "get"(): integer
public static "wrap"(config: $IMekanismConfig$Type, internal: $ForgeConfigSpec$ConfigValue$Type<(integer)>): $CachedIntValue
public "set"(value: integer): void
public "getOrDefault"(): integer
public "getAsInt"(): integer
get "orDefault"(): integer
get "asInt"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedIntValue$Type = ($CachedIntValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedIntValue_ = $CachedIntValue$Type;
}}
declare module "packages/mekanism/common/content/network/transmitter/$IUpgradeableTransmitter" {
import {$TransmitterUpgradeData, $TransmitterUpgradeData$Type} from "packages/mekanism/common/upgrade/transmitter/$TransmitterUpgradeData"
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$AlloyTier, $AlloyTier$Type} from "packages/mekanism/api/tier/$AlloyTier"

export interface $IUpgradeableTransmitter<DATA extends $TransmitterUpgradeData> {

 "getTier"(): $ITier
 "getUpgradeData"(): DATA
 "parseUpgradeData"(data: DATA): void
 "canUpgrade"(alloyTier: $AlloyTier$Type): boolean
 "dataTypeMatches"(data: $TransmitterUpgradeData$Type): boolean
}

export namespace $IUpgradeableTransmitter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IUpgradeableTransmitter$Type<DATA> = ($IUpgradeableTransmitter<(DATA)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IUpgradeableTransmitter_<DATA> = $IUpgradeableTransmitter$Type<(DATA)>;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$SingleFluid" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$FluidStackIngredient, $FluidStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$FluidStackIngredient"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$SingleInputRecipeCache, $SingleInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$SingleInputRecipeCache"
import {$MekanismRecipeType, $MekanismRecipeType$Type} from "packages/mekanism/common/recipe/$MekanismRecipeType"
import {$FluidInputCache, $FluidInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$FluidInputCache"

export class $InputRecipeCache$SingleFluid<RECIPE extends ($MekanismRecipe) & ($Predicate<($FluidStack)>)> extends $SingleInputRecipeCache<($FluidStack), ($FluidStackIngredient), (RECIPE), ($FluidInputCache<(RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$Type<(RECIPE), (any)>, inputExtractor: $Function$Type<(RECIPE), ($FluidStackIngredient$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$SingleFluid$Type<RECIPE> = ($InputRecipeCache$SingleFluid<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$SingleFluid_<RECIPE> = $InputRecipeCache$SingleFluid$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/item/block/machine/$ItemBlockQuantumEntangloporter" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemBlockTooltip, $ItemBlockTooltip$Type} from "packages/mekanism/common/item/block/$ItemBlockTooltip"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$Type} from "packages/mekanism/common/block/prefab/$BlockTile$BlockTileModel"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$TileEntityQuantumEntangloporter, $TileEntityQuantumEntangloporter$Type} from "packages/mekanism/common/tile/$TileEntityQuantumEntangloporter"

export class $ItemBlockQuantumEntangloporter extends $ItemBlockTooltip<($BlockTile$BlockTileModel<($TileEntityQuantumEntangloporter), ($BlockTypeTile<($TileEntityQuantumEntangloporter)>)>)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockTile$BlockTileModel$Type<($TileEntityQuantumEntangloporter$Type), ($BlockTypeTile$Type<($TileEntityQuantumEntangloporter$Type)>)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockQuantumEntangloporter$Type = ($ItemBlockQuantumEntangloporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockQuantumEntangloporter_ = $ItemBlockQuantumEntangloporter$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$EitherSideChemical" {
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$ChemicalStackIngredient, $ChemicalStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient"
import {$ChemicalChemicalToChemicalRecipe, $ChemicalChemicalToChemicalRecipe$Type} from "packages/mekanism/api/recipes/chemical/$ChemicalChemicalToChemicalRecipe"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$ChemicalInputCache, $ChemicalInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$ChemicalInputCache"
import {$MekanismRecipeType, $MekanismRecipeType$Type} from "packages/mekanism/common/recipe/$MekanismRecipeType"
import {$EitherSideInputRecipeCache, $EitherSideInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$EitherSideInputRecipeCache"

export class $InputRecipeCache$EitherSideChemical<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, RECIPE extends $ChemicalChemicalToChemicalRecipe<(CHEMICAL), (STACK), (any)>> extends $EitherSideInputRecipeCache<(STACK), ($ChemicalStackIngredient<(CHEMICAL), (STACK)>), (RECIPE), ($ChemicalInputCache<(CHEMICAL), (STACK), (RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$Type<(RECIPE), (any)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$EitherSideChemical$Type<CHEMICAL, STACK, RECIPE> = ($InputRecipeCache$EitherSideChemical<(CHEMICAL), (STACK), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$EitherSideChemical_<CHEMICAL, STACK, RECIPE> = $InputRecipeCache$EitherSideChemical$Type<(CHEMICAL), (STACK), (RECIPE)>;
}}
declare module "packages/mekanism/common/recipe/lookup/$IRecipeLookupHandler" {
import {$CachedRecipe, $CachedRecipe$Type} from "packages/mekanism/api/recipes/cache/$CachedRecipe"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$IMekanismRecipeTypeProvider, $IMekanismRecipeTypeProvider$Type} from "packages/mekanism/common/recipe/$IMekanismRecipeTypeProvider"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"

export interface $IRecipeLookupHandler<RECIPE extends $MekanismRecipe> extends $IContentsListener {

 "getRecipeType"(): $IMekanismRecipeTypeProvider<(RECIPE), (any)>
 "getRecipe"(cacheIndex: integer): RECIPE
 "clearRecipeErrors"(cacheIndex: integer): void
 "getHandlerWorld"(): $Level
 "createNewCachedRecipe"(recipe: RECIPE, cacheIndex: integer): $CachedRecipe<(RECIPE)>
 "getSavedOperatingTicks"(cacheIndex: integer): integer
 "onCachedRecipeChanged"(cachedRecipe: $CachedRecipe$Type<(RECIPE)>, cacheIndex: integer): void
 "onContentsChanged"(): void
}

export namespace $IRecipeLookupHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRecipeLookupHandler$Type<RECIPE> = ($IRecipeLookupHandler<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRecipeLookupHandler_<RECIPE> = $IRecipeLookupHandler$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/item/$ItemConfigurator$ConfiguratorMode" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IIncrementalEnum, $IIncrementalEnum$Type} from "packages/mekanism/api/$IIncrementalEnum"
import {$IHasTextComponent, $IHasTextComponent$Type} from "packages/mekanism/api/text/$IHasTextComponent"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TransmissionType, $TransmissionType$Type} from "packages/mekanism/common/lib/transmitter/$TransmissionType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IRadialMode, $IRadialMode$Type} from "packages/mekanism/api/radial/mode/$IRadialMode"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"

export class $ItemConfigurator$ConfiguratorMode extends $Enum<($ItemConfigurator$ConfiguratorMode)> implements $IIncrementalEnum<($ItemConfigurator$ConfiguratorMode)>, $IHasTextComponent, $IRadialMode {
static readonly "CONFIGURATE_ITEMS": $ItemConfigurator$ConfiguratorMode
static readonly "CONFIGURATE_FLUIDS": $ItemConfigurator$ConfiguratorMode
static readonly "CONFIGURATE_GASES": $ItemConfigurator$ConfiguratorMode
static readonly "CONFIGURATE_INFUSE_TYPES": $ItemConfigurator$ConfiguratorMode
static readonly "CONFIGURATE_PIGMENTS": $ItemConfigurator$ConfiguratorMode
static readonly "CONFIGURATE_SLURRIES": $ItemConfigurator$ConfiguratorMode
static readonly "CONFIGURATE_ENERGY": $ItemConfigurator$ConfiguratorMode
static readonly "CONFIGURATE_HEAT": $ItemConfigurator$ConfiguratorMode
static readonly "EMPTY": $ItemConfigurator$ConfiguratorMode
static readonly "ROTATE": $ItemConfigurator$ConfiguratorMode
static readonly "WRENCH": $ItemConfigurator$ConfiguratorMode


public static "values"(): ($ItemConfigurator$ConfiguratorMode)[]
public static "valueOf"(name: string): $ItemConfigurator$ConfiguratorMode
public "color"(): $EnumColor
public "icon"(): $ResourceLocation
public "sliceName"(): $Component
public "getTransmission"(): $TransmissionType
public "getTextComponent"(): $Component
public static "byIndexStatic"(index: integer): $ItemConfigurator$ConfiguratorMode
public "isConfigurating"(): boolean
public "ordinal"(): integer
public "adjust"(arg0: integer): $ItemConfigurator$ConfiguratorMode
public "adjust"(arg0: integer, arg1: $Predicate$Type<($ItemConfigurator$ConfiguratorMode$Type)>): $ItemConfigurator$ConfiguratorMode
public "getNext"(arg0: $Predicate$Type<($ItemConfigurator$ConfiguratorMode$Type)>): $ItemConfigurator$ConfiguratorMode
public "getNext"(): $ItemConfigurator$ConfiguratorMode
public "getPrevious"(): $ItemConfigurator$ConfiguratorMode
public "getPrevious"(arg0: $Predicate$Type<($ItemConfigurator$ConfiguratorMode$Type)>): $ItemConfigurator$ConfiguratorMode
get "transmission"(): $TransmissionType
get "textComponent"(): $Component
get "configurating"(): boolean
get "next"(): $ItemConfigurator$ConfiguratorMode
get "previous"(): $ItemConfigurator$ConfiguratorMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemConfigurator$ConfiguratorMode$Type = (("rotate") | ("configurate_energy") | ("configurate_fluids") | ("configurate_gases") | ("configurate_slurries") | ("configurate_infuse_types") | ("configurate_items") | ("configurate_pigments") | ("configurate_heat") | ("empty") | ("wrench")) | ($ItemConfigurator$ConfiguratorMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemConfigurator$ConfiguratorMode_ = $ItemConfigurator$ConfiguratorMode$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ItemStackToPigmentRecipeSerializer" {
import {$ItemStackToChemicalRecipeSerializer, $ItemStackToChemicalRecipeSerializer$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackToChemicalRecipeSerializer"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$Pigment, $Pigment$Type} from "packages/mekanism/api/chemical/pigment/$Pigment"
import {$ItemStackToChemicalRecipeSerializer$IFactory, $ItemStackToChemicalRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackToChemicalRecipeSerializer$IFactory"
import {$ItemStackToPigmentRecipe, $ItemStackToPigmentRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackToPigmentRecipe"
import {$PigmentStack, $PigmentStack$Type} from "packages/mekanism/api/chemical/pigment/$PigmentStack"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ItemStackToPigmentRecipeSerializer<RECIPE extends $ItemStackToPigmentRecipe> extends $ItemStackToChemicalRecipeSerializer<($Pigment), ($PigmentStack), (RECIPE)> {

constructor(factory: $ItemStackToChemicalRecipeSerializer$IFactory$Type<($Pigment$Type), ($PigmentStack$Type), (RECIPE)>)

public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackToPigmentRecipeSerializer$Type<RECIPE> = ($ItemStackToPigmentRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackToPigmentRecipeSerializer_<RECIPE> = $ItemStackToPigmentRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/content/teleporter/$TeleporterFrequency" {
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IColorableFrequency, $IColorableFrequency$Type} from "packages/mekanism/common/lib/frequency/$IColorableFrequency"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"

export class $TeleporterFrequency extends $Frequency implements $IColorableFrequency {

constructor(n: string, uuid: $UUID$Type)
constructor()

public "update"(tile: $BlockEntity$Type): boolean
public "write"(buffer: $FriendlyByteBuf$Type): void
public "write"(nbtTags: $CompoundTag$Type): void
public "setColor"(color: $EnumColor$Type): void
public "getColor"(): $EnumColor
public "onDeactivate"(tile: $BlockEntity$Type): boolean
public "getSyncHash"(): integer
public "getActiveCoords"(): $Set<($Coord4D)>
public "getClosestCoords"(coord: $Coord4D$Type): $Coord4D
set "color"(value: $EnumColor$Type)
get "color"(): $EnumColor
get "syncHash"(): integer
get "activeCoords"(): $Set<($Coord4D)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TeleporterFrequency$Type = ($TeleporterFrequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TeleporterFrequency_ = $TeleporterFrequency$Type;
}}
declare module "packages/mekanism/common/tile/$TileEntityFluidTank" {
import {$IFluidContainerManager$ContainerEditMode, $IFluidContainerManager$ContainerEditMode$Type} from "packages/mekanism/common/tile/interfaces/$IFluidContainerManager$ContainerEditMode"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$FluidTankFluidTank, $FluidTankFluidTank$Type} from "packages/mekanism/common/capabilities/fluid/$FluidTankFluidTank"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ISustainedData, $ISustainedData$Type} from "packages/mekanism/common/tile/interfaces/$ISustainedData"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IUpgradeData, $IUpgradeData$Type} from "packages/mekanism/common/upgrade/$IUpgradeData"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$IFluidContainerManager, $IFluidContainerManager$Type} from "packages/mekanism/common/tile/interfaces/$IFluidContainerManager"
import {$FluidTankTier, $FluidTankTier$Type} from "packages/mekanism/common/tier/$FluidTankTier"
import {$IConfigurable, $IConfigurable$Type} from "packages/mekanism/api/$IConfigurable"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TileEntityFluidTank extends $TileEntityMekanism implements $IConfigurable, $IFluidContainerManager, $ISustainedData {
 "fluidTank": $FluidTankFluidTank
 "tier": $FluidTankTier
 "valve": integer
 "valveFluid": $FluidStack
 "prevScale": float
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "addContainerTrackers"(container: $MekanismContainer$Type): void
public "nextMode"(): void
public "previousMode"(): void
public "onRightClick"(player: $Player$Type): $InteractionResult
public "getRedstoneLevel"(): integer
public "readSustainedData"(data: $CompoundTag$Type): void
public "writeSustainedData"(data: $CompoundTag$Type): void
public "parseUpgradeData"(upgradeData: $IUpgradeData$Type): void
public "getReducedUpdateTag"(): $CompoundTag
public "getContainerEditMode"(): $IFluidContainerManager$ContainerEditMode
public "insertFluid"(tank: integer, stack: $FluidStack$Type, side: $Direction$Type, action: $Action$Type): $FluidStack
public "onSneakRightClick"(player: $Player$Type): $InteractionResult
public "getTileDataRemap"(): $Map<(string), (string)>
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "redstoneLevel"(): integer
get "reducedUpdateTag"(): $CompoundTag
get "containerEditMode"(): $IFluidContainerManager$ContainerEditMode
get "tileDataRemap"(): $Map<(string), (string)>
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityFluidTank$Type = ($TileEntityFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityFluidTank_ = $TileEntityFluidTank$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$ItemFluidChemical" {
import {$ChemicalStackIngredient, $ChemicalStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient"
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$TriPredicate, $TriPredicate$Type} from "packages/net/minecraftforge/common/util/$TriPredicate"
import {$ItemInputCache, $ItemInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$ItemInputCache"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$ChemicalInputCache, $ChemicalInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$ChemicalInputCache"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$TripleInputRecipeCache, $TripleInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$TripleInputRecipeCache"
import {$MekanismRecipeType, $MekanismRecipeType$Type} from "packages/mekanism/common/recipe/$MekanismRecipeType"
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$FluidInputCache, $FluidInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$FluidInputCache"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$FluidStackIngredient, $FluidStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$FluidStackIngredient"

export class $InputRecipeCache$ItemFluidChemical<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, RECIPE extends ($MekanismRecipe) & ($TriPredicate<($ItemStack), ($FluidStack), (STACK)>)> extends $TripleInputRecipeCache<($ItemStack), ($ItemStackIngredient), ($FluidStack), ($FluidStackIngredient), (STACK), ($ChemicalStackIngredient<(CHEMICAL), (STACK)>), (RECIPE), ($ItemInputCache<(RECIPE)>), ($FluidInputCache<(RECIPE)>), ($ChemicalInputCache<(CHEMICAL), (STACK), (RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$Type<(RECIPE), (any)>, inputAExtractor: $Function$Type<(RECIPE), ($ItemStackIngredient$Type)>, inputBExtractor: $Function$Type<(RECIPE), ($FluidStackIngredient$Type)>, inputCExtractor: $Function$Type<(RECIPE), ($ChemicalStackIngredient$Type<(CHEMICAL), (STACK)>)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$ItemFluidChemical$Type<CHEMICAL, STACK, RECIPE> = ($InputRecipeCache$ItemFluidChemical<(CHEMICAL), (STACK), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$ItemFluidChemical_<CHEMICAL, STACK, RECIPE> = $InputRecipeCache$ItemFluidChemical$Type<(CHEMICAL), (STACK), (RECIPE)>;
}}
declare module "packages/mekanism/common/item/block/machine/$ItemBlockTeleporter" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$BlockTile, $BlockTile$Type} from "packages/mekanism/common/block/prefab/$BlockTile"
import {$ItemBlockMachine, $ItemBlockMachine$Type} from "packages/mekanism/common/item/block/machine/$ItemBlockMachine"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockTeleporter extends $ItemBlockMachine {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockTile$Type<(any), (any)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockTeleporter$Type = ($ItemBlockTeleporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockTeleporter_ = $ItemBlockTeleporter$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ChemicalInfuserRecipeSerializer" {
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$ChemicalInfuserRecipe, $ChemicalInfuserRecipe$Type} from "packages/mekanism/api/recipes/$ChemicalInfuserRecipe"
import {$ChemicalChemicalToChemicalRecipeSerializer$IFactory, $ChemicalChemicalToChemicalRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$ChemicalChemicalToChemicalRecipeSerializer$IFactory"
import {$Gas, $Gas$Type} from "packages/mekanism/api/chemical/gas/$Gas"
import {$ChemicalStackIngredient$GasStackIngredient, $ChemicalStackIngredient$GasStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient$GasStackIngredient"
import {$ChemicalChemicalToChemicalRecipeSerializer, $ChemicalChemicalToChemicalRecipeSerializer$Type} from "packages/mekanism/common/recipe/serializer/$ChemicalChemicalToChemicalRecipeSerializer"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ChemicalInfuserRecipeSerializer<RECIPE extends $ChemicalInfuserRecipe> extends $ChemicalChemicalToChemicalRecipeSerializer<($Gas), ($GasStack), ($ChemicalStackIngredient$GasStackIngredient), (RECIPE)> {

constructor(factory: $ChemicalChemicalToChemicalRecipeSerializer$IFactory$Type<($Gas$Type), ($GasStack$Type), ($ChemicalStackIngredient$GasStackIngredient$Type), (RECIPE)>)

public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalInfuserRecipeSerializer$Type<RECIPE> = ($ChemicalInfuserRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalInfuserRecipeSerializer_<RECIPE> = $ChemicalInfuserRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/lib/multiblock/$MultiblockCache$RejectContents" {
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$SlurryStack, $SlurryStack$Type} from "packages/mekanism/api/chemical/slurry/$SlurryStack"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$InfusionStack, $InfusionStack$Type} from "packages/mekanism/api/chemical/infuse/$InfusionStack"
import {$PigmentStack, $PigmentStack$Type} from "packages/mekanism/api/chemical/pigment/$PigmentStack"

export class $MultiblockCache$RejectContents {
readonly "rejectedItems": $List<($ItemStack)>
readonly "rejectedFluids": $List<($FluidStack)>
readonly "rejectedGases": $List<($GasStack)>
readonly "rejectedInfuseTypes": $List<($InfusionStack)>
readonly "rejectedPigments": $List<($PigmentStack)>
readonly "rejectedSlurries": $List<($SlurryStack)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockCache$RejectContents$Type = ($MultiblockCache$RejectContents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockCache$RejectContents_ = $MultiblockCache$RejectContents$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ElectrolysisRecipeSerializer$IFactory" {
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$FluidStackIngredient, $FluidStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$FluidStackIngredient"
import {$ElectrolysisRecipe, $ElectrolysisRecipe$Type} from "packages/mekanism/api/recipes/$ElectrolysisRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"

export interface $ElectrolysisRecipeSerializer$IFactory<RECIPE extends $ElectrolysisRecipe> {

 "create"(id: $ResourceLocation$Type, input: $FluidStackIngredient$Type, energyMultiplier: $FloatingLong$Type, leftGasOutput: $GasStack$Type, rightGasOutput: $GasStack$Type): RECIPE

(id: $ResourceLocation$Type, input: $FluidStackIngredient$Type, energyMultiplier: $FloatingLong$Type, leftGasOutput: $GasStack$Type, rightGasOutput: $GasStack$Type): RECIPE
}

export namespace $ElectrolysisRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ElectrolysisRecipeSerializer$IFactory$Type<RECIPE> = ($ElectrolysisRecipeSerializer$IFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ElectrolysisRecipeSerializer$IFactory_<RECIPE> = $ElectrolysisRecipeSerializer$IFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/tile/$TileEntityQuantumEntangloporter" {
import {$InfuseType, $InfuseType$Type} from "packages/mekanism/api/chemical/infuse/$InfuseType"
import {$SubstanceType, $SubstanceType$Type} from "packages/mekanism/common/tile/base/$SubstanceType"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IChunkLoader, $IChunkLoader$Type} from "packages/mekanism/common/lib/chunkloading/$IChunkLoader"
import {$TileEntityConfigurableMachine, $TileEntityConfigurableMachine$Type} from "packages/mekanism/common/tile/prefab/$TileEntityConfigurableMachine"
import {$IPigmentTank, $IPigmentTank$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentTank"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Slurry, $Slurry$Type} from "packages/mekanism/api/chemical/slurry/$Slurry"
import {$Gas, $Gas$Type} from "packages/mekanism/api/chemical/gas/$Gas"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IHeatHandler, $IHeatHandler$Type} from "packages/mekanism/api/heat/$IHeatHandler"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$IInfusionTank, $IInfusionTank$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionTank"
import {$InventoryFrequency, $InventoryFrequency$Type} from "packages/mekanism/common/content/entangloporter/$InventoryFrequency"
import {$PigmentStack, $PigmentStack$Type} from "packages/mekanism/api/chemical/pigment/$PigmentStack"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$ChunkPos, $ChunkPos$Type} from "packages/net/minecraft/world/level/$ChunkPos"
import {$TileComponentEjector, $TileComponentEjector$Type} from "packages/mekanism/common/tile/component/$TileComponentEjector"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$ISlurryTank, $ISlurryTank$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryTank"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$SlurryStack, $SlurryStack$Type} from "packages/mekanism/api/chemical/slurry/$SlurryStack"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TileComponentConfig, $TileComponentConfig$Type} from "packages/mekanism/common/tile/component/$TileComponentConfig"
import {$Pigment, $Pigment$Type} from "packages/mekanism/api/chemical/pigment/$Pigment"
import {$InfusionStack, $InfusionStack$Type} from "packages/mekanism/api/chemical/infuse/$InfusionStack"
import {$IChemicalTankHolder, $IChemicalTankHolder$Type} from "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder"
import {$TileComponentChunkLoader, $TileComponentChunkLoader$Type} from "packages/mekanism/common/tile/component/$TileComponentChunkLoader"

export class $TileEntityQuantumEntangloporter extends $TileEntityConfigurableMachine implements $IChunkLoader {
 "ejectorComponent": $TileComponentEjector
 "configComponent": $TileComponentConfig
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "getFreq"(): $InventoryFrequency
public "shouldDumpRadiation"(): boolean
public "addContainerTrackers"(container: $MekanismContainer$Type): void
public "getInitialPigmentTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($Pigment), ($PigmentStack), ($IPigmentTank)>
public "getInitialSlurryTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($Slurry), ($SlurryStack), ($ISlurryTank)>
public "getInitialInfusionTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($InfuseType), ($InfusionStack), ($IInfusionTank)>
public "getInitialGasTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($Gas), ($GasStack), ($IGasTank)>
public "getChunkSet"(): $Set<($ChunkPos)>
public "persists"(type: $SubstanceType$Type): boolean
public "persistInventory"(): boolean
public "getChunkLoader"(): $TileComponentChunkLoader<($TileEntityQuantumEntangloporter)>
public "getAdjacent"(side: $Direction$Type): $IHeatHandler
public "hasFrequency"(): boolean
public "getLastTransferLoss"(): double
public "getLastEnvironmentLoss"(): double
public "getDirection"(): $Direction
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "freq"(): $InventoryFrequency
get "chunkSet"(): $Set<($ChunkPos)>
get "chunkLoader"(): $TileComponentChunkLoader<($TileEntityQuantumEntangloporter)>
get "lastTransferLoss"(): double
get "lastEnvironmentLoss"(): double
get "direction"(): $Direction
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityQuantumEntangloporter$Type = ($TileEntityQuantumEntangloporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityQuantumEntangloporter_ = $TileEntityQuantumEntangloporter$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$ITileWrapper" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"

export interface $ITileWrapper {

 "getTilePos"(): $BlockPos
 "getTileWorld"(): $Level
 "getTileCoord"(): $Coord4D
 "getTileChunk"(): $Chunk3D
}

export namespace $ITileWrapper {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileWrapper$Type = ($ITileWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileWrapper_ = $ITileWrapper$Type;
}}
declare module "packages/mekanism/common/inventory/$GuiComponents$IDropdownEnum" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $GuiComponents$IDropdownEnum<TYPE extends ($Enum<(TYPE)>) & ($GuiComponents$IDropdownEnum<(TYPE)>)> {

 "getIcon"(): $ResourceLocation
 "getShortName"(): $Component
 "getTooltip"(): $Component
}

export namespace $GuiComponents$IDropdownEnum {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiComponents$IDropdownEnum$Type<TYPE> = ($GuiComponents$IDropdownEnum<(TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiComponents$IDropdownEnum_<TYPE> = $GuiComponents$IDropdownEnum$Type<(TYPE)>;
}}
declare module "packages/mekanism/common/content/network/transmitter/$BufferedTransmitter" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$DynamicBufferedNetwork, $DynamicBufferedNetwork$Type} from "packages/mekanism/common/lib/transmitter/$DynamicBufferedNetwork"
import {$TransmissionType, $TransmissionType$Type} from "packages/mekanism/common/lib/transmitter/$TransmissionType"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$Transmitter, $Transmitter$Type} from "packages/mekanism/common/content/network/transmitter/$Transmitter"

export class $BufferedTransmitter<ACCEPTOR, NETWORK extends $DynamicBufferedNetwork<(ACCEPTOR), (NETWORK), (BUFFER), (TRANSMITTER)>, BUFFER, TRANSMITTER extends $BufferedTransmitter<(ACCEPTOR), (NETWORK), (BUFFER), (TRANSMITTER)>> extends $Transmitter<(ACCEPTOR), (NETWORK), (TRANSMITTER)> {
 "currentTransmitterConnections": byte

constructor(tile: $TileEntityTransmitter$Type, ...transmissionTypes: ($TransmissionType$Type)[])

public "getCapacity"(): long
public "getShare"(): BUFFER
public "requestsUpdate"(): void
public "releaseShare"(): BUFFER
public "validateAndTakeShare"(): void
public "getBufferWithFallback"(): BUFFER
public "isValidTransmitter"(transmitter: $TileEntityTransmitter$Type, side: $Direction$Type): boolean
public "noBufferOrFallback"(): boolean
get "capacity"(): long
get "share"(): BUFFER
get "bufferWithFallback"(): BUFFER
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BufferedTransmitter$Type<ACCEPTOR, NETWORK, BUFFER, TRANSMITTER> = ($BufferedTransmitter<(ACCEPTOR), (NETWORK), (BUFFER), (TRANSMITTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BufferedTransmitter_<ACCEPTOR, NETWORK, BUFFER, TRANSMITTER> = $BufferedTransmitter$Type<(ACCEPTOR), (NETWORK), (BUFFER), (TRANSMITTER)>;
}}
declare module "packages/mekanism/common/item/block/$ItemBlockSecurityDesk" {
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$Type} from "packages/mekanism/common/block/prefab/$BlockTile$BlockTileModel"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ListTag, $ListTag$Type} from "packages/net/minecraft/nbt/$ListTag"
import {$TileEntitySecurityDesk, $TileEntitySecurityDesk$Type} from "packages/mekanism/common/tile/$TileEntitySecurityDesk"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemBlockTooltip, $ItemBlockTooltip$Type} from "packages/mekanism/common/item/block/$ItemBlockTooltip"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$IItemSustainedInventory, $IItemSustainedInventory$Type} from "packages/mekanism/common/item/interfaces/$IItemSustainedInventory"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockSecurityDesk extends $ItemBlockTooltip<($BlockTile$BlockTileModel<($TileEntitySecurityDesk), ($BlockTypeTile<($TileEntitySecurityDesk)>)>)> implements $IItemSustainedInventory {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockTile$BlockTileModel$Type<($TileEntitySecurityDesk$Type), ($BlockTypeTile$Type<($TileEntitySecurityDesk$Type)>)>)

public "getSustainedInventory"(stack: $ItemStack$Type): $ListTag
public "getSustainedInventory"(): $ListTag
public "setSustainedInventory"(nbtTags: $ListTag$Type): void
public "setSustainedInventory"(nbtTags: $ListTag$Type, stack: $ItemStack$Type): void
public "getDroppedSlots"(stack: $ItemStack$Type): $List<($IInventorySlot)>
public "hasSustainedInventory"(stack: $ItemStack$Type): boolean
public "hasSustainedInventory"(): boolean
public "canContentsDrop"(stack: $ItemStack$Type): boolean
get "sustainedInventory"(): $ListTag
set "sustainedInventory"(value: $ListTag$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockSecurityDesk$Type = ($ItemBlockSecurityDesk);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockSecurityDesk_ = $ItemBlockSecurityDesk$Type;
}}
declare module "packages/mekanism/common/content/network/$EnergyNetwork" {
import {$UniversalCable, $UniversalCable$Type} from "packages/mekanism/common/content/network/transmitter/$UniversalCable"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$VariableCapacityEnergyContainer, $VariableCapacityEnergyContainer$Type} from "packages/mekanism/common/capabilities/energy/$VariableCapacityEnergyContainer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$DynamicBufferedNetwork, $DynamicBufferedNetwork$Type} from "packages/mekanism/common/lib/transmitter/$DynamicBufferedNetwork"
import {$IMekanismStrictEnergyHandler, $IMekanismStrictEnergyHandler$Type} from "packages/mekanism/api/energy/$IMekanismStrictEnergyHandler"
import {$IEnergyContainer, $IEnergyContainer$Type} from "packages/mekanism/api/energy/$IEnergyContainer"
import {$IStrictEnergyHandler, $IStrictEnergyHandler$Type} from "packages/mekanism/api/energy/$IStrictEnergyHandler"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"

export class $EnergyNetwork extends $DynamicBufferedNetwork<($IStrictEnergyHandler), ($EnergyNetwork), ($FloatingLong), ($UniversalCable)> implements $IMekanismStrictEnergyHandler {
readonly "energyContainer": $VariableCapacityEnergyContainer
 "currentScale": float

constructor(networkID: $UUID$Type)
constructor(networks: $Collection$Type<($EnergyNetwork$Type)>)

public "toString"(): string
public "onContentsChanged"(): void
public "adoptTransmittersAndAcceptorsFrom"(net: $EnergyNetwork$Type): $List<($UniversalCable)>
public "getNetworkReaderCapacity"(): any
public "onUpdate"(): void
public "getEnergyContainers"(side: $Direction$Type): $List<($IEnergyContainer)>
public "absorbBuffer"(transmitter: $UniversalCable$Type): void
public "getFlowInfo"(): $Component
public "updateCapacity"(): void
public "getStoredInfo"(): $Component
public "clampBuffer"(): void
public "getNeededInfo"(): $Component
public "getTextComponent"(): $Component
public "getCapacityAsFloatingLong"(): $FloatingLong
public "getEnergyContainer"(arg0: integer, arg1: $Direction$Type): $IEnergyContainer
public "getEnergyContainerCount"(arg0: $Direction$Type): integer
public "extractEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type, arg3: $Action$Type): $FloatingLong
public "getEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "setEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type): void
public "canHandleEnergy"(): boolean
public "getMaxEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "getNeededEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "insertEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type, arg3: $Action$Type): $FloatingLong
public "getEnergyContainerCount"(): integer
public "extractEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Action$Type): $FloatingLong
public "extractEnergy"(arg0: $FloatingLong$Type, arg1: $Direction$Type, arg2: $Action$Type): $FloatingLong
public "getEnergy"(arg0: integer): $FloatingLong
public "setEnergy"(arg0: integer, arg1: $FloatingLong$Type): void
public "getMaxEnergy"(arg0: integer): $FloatingLong
public "getNeededEnergy"(arg0: integer): $FloatingLong
public "insertEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Action$Type): $FloatingLong
public "insertEnergy"(arg0: $FloatingLong$Type, arg1: $Direction$Type, arg2: $Action$Type): $FloatingLong
public "getEnergySideFor"(): $Direction
public "extractEnergy"(arg0: $FloatingLong$Type, arg1: $Action$Type): $FloatingLong
public "insertEnergy"(arg0: $FloatingLong$Type, arg1: $Action$Type): $FloatingLong
get "networkReaderCapacity"(): any
get "flowInfo"(): $Component
get "storedInfo"(): $Component
get "neededInfo"(): $Component
get "textComponent"(): $Component
get "capacityAsFloatingLong"(): $FloatingLong
get "energyContainerCount"(): integer
get "energySideFor"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyNetwork$Type = ($EnergyNetwork);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyNetwork_ = $EnergyNetwork$Type;
}}
declare module "packages/mekanism/common/item/$ItemGaugeDropper" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CapabilityItem, $CapabilityItem$Type} from "packages/mekanism/common/item/$CapabilityItem"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemGaugeDropper extends $CapabilityItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "isBarVisible"(stack: $ItemStack$Type): boolean
public "getBarWidth"(stack: $ItemStack$Type): integer
public "getBarColor"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemGaugeDropper$Type = ($ItemGaugeDropper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemGaugeDropper_ = $ItemGaugeDropper$Type;
}}
declare module "packages/mekanism/common/content/gear/$IModuleItem" {
import {$ModuleData, $ModuleData$Type} from "packages/mekanism/api/gear/$ModuleData"

export interface $IModuleItem {

 "getModuleData"(): $ModuleData<(any)>

(): $ModuleData<(any)>
}

export namespace $IModuleItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModuleItem$Type = ($IModuleItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModuleItem_ = $IModuleItem$Type;
}}
declare module "packages/mekanism/common/block/$BlockCardboardBox$BlockData" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockCardboardBox$BlockData {
readonly "blockState": $BlockState
 "tileTag": $CompoundTag

constructor(blockState: $BlockState$Type)

public "write"(nbtTags: $CompoundTag$Type): $CompoundTag
public static "read"(level: $Level$Type, nbtTags: $CompoundTag$Type): $BlockCardboardBox$BlockData
public "updateLocation"(pos: $BlockPos$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockCardboardBox$BlockData$Type = ($BlockCardboardBox$BlockData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockCardboardBox$BlockData_ = $BlockCardboardBox$BlockData$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$CombinerRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$CombinerRecipe, $CombinerRecipe$Type} from "packages/mekanism/api/recipes/$CombinerRecipe"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CombinerRecipeSerializer$IFactory, $CombinerRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$CombinerRecipeSerializer$IFactory"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $CombinerRecipeSerializer<RECIPE extends $CombinerRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(factory: $CombinerRecipeSerializer$IFactory$Type<(RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CombinerRecipeSerializer$Type<RECIPE> = ($CombinerRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CombinerRecipeSerializer_<RECIPE> = $CombinerRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/item/gear/$ItemGasArmor" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemSpecialArmor, $ItemSpecialArmor$Type} from "packages/mekanism/common/item/gear/$ItemSpecialArmor"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$CreativeModeTab$Output, $CreativeModeTab$Output$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$Output"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$Type} from "packages/mekanism/common/registration/impl/$CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$DispenseItemBehavior, $DispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DispenseItemBehavior"
import {$IGasItem, $IGasItem$Type} from "packages/mekanism/common/item/interfaces/$IGasItem"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemGasArmor extends $ItemSpecialArmor implements $IGasItem, $CreativeTabDeferredRegister$ICustomCreativeTabContents {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer


public "addItems"(tabOutput: $CreativeModeTab$Output$Type): void
public "isBarVisible"(stack: $ItemStack$Type): boolean
public "getBarWidth"(stack: $ItemStack$Type): integer
public "getBarColor"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "hasGas"(stack: $ItemStack$Type): boolean
public "useGas"(stack: $ItemStack$Type, amount: long): $GasStack
public "addDefault"(): boolean
public static "get"(arg0: $ItemStack$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemGasArmor$Type = ($ItemGasArmor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemGasArmor_ = $ItemGasArmor$Type;
}}
declare module "packages/mekanism/common/inventory/slot/$BinInventorySlot" {
import {$BinTier, $BinTier$Type} from "packages/mekanism/common/tier/$BinTier"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$BasicInventorySlot, $BasicInventorySlot$Type} from "packages/mekanism/common/inventory/slot/$BasicInventorySlot"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"

export class $BinInventorySlot extends $BasicInventorySlot {
static readonly "alwaysTrue": $Predicate<($ItemStack)>
static readonly "alwaysFalse": $Predicate<($ItemStack)>
static readonly "alwaysTrueBi": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "DEFAULT_LIMIT": integer


public static "create"(listener: $IContentsListener$Type, tier: $BinTier$Type): $BinInventorySlot
public "setLocked"(lock: boolean): boolean
public "deserializeNBT"(nbt: $CompoundTag$Type): void
public "getBottomStack"(): $ItemStack
public "insertItem"(stack: $ItemStack$Type, action: $Action$Type, automationType: $AutomationType$Type): $ItemStack
public "extractItem"(amount: integer, action: $Action$Type, automationType: $AutomationType$Type): $ItemStack
public "setStackSize"(amount: integer, action: $Action$Type): integer
public "getRenderStack"(): $ItemStack
public "getLockStack"(): $ItemStack
public "setLockStack"(stack: $ItemStack$Type): void
public "isLocked"(): boolean
set "locked"(value: boolean)
get "bottomStack"(): $ItemStack
get "renderStack"(): $ItemStack
get "lockStack"(): $ItemStack
set "lockStack"(value: $ItemStack$Type)
get "locked"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinInventorySlot$Type = ($BinInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinInventorySlot_ = $BinInventorySlot$Type;
}}
declare module "packages/mekanism/common/item/block/machine/$ItemBlockFluidTank" {
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockFluidTank, $BlockFluidTank$Type} from "packages/mekanism/common/block/basic/$BlockFluidTank"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$IModeItem, $IModeItem$Type} from "packages/mekanism/common/item/interfaces/$IModeItem"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ItemBlockMachine, $ItemBlockMachine$Type} from "packages/mekanism/common/item/block/machine/$ItemBlockMachine"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockFluidTank extends $ItemBlockMachine implements $IModeItem {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockFluidTank$Type)

public "initializeClient"(consumer: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "setBucketMode"(itemStack: $ItemStack$Type, bucketMode: boolean): void
public "getBucketMode"(itemStack: $ItemStack$Type): boolean
public "use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "getScrollTextComponent"(stack: $ItemStack$Type): $Component
public "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
public "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "displayModeChange"(player: $Player$Type): void
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockFluidTank$Type = ($ItemBlockFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockFluidTank_ = $ItemBlockFluidTank$Type;
}}
declare module "packages/mekanism/common/block/transmitter/$BlockUniversalCable" {
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$ITypeBlock, $ITypeBlock$Type} from "packages/mekanism/common/block/interfaces/$ITypeBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockType, $BlockType$Type} from "packages/mekanism/common/content/blocktype/$BlockType"
import {$IHasTileEntity, $IHasTileEntity$Type} from "packages/mekanism/common/block/interfaces/$IHasTileEntity"
import {$BlockSmallTransmitter, $BlockSmallTransmitter$Type} from "packages/mekanism/common/block/transmitter/$BlockSmallTransmitter"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$TileEntityUniversalCable, $TileEntityUniversalCable$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityUniversalCable"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$CableTier, $CableTier$Type} from "packages/mekanism/common/tier/$CableTier"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export class $BlockUniversalCable extends $BlockSmallTransmitter implements $ITypeBlock, $IHasTileEntity<($TileEntityUniversalCable)> {
static readonly "CENTER": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(tier: $CableTier$Type)

public "getType"(): $BlockType
public "getTileType"(): $TileEntityTypeRegistryObject<($TileEntityUniversalCable)>
public "createDummyBlockEntity"(state: $BlockState$Type): $TileEntityUniversalCable
public "createDummyBlockEntity"(): $TileEntityUniversalCable
public "triggerBlockEntityEvent"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, id: integer, param: integer): boolean
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $TileEntityUniversalCable
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
get "type"(): $BlockType
get "tileType"(): $TileEntityTypeRegistryObject<($TileEntityUniversalCable)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockUniversalCable$Type = ($BlockUniversalCable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockUniversalCable_ = $BlockUniversalCable$Type;
}}
declare module "packages/mekanism/common/content/network/$FluidNetwork" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$MechanicalPipe, $MechanicalPipe$Type} from "packages/mekanism/common/content/network/transmitter/$MechanicalPipe"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$DynamicBufferedNetwork, $DynamicBufferedNetwork$Type} from "packages/mekanism/common/lib/transmitter/$DynamicBufferedNetwork"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMekanismFluidHandler, $IMekanismFluidHandler$Type} from "packages/mekanism/api/fluid/$IMekanismFluidHandler"
import {$VariableCapacityFluidTank, $VariableCapacityFluidTank$Type} from "packages/mekanism/common/capabilities/fluid/$VariableCapacityFluidTank"
import {$IExtendedFluidTank, $IExtendedFluidTank$Type} from "packages/mekanism/api/fluid/$IExtendedFluidTank"

export class $FluidNetwork extends $DynamicBufferedNetwork<($IFluidHandler), ($FluidNetwork), ($FluidStack), ($MechanicalPipe)> implements $IMekanismFluidHandler {
readonly "fluidTank": $VariableCapacityFluidTank
 "lastFluid": $FluidStack
 "currentScale": float

constructor(networkID: $UUID$Type)
constructor(networks: $Collection$Type<($FluidNetwork$Type)>)

public "toString"(): string
public "isCompatibleWith"(other: $FluidNetwork$Type): boolean
public "getBuffer"(): $FluidStack
public "getPrevTransferAmount"(): integer
public "onContentsChanged"(): void
public "adoptTransmittersAndAcceptorsFrom"(net: $FluidNetwork$Type): $List<($MechanicalPipe)>
public "onUpdate"(): void
public "setLastFluid"(fluid: $FluidStack$Type): void
public "getCapacityAsInt"(): integer
public "absorbBuffer"(transmitter: $MechanicalPipe$Type): void
public "getFlowInfo"(): $Component
public "updateCapacity"(): void
public "getStoredInfo"(): $Component
public "clampBuffer"(): void
public "getNeededInfo"(): $Component
public "getTextComponent"(): $Component
public "getFluidTanks"(side: $Direction$Type): $List<($IExtendedFluidTank)>
public "getTanks"(arg0: $Direction$Type): integer
public "getTankCapacity"(arg0: integer, arg1: $Direction$Type): integer
public "getFluidInTank"(arg0: integer, arg1: $Direction$Type): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type): boolean
public "getFluidTank"(arg0: integer, arg1: $Direction$Type): $IExtendedFluidTank
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type): void
public "insertFluid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type, arg3: $Action$Type): $FluidStack
public "canHandleFluid"(): boolean
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Direction$Type, arg3: $Action$Type): $FluidStack
public "getTanks"(): integer
public "getTankCapacity"(arg0: integer): integer
public "getFluidInTank"(arg0: integer): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$Type): void
public "insertFluid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Action$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$Type, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "getFluidSideFor"(): $Direction
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Action$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$Type, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
/**
 * 
 * @deprecated
 */
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$Type, arg1: $Action$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Action$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$Type, arg1: $Action$Type): $FluidStack
get "buffer"(): $FluidStack
get "prevTransferAmount"(): integer
set "lastFluid"(value: $FluidStack$Type)
get "capacityAsInt"(): integer
get "flowInfo"(): $Component
get "storedInfo"(): $Component
get "neededInfo"(): $Component
get "textComponent"(): $Component
get "tanks"(): integer
get "fluidSideFor"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidNetwork$Type = ($FluidNetwork);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidNetwork_ = $FluidNetwork$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemMekaSuitArmor" {
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$BooleanSupplier, $BooleanSupplier$Type} from "packages/java/util/function/$BooleanSupplier"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$IHUDElement, $IHUDElement$Type} from "packages/mekanism/api/gear/$IHUDElement"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$ICustomModule, $ICustomModule$Type} from "packages/mekanism/api/gear/$ICustomModule"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$Type} from "packages/mekanism/common/registration/impl/$CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$RateLimitMultiTankFluidHandler$FluidTankSpec, $RateLimitMultiTankFluidHandler$FluidTankSpec$Type} from "packages/mekanism/common/capabilities/fluid/item/$RateLimitMultiTankFluidHandler$FluidTankSpec"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"
import {$ImmutableMultimap$Builder, $ImmutableMultimap$Builder$Type} from "packages/com/google/common/collect/$ImmutableMultimap$Builder"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$IJetpackItem$JetpackMode, $IJetpackItem$JetpackMode$Type} from "packages/mekanism/common/item/interfaces/$IJetpackItem$JetpackMode"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemSpecialArmor, $ItemSpecialArmor$Type} from "packages/mekanism/common/item/gear/$ItemSpecialArmor"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$IModeItem, $IModeItem$Type} from "packages/mekanism/common/item/interfaces/$IModeItem"
import {$ModuleData, $ModuleData$Type} from "packages/mekanism/api/gear/$ModuleData"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IModuleDataProvider, $IModuleDataProvider$Type} from "packages/mekanism/api/providers/$IModuleDataProvider"
import {$CreativeModeTab$Output, $CreativeModeTab$Output$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$Output"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ChemicalTankSpec, $ChemicalTankSpec$Type} from "packages/mekanism/common/capabilities/chemical/item/$ChemicalTankSpec"
import {$IJetpackItem, $IJetpackItem$Type} from "packages/mekanism/common/item/interfaces/$IJetpackItem"
import {$Gas, $Gas$Type} from "packages/mekanism/api/chemical/gas/$Gas"
import {$IModuleContainerItem, $IModuleContainerItem$Type} from "packages/mekanism/common/content/gear/$IModuleContainerItem"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$IModule, $IModule$Type} from "packages/mekanism/api/gear/$IModule"
import {$IClientItemExtensions, $IClientItemExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientItemExtensions"
import {$Module, $Module$Type} from "packages/mekanism/common/content/gear/$Module"
import {$EnderMan, $EnderMan$Type} from "packages/net/minecraft/world/entity/monster/$EnderMan"
import {$IAttributeRefresher, $IAttributeRefresher$Type} from "packages/mekanism/common/lib/attribute/$IAttributeRefresher"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$DamageType, $DamageType$Type} from "packages/net/minecraft/world/damagesource/$DamageType"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$DispenseItemBehavior, $DispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DispenseItemBehavior"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemMekaSuitArmor extends $ItemSpecialArmor implements $IModuleContainerItem, $IModeItem, $IJetpackItem, $IAttributeRefresher, $CreativeTabDeferredRegister$ICustomCreativeTabContents {
static readonly "BASE_ALWAYS_SUPPORTED": $List<($ResourceKey<($DamageType)>)>
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(armorType: $ArmorItem$Type$Type, properties: $Item$Properties$Type)

public "getContainedGas"(stack: $ItemStack$Type, type: $Gas$Type): $GasStack
public "getGasTankSpecs"(): $List<($ChemicalTankSpec<($Gas)>)>
public "getFluidTankSpecs"(): $List<($RateLimitMultiTankFluidHandler$FluidTankSpec)>
public "getContainedFluid"(stack: $ItemStack$Type, type: $FluidStack$Type): $FluidStack
public static "tryAbsorbAll"(player: $Player$Type, source: $DamageSource$Type, amount: float): boolean
public static "getDamageAbsorbed"(player: $Player$Type, source: $DamageSource$Type, amount: float): float
public "addItems"(tabOutput: $CreativeModeTab$Output$Type): void
public "getEnchantmentLevel"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): integer
public "initializeClient"(consumer: $Consumer$Type<($IClientItemExtensions$Type)>): void
public "getAllEnchantments"(stack: $ItemStack$Type): $Map<($Enchantment), (integer)>
public "addToBuilder"(builder: $ImmutableMultimap$Builder$Type<($Attribute$Type), ($AttributeModifier$Type)>): void
public "shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "canWalkOnPowderedSnow"(stack: $ItemStack$Type, wearer: $LivingEntity$Type): boolean
public "getAttributeModifiers"(slot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "makesPiglinsNeutral"(stack: $ItemStack$Type, wearer: $LivingEntity$Type): boolean
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "isNotReplaceableByPickAction"(stack: $ItemStack$Type, player: $Player$Type, inventorySlot: integer): boolean
public static "getBaseDamageRatio"(damageType: $ResourceKey$Type<($DamageType$Type)>): float
public "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public "canElytraFly"(stack: $ItemStack$Type, entity: $LivingEntity$Type): boolean
public "elytraFlightTick"(stack: $ItemStack$Type, entity: $LivingEntity$Type, flightTicks: integer): boolean
public "isBarVisible"(stack: $ItemStack$Type): boolean
public "getBarWidth"(stack: $ItemStack$Type): integer
public "getBarColor"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "onArmorTick"(stack: $ItemStack$Type, world: $Level$Type, player: $Player$Type): void
public "damageItem"<T extends $LivingEntity>(stack: $ItemStack$Type, amount: integer, entity: T, onBroken: $Consumer$Type<(T)>): integer
public "isEnderMask"(stack: $ItemStack$Type, player: $Player$Type, enderman: $EnderMan$Type): boolean
public "getDefense"(): integer
public "getToughness"(): float
public "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
public "useGas"(stack: $ItemStack$Type, type: $Gas$Type, amount: long): $GasStack
public "canUseJetpack"(stack: $ItemStack$Type): boolean
public "useJetpackFuel"(stack: $ItemStack$Type): void
public "getJetpackMode"(stack: $ItemStack$Type): $IJetpackItem$JetpackMode
public "getModule"<MODULE extends $ICustomModule<(MODULE)>>(stack: $ItemStack$Type, typeProvider: $IModuleDataProvider$Type<(MODULE)>): $IModule<(MODULE)>
public "addModuleDetails"(stack: $ItemStack$Type, tooltip: $List$Type<($Component$Type)>): void
public "isModuleEnabled"(stack: $ItemStack$Type, type: $IModuleDataProvider$Type<(any)>): boolean
public "supportsModule"(stack: $ItemStack$Type, typeProvider: $IModuleDataProvider$Type<(any)>): boolean
public "getHUDElements"(player: $Player$Type, stack: $ItemStack$Type): $List<($IHUDElement)>
public "removeModule"(stack: $ItemStack$Type, type: $ModuleData$Type<(any)>): void
public "hasModule"(stack: $ItemStack$Type, type: $IModuleDataProvider$Type<(any)>): boolean
public "addModule"(stack: $ItemStack$Type, type: $ModuleData$Type<(any)>): void
public "getModules"(stack: $ItemStack$Type): $List<($Module<(any)>)>
public "addHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): void
public static "displayModeChange"(player: $Player$Type): void
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
public "getScrollTextComponent"(stack: $ItemStack$Type): $Component
public static "getPlayerJetpackMode"(player: $Player$Type, mode: $IJetpackItem$JetpackMode$Type, ascendingSupplier: $BooleanSupplier$Type): $IJetpackItem$JetpackMode
public static "getActiveJetpack"(entity: $LivingEntity$Type): $ItemStack
public static "getPrimaryJetpack"(entity: $LivingEntity$Type): $ItemStack
public static "handleJetpackMotion"(player: $Player$Type, mode: $IJetpackItem$JetpackMode$Type, ascendingSupplier: $BooleanSupplier$Type): boolean
public "addDefault"(): boolean
public "addCurioHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type): void
public static "get"(arg0: $ItemStack$Type): $Equipable
get "gasTankSpecs"(): $List<($ChemicalTankSpec<($Gas)>)>
get "fluidTankSpecs"(): $List<($RateLimitMultiTankFluidHandler$FluidTankSpec)>
get "defense"(): integer
get "toughness"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemMekaSuitArmor$Type = ($ItemMekaSuitArmor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemMekaSuitArmor_ = $ItemMekaSuitArmor$Type;
}}
declare module "packages/mekanism/common/tile/laser/$TileEntityLaserAmplifier" {
import {$TileEntityLaserAmplifier$RedstoneOutput, $TileEntityLaserAmplifier$RedstoneOutput$Type} from "packages/mekanism/common/tile/laser/$TileEntityLaserAmplifier$RedstoneOutput"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$TileEntityLaserReceptor, $TileEntityLaserReceptor$Type} from "packages/mekanism/common/tile/laser/$TileEntityLaserReceptor"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$IHasMode, $IHasMode$Type} from "packages/mekanism/common/tile/interfaces/$IHasMode"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export class $TileEntityLaserAmplifier extends $TileEntityLaserReceptor implements $IHasMode {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "getMaxThreshold"(): $FloatingLong
public "getMinThreshold"(): $FloatingLong
public "getOutputMode"(): $TileEntityLaserAmplifier$RedstoneOutput
public "addContainerTrackers"(container: $MekanismContainer$Type): void
public "nextMode"(): void
public "previousMode"(): void
public "getDelay"(): integer
public "setDelay"(delay: integer): void
public "setMinThresholdFromPacket"(target: $FloatingLong$Type): void
public "setMaxThresholdFromPacket"(target: $FloatingLong$Type): void
public "getRedstoneLevel"(): integer
public "canPulse"(): boolean
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "maxThreshold"(): $FloatingLong
get "minThreshold"(): $FloatingLong
get "outputMode"(): $TileEntityLaserAmplifier$RedstoneOutput
get "delay"(): integer
set "delay"(value: integer)
set "minThresholdFromPacket"(value: $FloatingLong$Type)
set "maxThresholdFromPacket"(value: $FloatingLong$Type)
get "redstoneLevel"(): integer
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityLaserAmplifier$Type = ($TileEntityLaserAmplifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityLaserAmplifier_ = $TileEntityLaserAmplifier$Type;
}}
declare module "packages/mekanism/common/block/interfaces/$IHasTileEntity" {
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export interface $IHasTileEntity<TILE extends $BlockEntity> extends $EntityBlock {

 "createDummyBlockEntity"(state: $BlockState$Type): TILE
 "createDummyBlockEntity"(): TILE
 "triggerBlockEntityEvent"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, id: integer, param: integer): boolean
 "getTileType"(): $TileEntityTypeRegistryObject<(any)>
 "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): TILE
 "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
 "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener

(state: $BlockState$Type): TILE
}

export namespace $IHasTileEntity {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHasTileEntity$Type<TILE> = ($IHasTileEntity<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHasTileEntity_<TILE> = $IHasTileEntity$Type<(TILE)>;
}}
declare module "packages/mekanism/common/content/miner/$MinerFilter" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$BaseFilter, $BaseFilter$Type} from "packages/mekanism/common/content/filter/$BaseFilter"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"

export class $MinerFilter<FILTER extends $MinerFilter<(FILTER)>> extends $BaseFilter<(FILTER)> {
 "replaceTarget": $Item
 "requiresReplacement": boolean


public "equals"(o: any): boolean
public "hashCode"(): integer
public "write"(buffer: $FriendlyByteBuf$Type): void
public "write"(nbtTags: $CompoundTag$Type): $CompoundTag
public "read"(dataStream: $FriendlyByteBuf$Type): void
public "read"(nbtTags: $CompoundTag$Type): void
public "canFilter"(state: $BlockState$Type): boolean
public "hasBlacklistedElement"(): boolean
public "replaceTargetMatches"(target: $Item$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinerFilter$Type<FILTER> = ($MinerFilter<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MinerFilter_<FILTER> = $MinerFilter$Type<(FILTER)>;
}}
declare module "packages/mekanism/common/tile/base/$SubstanceType" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$List, $List$Type} from "packages/java/util/$List"

export class $SubstanceType extends $Enum<($SubstanceType)> {
static readonly "ENERGY": $SubstanceType
static readonly "FLUID": $SubstanceType
static readonly "GAS": $SubstanceType
static readonly "INFUSION": $SubstanceType
static readonly "PIGMENT": $SubstanceType
static readonly "SLURRY": $SubstanceType
static readonly "HEAT": $SubstanceType


public static "values"(): ($SubstanceType)[]
public static "valueOf"(name: string): $SubstanceType
public "write"(tile: $TileEntityMekanism$Type, tag: $CompoundTag$Type): void
public "read"(tile: $TileEntityMekanism$Type, tag: $CompoundTag$Type): void
public "canHandle"(tile: $TileEntityMekanism$Type): boolean
public "getContainers"(tile: $TileEntityMekanism$Type): $List<(any)>
public "getContainerTag"(): string
get "containerTag"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SubstanceType$Type = (("heat") | ("infusion") | ("gas") | ("pigment") | ("fluid") | ("slurry") | ("energy")) | ($SubstanceType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SubstanceType_ = $SubstanceType$Type;
}}
declare module "packages/mekanism/common/world/$ResizableOreFeature" {
import {$BonusChestFeature, $BonusChestFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$BonusChestFeature"
import {$RandomFeatureConfiguration, $RandomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomFeatureConfiguration"
import {$SpikeConfiguration, $SpikeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SpikeConfiguration"
import {$LakeFeature$Configuration, $LakeFeature$Configuration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$LakeFeature$Configuration"
import {$ResizableOreFeatureConfig, $ResizableOreFeatureConfig$Type} from "packages/mekanism/common/world/$ResizableOreFeatureConfig"
import {$BlockColumnConfiguration, $BlockColumnConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockColumnConfiguration"
import {$MultifaceGrowthConfiguration, $MultifaceGrowthConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$MultifaceGrowthConfiguration"
import {$RootSystemConfiguration, $RootSystemConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RootSystemConfiguration"
import {$UnderwaterMagmaConfiguration, $UnderwaterMagmaConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$UnderwaterMagmaConfiguration"
import {$RandomPatchConfiguration, $RandomPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomPatchConfiguration"
import {$ProbabilityFeatureConfiguration, $ProbabilityFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ProbabilityFeatureConfiguration"
import {$TreeConfiguration, $TreeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$TreeConfiguration"
import {$TwistingVinesConfig, $TwistingVinesConfig$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$TwistingVinesConfig"
import {$FeaturePlaceContext, $FeaturePlaceContext$Type} from "packages/net/minecraft/world/level/levelgen/feature/$FeaturePlaceContext"
import {$DripstoneClusterConfiguration, $DripstoneClusterConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DripstoneClusterConfiguration"
import {$LayerConfiguration, $LayerConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$LayerConfiguration"
import {$HugeMushroomFeatureConfiguration, $HugeMushroomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$HugeMushroomFeatureConfiguration"
import {$ReplaceBlockConfiguration, $ReplaceBlockConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ReplaceBlockConfiguration"
import {$BlockStateConfiguration, $BlockStateConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockStateConfiguration"
import {$SimpleBlockConfiguration, $SimpleBlockConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SimpleBlockConfiguration"
import {$HugeFungusConfiguration, $HugeFungusConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$HugeFungusConfiguration"
import {$DiskConfiguration, $DiskConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DiskConfiguration"
import {$SeagrassFeature, $SeagrassFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$SeagrassFeature"
import {$ReplaceSphereConfiguration, $ReplaceSphereConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ReplaceSphereConfiguration"
import {$FossilFeatureConfiguration, $FossilFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$FossilFeatureConfiguration"
import {$DeltaFeatureConfiguration, $DeltaFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DeltaFeatureConfiguration"
import {$PointedDripstoneConfiguration, $PointedDripstoneConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$PointedDripstoneConfiguration"
import {$SpringConfiguration, $SpringConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SpringConfiguration"
import {$BlockPileConfiguration, $BlockPileConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockPileConfiguration"
import {$OreConfiguration, $OreConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration"
import {$SimpleRandomFeatureConfiguration, $SimpleRandomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SimpleRandomFeatureConfiguration"
import {$SculkPatchConfiguration, $SculkPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SculkPatchConfiguration"
import {$NetherForestVegetationConfig, $NetherForestVegetationConfig$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$NetherForestVegetationConfig"
import {$GeodeConfiguration, $GeodeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$GeodeConfiguration"
import {$LargeDripstoneConfiguration, $LargeDripstoneConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$LargeDripstoneConfiguration"
import {$RandomBooleanFeatureConfiguration, $RandomBooleanFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomBooleanFeatureConfiguration"
import {$ColumnFeatureConfiguration, $ColumnFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ColumnFeatureConfiguration"
import {$CountConfiguration, $CountConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$CountConfiguration"
import {$VegetationPatchConfiguration, $VegetationPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$VegetationPatchConfiguration"
import {$Feature, $Feature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$Feature"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$NoneFeatureConfiguration"
import {$EndGatewayConfiguration, $EndGatewayConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$EndGatewayConfiguration"

export class $ResizableOreFeature extends $Feature<($ResizableOreFeatureConfig)> {
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>

constructor()

public "place"(context: $FeaturePlaceContext$Type<($ResizableOreFeatureConfig$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResizableOreFeature$Type = ($ResizableOreFeature);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResizableOreFeature_ = $ResizableOreFeature$Type;
}}
declare module "packages/mekanism/common/capabilities/chemical/$BoxedChemicalHandler" {
import {$IChemicalHandler, $IChemicalHandler$Type} from "packages/mekanism/api/chemical/$IChemicalHandler"
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$IInfusionHandler, $IInfusionHandler$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionHandler"
import {$ChemicalType, $ChemicalType$Type} from "packages/mekanism/api/chemical/$ChemicalType"
import {$NonNullConsumer, $NonNullConsumer$Type} from "packages/net/minecraftforge/common/util/$NonNullConsumer"
import {$ISlurryHandler, $ISlurryHandler$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryHandler"
import {$IPigmentHandler, $IPigmentHandler$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentHandler"
import {$IGasHandler, $IGasHandler$Type} from "packages/mekanism/api/chemical/gas/$IGasHandler"

export class $BoxedChemicalHandler {

constructor()

public "getHandlerFor"<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>>(chemicalType: $ChemicalType$Type): $IChemicalHandler<(CHEMICAL), (STACK)>
public "addInfusionHandler"(lazyHandler: $LazyOptional$Type<($IInfusionHandler$Type)>): void
public "addSlurryHandler"(lazyHandler: $LazyOptional$Type<($ISlurryHandler$Type)>): void
public "addPigmentHandler"(lazyHandler: $LazyOptional$Type<($IPigmentHandler$Type)>): void
public "sameHandlers"(other: $BoxedChemicalHandler$Type): boolean
public "addGasHandler"(lazyHandler: $LazyOptional$Type<($IGasHandler$Type)>): void
public "addRefreshListeners"(refreshListener: $NonNullConsumer$Type<($LazyOptional$Type<($BoxedChemicalHandler$Type)>)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoxedChemicalHandler$Type = ($BoxedChemicalHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoxedChemicalHandler_ = $BoxedChemicalHandler$Type;
}}
declare module "packages/mekanism/common/block/basic/$BlockFluidTank" {
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$Type} from "packages/mekanism/common/block/prefab/$BlockTile$BlockTileModel"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Machine, $Machine$Type} from "packages/mekanism/common/content/blocktype/$Machine"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$TileEntityFluidTank, $TileEntityFluidTank$Type} from "packages/mekanism/common/tile/$TileEntityFluidTank"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockFluidTank extends $BlockTile$BlockTileModel<($TileEntityFluidTank), ($Machine<($TileEntityFluidTank)>)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(type: $Machine$Type<($TileEntityFluidTank$Type)>)

public "getLightEmission"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type): integer
/**
 * 
 * @deprecated
 */
public "use"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockFluidTank$Type = ($BlockFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockFluidTank_ = $BlockFluidTank$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ChemicalDissolutionRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ChemicalDissolutionRecipe, $ChemicalDissolutionRecipe$Type} from "packages/mekanism/api/recipes/$ChemicalDissolutionRecipe"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$ChemicalDissolutionRecipeSerializer$IFactory, $ChemicalDissolutionRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$ChemicalDissolutionRecipeSerializer$IFactory"

export class $ChemicalDissolutionRecipeSerializer<RECIPE extends $ChemicalDissolutionRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(factory: $ChemicalDissolutionRecipeSerializer$IFactory$Type<(RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalDissolutionRecipeSerializer$Type<RECIPE> = ($ChemicalDissolutionRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalDissolutionRecipeSerializer_<RECIPE> = $ChemicalDissolutionRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/tile/component/config/slot/$ISlotInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ISlotInfo {

 "isEnabled"(): boolean
 "canInput"(): boolean
 "canOutput"(): boolean
}

export namespace $ISlotInfo {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISlotInfo$Type = ($ISlotInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISlotInfo_ = $ISlotInfo$Type;
}}
declare module "packages/mekanism/common/lib/multiblock/$IMultiblock" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$FormationProtocol, $FormationProtocol$Type} from "packages/mekanism/common/lib/multiblock/$FormationProtocol"
import {$MultiblockManager, $MultiblockManager$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockManager"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Structure, $Structure$Type} from "packages/mekanism/common/lib/multiblock/$Structure"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MultiblockData, $MultiblockData$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockData"
import {$IMultiblockBase, $IMultiblockBase$Type} from "packages/mekanism/common/lib/multiblock/$IMultiblockBase"

export interface $IMultiblock<T extends $MultiblockData> extends $IMultiblockBase {

 "getMultiblock"(): T
 "getManager"(): $MultiblockManager<(T)>
 "getStructure"(manager: $MultiblockManager$Type<(any)>): $Structure
 "getStructure"(): $Structure
 "createMultiblock"(): T
 "resetCache"(): void
 "getCacheID"(): $UUID
 "setStructure"(manager: $MultiblockManager$Type<(any)>, structure: $Structure$Type): void
 "setStructure"(structure: $Structure$Type): void
 "createFormationProtocol"(): $FormationProtocol<(T)>
 "getDefaultData"(): T
 "isMaster"(): boolean
 "canBeMaster"(): boolean
 "hasStructure"(structure: $Structure$Type): boolean
 "onActivate"(player: $Player$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type): $InteractionResult
 "resetForFormed"(): void
 "getMultiblockData"(manager: $MultiblockManager$Type<(any)>): $MultiblockData
 "resetStructure"(manager: $MultiblockManager$Type<(any)>): $Structure
 "setMultiblockData"(manager: $MultiblockManager$Type<(any)>, multiblockData: $MultiblockData$Type): void
 "getTilePos"(): $BlockPos
 "getTileWorld"(): $Level
 "getTileCoord"(): $Coord4D
 "getTileChunk"(): $Chunk3D
}

export namespace $IMultiblock {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMultiblock$Type<T> = ($IMultiblock<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMultiblock_<T> = $IMultiblock$Type<(T)>;
}}
declare module "packages/mekanism/common/inventory/container/slot/$InsertableSlot" {
import {$IInsertableSlot, $IInsertableSlot$Type} from "packages/mekanism/common/inventory/container/slot/$IInsertableSlot"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$SelectedWindowData, $SelectedWindowData$Type} from "packages/mekanism/common/inventory/container/$SelectedWindowData"

export class $InsertableSlot extends $Slot implements $IInsertableSlot {
readonly "slot": integer
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(inventory: $Container$Type, index: integer, x: integer, y: integer)

public "getMaxStackSize"(stack: $ItemStack$Type): integer
public "insertItem"(stack: $ItemStack$Type, action: $Action$Type): $ItemStack
public "exists"(windowData: $SelectedWindowData$Type): boolean
public "canMergeWith"(stack: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InsertableSlot$Type = ($InsertableSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InsertableSlot_ = $InsertableSlot$Type;
}}
declare module "packages/mekanism/common/lib/multiblock/$IInternalMultiblock" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$MultiblockData, $MultiblockData$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockData"

export interface $IInternalMultiblock {

 "getMultiblock"(): $MultiblockData
 "hasFormedMultiblock"(): boolean
 "setMultiblock"(multiblock: $MultiblockData$Type): void
 "getMultiblockUUID"(): $UUID
}

export namespace $IInternalMultiblock {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInternalMultiblock$Type = ($IInternalMultiblock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInternalMultiblock_ = $IInternalMultiblock$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ChemicalChemicalToChemicalRecipeSerializer" {
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$ChemicalStackIngredient, $ChemicalStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient"
import {$ChemicalChemicalToChemicalRecipe, $ChemicalChemicalToChemicalRecipe$Type} from "packages/mekanism/api/recipes/chemical/$ChemicalChemicalToChemicalRecipe"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ChemicalChemicalToChemicalRecipeSerializer<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, INGREDIENT extends $ChemicalStackIngredient<(CHEMICAL), (STACK)>, RECIPE extends $ChemicalChemicalToChemicalRecipe<(CHEMICAL), (STACK), (INGREDIENT)>> implements $RecipeSerializer<(RECIPE)> {


public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalChemicalToChemicalRecipeSerializer$Type<CHEMICAL, STACK, INGREDIENT, RECIPE> = ($ChemicalChemicalToChemicalRecipeSerializer<(CHEMICAL), (STACK), (INGREDIENT), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalChemicalToChemicalRecipeSerializer_<CHEMICAL, STACK, INGREDIENT, RECIPE> = $ChemicalChemicalToChemicalRecipeSerializer$Type<(CHEMICAL), (STACK), (INGREDIENT), (RECIPE)>;
}}
declare module "packages/mekanism/common/block/states/$IStateStorage" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IStateStorage {

}

export namespace $IStateStorage {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IStateStorage$Type = ($IStateStorage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IStateStorage_ = $IStateStorage$Type;
}}
declare module "packages/mekanism/common/upgrade/transmitter/$TransmitterUpgradeData" {
import {$ConnectionType, $ConnectionType$Type} from "packages/mekanism/common/lib/transmitter/$ConnectionType"
import {$IUpgradeData, $IUpgradeData$Type} from "packages/mekanism/common/upgrade/$IUpgradeData"

export class $TransmitterUpgradeData implements $IUpgradeData {
readonly "redstoneReactive": boolean
readonly "connectionTypes": ($ConnectionType)[]

constructor(redstoneReactive: boolean, connectionTypes: ($ConnectionType$Type)[])

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransmitterUpgradeData$Type = ($TransmitterUpgradeData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransmitterUpgradeData_ = $TransmitterUpgradeData$Type;
}}
declare module "packages/mekanism/common/inventory/container/$ITrackableContainer" {
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"

export interface $ITrackableContainer {

 "addContainerTrackers"(container: $MekanismContainer$Type): void

(container: $MekanismContainer$Type): void
}

export namespace $ITrackableContainer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITrackableContainer$Type = ($ITrackableContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITrackableContainer_ = $ITrackableContainer$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$ITileDirectional" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"

export interface $ITileDirectional {

 "getOppositeDirection"(): $Direction
 "getDirection"(): $Direction
 "setFacing"(direction: $Direction$Type): void
 "isDirectional"(): boolean
 "getLeftSide"(): $Direction
 "getRightSide"(): $Direction
}

export namespace $ITileDirectional {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileDirectional$Type = ($ITileDirectional);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileDirectional_ = $ITileDirectional$Type;
}}
declare module "packages/mekanism/common/inventory/container/type/$MekanismItemContainerType" {
import {$LecternMenu, $LecternMenu$Type} from "packages/net/minecraft/world/inventory/$LecternMenu"
import {$DispenserMenu, $DispenserMenu$Type} from "packages/net/minecraft/world/inventory/$DispenserMenu"
import {$BaseMekanismContainerType, $BaseMekanismContainerType$Type} from "packages/mekanism/common/inventory/container/type/$BaseMekanismContainerType"
import {$SmithingMenu, $SmithingMenu$Type} from "packages/net/minecraft/world/inventory/$SmithingMenu"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IContainerFactory, $IContainerFactory$Type} from "packages/net/minecraftforge/network/$IContainerFactory"
import {$GrindstoneMenu, $GrindstoneMenu$Type} from "packages/net/minecraft/world/inventory/$GrindstoneMenu"
import {$LoomMenu, $LoomMenu$Type} from "packages/net/minecraft/world/inventory/$LoomMenu"
import {$MerchantMenu, $MerchantMenu$Type} from "packages/net/minecraft/world/inventory/$MerchantMenu"
import {$MenuConstructor, $MenuConstructor$Type} from "packages/net/minecraft/world/inventory/$MenuConstructor"
import {$BeaconMenu, $BeaconMenu$Type} from "packages/net/minecraft/world/inventory/$BeaconMenu"
import {$StonecutterMenu, $StonecutterMenu$Type} from "packages/net/minecraft/world/inventory/$StonecutterMenu"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$ChestMenu, $ChestMenu$Type} from "packages/net/minecraft/world/inventory/$ChestMenu"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$SmokerMenu, $SmokerMenu$Type} from "packages/net/minecraft/world/inventory/$SmokerMenu"
import {$FurnaceMenu, $FurnaceMenu$Type} from "packages/net/minecraft/world/inventory/$FurnaceMenu"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$AnvilMenu, $AnvilMenu$Type} from "packages/net/minecraft/world/inventory/$AnvilMenu"
import {$CraftingMenu, $CraftingMenu$Type} from "packages/net/minecraft/world/inventory/$CraftingMenu"
import {$CartographyTableMenu, $CartographyTableMenu$Type} from "packages/net/minecraft/world/inventory/$CartographyTableMenu"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ShulkerBoxMenu, $ShulkerBoxMenu$Type} from "packages/net/minecraft/world/inventory/$ShulkerBoxMenu"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$EnchantmentMenu, $EnchantmentMenu$Type} from "packages/net/minecraft/world/inventory/$EnchantmentMenu"
import {$HopperMenu, $HopperMenu$Type} from "packages/net/minecraft/world/inventory/$HopperMenu"
import {$MekanismItemContainerType$IMekanismSidedItemContainerFactory, $MekanismItemContainerType$IMekanismSidedItemContainerFactory$Type} from "packages/mekanism/common/inventory/container/type/$MekanismItemContainerType$IMekanismSidedItemContainerFactory"
import {$BrewingStandMenu, $BrewingStandMenu$Type} from "packages/net/minecraft/world/inventory/$BrewingStandMenu"
import {$BlastFurnaceMenu, $BlastFurnaceMenu$Type} from "packages/net/minecraft/world/inventory/$BlastFurnaceMenu"
import {$MekanismItemContainerType$IMekanismItemContainerFactory, $MekanismItemContainerType$IMekanismItemContainerFactory$Type} from "packages/mekanism/common/inventory/container/type/$MekanismItemContainerType$IMekanismItemContainerFactory"

export class $MekanismItemContainerType<ITEM extends $Item, CONTAINER extends $AbstractContainerMenu> extends $BaseMekanismContainerType<(ITEM), (CONTAINER), ($MekanismItemContainerType$IMekanismItemContainerFactory<(ITEM), (CONTAINER)>)> {
static readonly "GENERIC_9x1": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x2": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x3": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x4": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x5": $MenuType<($ChestMenu)>
static readonly "GENERIC_9x6": $MenuType<($ChestMenu)>
static readonly "GENERIC_3x3": $MenuType<($DispenserMenu)>
static readonly "ANVIL": $MenuType<($AnvilMenu)>
static readonly "BEACON": $MenuType<($BeaconMenu)>
static readonly "BLAST_FURNACE": $MenuType<($BlastFurnaceMenu)>
static readonly "BREWING_STAND": $MenuType<($BrewingStandMenu)>
static readonly "CRAFTING": $MenuType<($CraftingMenu)>
static readonly "ENCHANTMENT": $MenuType<($EnchantmentMenu)>
static readonly "FURNACE": $MenuType<($FurnaceMenu)>
static readonly "GRINDSTONE": $MenuType<($GrindstoneMenu)>
static readonly "HOPPER": $MenuType<($HopperMenu)>
static readonly "LECTERN": $MenuType<($LecternMenu)>
static readonly "LOOM": $MenuType<($LoomMenu)>
static readonly "MERCHANT": $MenuType<($MerchantMenu)>
static readonly "SHULKER_BOX": $MenuType<($ShulkerBoxMenu)>
static readonly "SMITHING": $MenuType<($SmithingMenu)>
static readonly "SMOKER": $MenuType<($SmokerMenu)>
static readonly "CARTOGRAPHY_TABLE": $MenuType<($CartographyTableMenu)>
static readonly "STONECUTTER": $MenuType<($StonecutterMenu)>


public "create"(id: integer, inv: $Inventory$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type): CONTAINER
public "create"(hand: $InteractionHand$Type, stack: $ItemStack$Type): $MenuConstructor
public static "item"<ITEM extends $Item, CONTAINER extends $AbstractContainerMenu>(type: $Class$Type<(ITEM)>, arg1: $MekanismItemContainerType$IMekanismItemContainerFactory$Type<(ITEM), (CONTAINER)>): $MekanismItemContainerType<(ITEM), (CONTAINER)>
public static "item"<ITEM extends $Item, CONTAINER extends $AbstractContainerMenu>(type: $Class$Type<(ITEM)>, arg1: $MekanismItemContainerType$IMekanismSidedItemContainerFactory$Type<(ITEM), (CONTAINER)>): $MekanismItemContainerType<(ITEM), (CONTAINER)>
public static "create"<T extends $AbstractContainerMenu>(arg0: $IContainerFactory$Type<(T)>): $MenuType<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismItemContainerType$Type<ITEM, CONTAINER> = ($MekanismItemContainerType<(ITEM), (CONTAINER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismItemContainerType_<ITEM, CONTAINER> = $MekanismItemContainerType$Type<(ITEM), (CONTAINER)>;
}}
declare module "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager" {
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$IChemicalHandler, $IChemicalHandler$Type} from "packages/mekanism/api/chemical/$IChemicalHandler"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$CapabilityHandlerManager, $CapabilityHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$CapabilityHandlerManager"
import {$IChemicalTank, $IChemicalTank$Type} from "packages/mekanism/api/chemical/$IChemicalTank"
import {$IChemicalTankHolder, $IChemicalTankHolder$Type} from "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder"

export class $ChemicalHandlerManager<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, TANK extends $IChemicalTank<(CHEMICAL), (STACK)>, HANDLER extends $IChemicalHandler<(CHEMICAL), (STACK)>, SIDED_HANDLER extends HANDLER> extends $CapabilityHandlerManager<($IChemicalTankHolder<(CHEMICAL), (STACK), (TANK)>), (TANK), (HANDLER), (SIDED_HANDLER)> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalHandlerManager$Type<CHEMICAL, STACK, TANK, HANDLER, SIDED_HANDLER> = ($ChemicalHandlerManager<(CHEMICAL), (STACK), (TANK), (HANDLER), (SIDED_HANDLER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalHandlerManager_<CHEMICAL, STACK, TANK, HANDLER, SIDED_HANDLER> = $ChemicalHandlerManager$Type<(CHEMICAL), (STACK), (TANK), (HANDLER), (SIDED_HANDLER)>;
}}
declare module "packages/mekanism/common/item/$CapabilityItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CapabilityItem extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer


public "initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CapabilityItem$Type = ($CapabilityItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CapabilityItem_ = $CapabilityItem$Type;
}}
declare module "packages/mekanism/common/registration/impl/$BlockRegistryObject" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$DoubleWrappedRegistryObject, $DoubleWrappedRegistryObject$Type} from "packages/mekanism/common/registration/$DoubleWrappedRegistryObject"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $BlockRegistryObject<BLOCK extends $Block, ITEM extends $Item> extends $DoubleWrappedRegistryObject<(BLOCK), (ITEM)> implements $IBlockProvider {

constructor(blockRegistryObject: $RegistryObject$Type<(BLOCK)>, itemRegistryObject: $RegistryObject$Type<(ITEM)>)

public "getBlock"(): BLOCK
public "asItem"(): ITEM
public "getTranslationKey"(): string
public "getRegistryName"(): $ResourceLocation
public "getItemStack"(arg0: integer): $ItemStack
public "getItemStack"(): $ItemStack
public "getName"(): string
public "getTextComponent"(): $Component
get "block"(): BLOCK
get "translationKey"(): string
get "registryName"(): $ResourceLocation
get "itemStack"(): $ItemStack
get "name"(): string
get "textComponent"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRegistryObject$Type<BLOCK, ITEM> = ($BlockRegistryObject<(BLOCK), (ITEM)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockRegistryObject_<BLOCK, ITEM> = $BlockRegistryObject$Type<(BLOCK), (ITEM)>;
}}
declare module "packages/mekanism/common/block/interfaces/$IHasDescription" {
import {$ILangEntry, $ILangEntry$Type} from "packages/mekanism/api/text/$ILangEntry"

export interface $IHasDescription {

 "getDescription"(): $ILangEntry

(): $ILangEntry
}

export namespace $IHasDescription {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHasDescription$Type = ($IHasDescription);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHasDescription_ = $IHasDescription$Type;
}}
declare module "packages/mekanism/common/lib/frequency/$FrequencyManager" {
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$FrequencyType, $FrequencyType$Type} from "packages/mekanism/common/lib/frequency/$FrequencyType"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$Type} from "packages/mekanism/common/lib/frequency/$Frequency$FrequencyIdentity"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export class $FrequencyManager<FREQ extends $Frequency> {
static readonly "MAX_FREQ_LENGTH": integer

constructor(frequencyType: $FrequencyType$Type<(FREQ)>)
constructor(frequencyType: $FrequencyType$Type<(FREQ)>, uuid: $UUID$Type)

public "getName"(): string
public "remove"(key: any, ownerUUID: $UUID$Type): boolean
public static "load"(): void
public "getType"(): $FrequencyType<(FREQ)>
public static "reset"(): void
public "deactivate"(freq: $Frequency$Type, tile: $BlockEntity$Type): void
public "getOrCreateFrequency"(identity: $Frequency$FrequencyIdentity$Type, ownerUUID: $UUID$Type): FREQ
public "getFrequency"(key: any): FREQ
public static "tick"(): void
public "createOrLoad"(): void
public "getFrequencies"(): $Collection<(FREQ)>
public "validateAndUpdate"(tile: $BlockEntity$Type, freq: FREQ): FREQ
public "addFrequency"(freq: FREQ): void
get "name"(): string
get "type"(): $FrequencyType<(FREQ)>
get "frequencies"(): $Collection<(FREQ)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrequencyManager$Type<FREQ> = ($FrequencyManager<(FREQ)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FrequencyManager_<FREQ> = $FrequencyManager$Type<(FREQ)>;
}}
declare module "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager$PigmentHandlerManager" {
import {$IPigmentHandler$ISidedPigmentHandler, $IPigmentHandler$ISidedPigmentHandler$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentHandler$ISidedPigmentHandler"
import {$IPigmentTank, $IPigmentTank$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentTank"
import {$ChemicalHandlerManager, $ChemicalHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager"
import {$Pigment, $Pigment$Type} from "packages/mekanism/api/chemical/pigment/$Pigment"
import {$IChemicalTankHolder, $IChemicalTankHolder$Type} from "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder"
import {$IPigmentHandler, $IPigmentHandler$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentHandler"
import {$PigmentStack, $PigmentStack$Type} from "packages/mekanism/api/chemical/pigment/$PigmentStack"

export class $ChemicalHandlerManager$PigmentHandlerManager extends $ChemicalHandlerManager<($Pigment), ($PigmentStack), ($IPigmentTank), ($IPigmentHandler), ($IPigmentHandler$ISidedPigmentHandler)> {

constructor(holder: $IChemicalTankHolder$Type<($Pigment$Type), ($PigmentStack$Type), ($IPigmentTank$Type)>, baseHandler: $IPigmentHandler$ISidedPigmentHandler$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalHandlerManager$PigmentHandlerManager$Type = ($ChemicalHandlerManager$PigmentHandlerManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalHandlerManager$PigmentHandlerManager_ = $ChemicalHandlerManager$PigmentHandlerManager$Type;
}}
declare module "packages/mekanism/common/tile/$TileEntityBin" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BinTier, $BinTier$Type} from "packages/mekanism/common/tier/$BinTier"
import {$IConfigurable, $IConfigurable$Type} from "packages/mekanism/api/$IConfigurable"
import {$BinUpgradeData, $BinUpgradeData$Type} from "packages/mekanism/common/upgrade/$BinUpgradeData"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$BinInventorySlot, $BinInventorySlot$Type} from "packages/mekanism/common/inventory/slot/$BinInventorySlot"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IUpgradeData, $IUpgradeData$Type} from "packages/mekanism/common/upgrade/$IUpgradeData"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export class $TileEntityBin extends $TileEntityMekanism implements $IConfigurable {
 "addTicks": integer
 "removeTicks": integer
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "getItemCount"(): integer
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "onContentsChanged"(): void
public "getTier"(): $BinTier
public "setLocked"(isLocked: boolean): boolean
public "getUpgradeData"(): $BinUpgradeData
public "onRightClick"(player: $Player$Type): $InteractionResult
public "toggleLock"(): boolean
public "parseUpgradeData"(upgradeData: $IUpgradeData$Type): void
public "getReducedUpdateTag"(): $CompoundTag
public "getBinSlot"(): $BinInventorySlot
public "onSneakRightClick"(player: $Player$Type): $InteractionResult
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "itemCount"(): integer
get "tier"(): $BinTier
set "locked"(value: boolean)
get "upgradeData"(): $BinUpgradeData
get "reducedUpdateTag"(): $CompoundTag
get "binSlot"(): $BinInventorySlot
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityBin$Type = ($TileEntityBin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityBin_ = $TileEntityBin$Type;
}}
declare module "packages/mekanism/common/block/basic/$BlockStructuralGlass" {
import {$TileEntityStructuralMultiblock, $TileEntityStructuralMultiblock$Type} from "packages/mekanism/common/tile/prefab/$TileEntityStructuralMultiblock"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$BlockTileGlass, $BlockTileGlass$Type} from "packages/mekanism/common/block/prefab/$BlockTileGlass"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockStructuralGlass<TILE extends $TileEntityStructuralMultiblock> extends $BlockTileGlass<(TILE), ($BlockTypeTile<(TILE)>)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(type: $BlockTypeTile$Type<(TILE)>)

/**
 * 
 * @deprecated
 */
public "use"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStructuralGlass$Type<TILE> = ($BlockStructuralGlass<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStructuralGlass_<TILE> = $BlockStructuralGlass$Type<(TILE)>;
}}
declare module "packages/mekanism/common/block/transmitter/$BlockThermodynamicConductor" {
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$ITypeBlock, $ITypeBlock$Type} from "packages/mekanism/common/block/interfaces/$ITypeBlock"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockType, $BlockType$Type} from "packages/mekanism/common/content/blocktype/$BlockType"
import {$IHasTileEntity, $IHasTileEntity$Type} from "packages/mekanism/common/block/interfaces/$IHasTileEntity"
import {$BlockSmallTransmitter, $BlockSmallTransmitter$Type} from "packages/mekanism/common/block/transmitter/$BlockSmallTransmitter"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ConductorTier, $ConductorTier$Type} from "packages/mekanism/common/tier/$ConductorTier"
import {$TileEntityThermodynamicConductor, $TileEntityThermodynamicConductor$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityThermodynamicConductor"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export class $BlockThermodynamicConductor extends $BlockSmallTransmitter implements $ITypeBlock, $IHasTileEntity<($TileEntityThermodynamicConductor)> {
static readonly "CENTER": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(tier: $ConductorTier$Type)

public "getType"(): $BlockType
public "getTileType"(): $TileEntityTypeRegistryObject<($TileEntityThermodynamicConductor)>
public "createDummyBlockEntity"(state: $BlockState$Type): $TileEntityThermodynamicConductor
public "createDummyBlockEntity"(): $TileEntityThermodynamicConductor
public "triggerBlockEntityEvent"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, id: integer, param: integer): boolean
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $TileEntityThermodynamicConductor
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
get "type"(): $BlockType
get "tileType"(): $TileEntityTypeRegistryObject<($TileEntityThermodynamicConductor)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockThermodynamicConductor$Type = ($BlockThermodynamicConductor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockThermodynamicConductor_ = $BlockThermodynamicConductor$Type;
}}
declare module "packages/mekanism/common/network/to_client/container/property/$PropertyType" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ISyncableData, $ISyncableData$Type} from "packages/mekanism/common/inventory/container/sync/$ISyncableData"
import {$PropertyData, $PropertyData$Type} from "packages/mekanism/common/network/to_client/container/property/$PropertyData"

export class $PropertyType extends $Enum<($PropertyType)> {
static readonly "BOOLEAN": $PropertyType
static readonly "BYTE": $PropertyType
static readonly "DOUBLE": $PropertyType
static readonly "FLOAT": $PropertyType
static readonly "INT": $PropertyType
static readonly "LONG": $PropertyType
static readonly "SHORT": $PropertyType
static readonly "REGISTRY_ENTRY": $PropertyType
static readonly "ITEM_STACK": $PropertyType
static readonly "FLUID_STACK": $PropertyType
static readonly "GAS_STACK": $PropertyType
static readonly "INFUSION_STACK": $PropertyType
static readonly "PIGMENT_STACK": $PropertyType
static readonly "SLURRY_STACK": $PropertyType
static readonly "FREQUENCY": $PropertyType
static readonly "LIST": $PropertyType
static readonly "BLOCK_POS": $PropertyType
static readonly "FLOATING_LONG": $PropertyType


public static "values"(): ($PropertyType)[]
public static "valueOf"(name: string): $PropertyType
public "getDefault"<T>(): T
public "create"(supplier: $Supplier$Type<(any)>, consumer: $Consumer$Type<(any)>): $ISyncableData
public "createData"(property: short, buffer: $FriendlyByteBuf$Type): $PropertyData
public static "getFromType"(type: $Class$Type<(any)>): $PropertyType
get "default"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyType$Type = (("fluid_stack") | ("registry_entry") | ("byte") | ("double") | ("pigment_stack") | ("block_pos") | ("infusion_stack") | ("floating_long") | ("float") | ("gas_stack") | ("list") | ("int") | ("long") | ("frequency") | ("boolean") | ("slurry_stack") | ("short") | ("item_stack")) | ($PropertyType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyType_ = $PropertyType$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$IRedstoneControl" {
import {$IRedstoneControl$RedstoneControl, $IRedstoneControl$RedstoneControl$Type} from "packages/mekanism/common/tile/interfaces/$IRedstoneControl$RedstoneControl"

export interface $IRedstoneControl {

 "getControlType"(): $IRedstoneControl$RedstoneControl
 "isPowered"(): boolean
 "wasPowered"(): boolean
 "setControlType"(type: $IRedstoneControl$RedstoneControl$Type): void
 "canPulse"(): boolean
}

export namespace $IRedstoneControl {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRedstoneControl$Type = ($IRedstoneControl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRedstoneControl_ = $IRedstoneControl$Type;
}}
declare module "packages/mekanism/common/world/$ResizableDiskReplaceFeature" {
import {$BonusChestFeature, $BonusChestFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$BonusChestFeature"
import {$RandomFeatureConfiguration, $RandomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomFeatureConfiguration"
import {$SpikeConfiguration, $SpikeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SpikeConfiguration"
import {$LakeFeature$Configuration, $LakeFeature$Configuration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$LakeFeature$Configuration"
import {$BlockColumnConfiguration, $BlockColumnConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockColumnConfiguration"
import {$MultifaceGrowthConfiguration, $MultifaceGrowthConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$MultifaceGrowthConfiguration"
import {$RootSystemConfiguration, $RootSystemConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RootSystemConfiguration"
import {$UnderwaterMagmaConfiguration, $UnderwaterMagmaConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$UnderwaterMagmaConfiguration"
import {$RandomPatchConfiguration, $RandomPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomPatchConfiguration"
import {$ProbabilityFeatureConfiguration, $ProbabilityFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ProbabilityFeatureConfiguration"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$TreeConfiguration, $TreeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$TreeConfiguration"
import {$TwistingVinesConfig, $TwistingVinesConfig$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$TwistingVinesConfig"
import {$FeaturePlaceContext, $FeaturePlaceContext$Type} from "packages/net/minecraft/world/level/levelgen/feature/$FeaturePlaceContext"
import {$DripstoneClusterConfiguration, $DripstoneClusterConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DripstoneClusterConfiguration"
import {$LayerConfiguration, $LayerConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$LayerConfiguration"
import {$HugeMushroomFeatureConfiguration, $HugeMushroomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$HugeMushroomFeatureConfiguration"
import {$ReplaceBlockConfiguration, $ReplaceBlockConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ReplaceBlockConfiguration"
import {$BlockStateConfiguration, $BlockStateConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockStateConfiguration"
import {$SimpleBlockConfiguration, $SimpleBlockConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SimpleBlockConfiguration"
import {$HugeFungusConfiguration, $HugeFungusConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$HugeFungusConfiguration"
import {$DiskConfiguration, $DiskConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DiskConfiguration"
import {$SeagrassFeature, $SeagrassFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$SeagrassFeature"
import {$ReplaceSphereConfiguration, $ReplaceSphereConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ReplaceSphereConfiguration"
import {$FossilFeatureConfiguration, $FossilFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/$FossilFeatureConfiguration"
import {$DeltaFeatureConfiguration, $DeltaFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$DeltaFeatureConfiguration"
import {$PointedDripstoneConfiguration, $PointedDripstoneConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$PointedDripstoneConfiguration"
import {$SpringConfiguration, $SpringConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SpringConfiguration"
import {$BlockPileConfiguration, $BlockPileConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$BlockPileConfiguration"
import {$OreConfiguration, $OreConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration"
import {$SimpleRandomFeatureConfiguration, $SimpleRandomFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SimpleRandomFeatureConfiguration"
import {$SculkPatchConfiguration, $SculkPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$SculkPatchConfiguration"
import {$NetherForestVegetationConfig, $NetherForestVegetationConfig$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$NetherForestVegetationConfig"
import {$GeodeConfiguration, $GeodeConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$GeodeConfiguration"
import {$LargeDripstoneConfiguration, $LargeDripstoneConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$LargeDripstoneConfiguration"
import {$RandomBooleanFeatureConfiguration, $RandomBooleanFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$RandomBooleanFeatureConfiguration"
import {$ColumnFeatureConfiguration, $ColumnFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$ColumnFeatureConfiguration"
import {$CountConfiguration, $CountConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$CountConfiguration"
import {$VegetationPatchConfiguration, $VegetationPatchConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$VegetationPatchConfiguration"
import {$Feature, $Feature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$Feature"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$NoneFeatureConfiguration"
import {$EndGatewayConfiguration, $EndGatewayConfiguration$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$EndGatewayConfiguration"
import {$ResizableDiskConfig, $ResizableDiskConfig$Type} from "packages/mekanism/common/world/$ResizableDiskConfig"

export class $ResizableDiskReplaceFeature extends $Feature<($ResizableDiskConfig)> {
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>

constructor(codec: $Codec$Type<($ResizableDiskConfig$Type)>)

public "place"(context: $FeaturePlaceContext$Type<($ResizableDiskConfig$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResizableDiskReplaceFeature$Type = ($ResizableDiskReplaceFeature);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResizableDiskReplaceFeature_ = $ResizableDiskReplaceFeature$Type;
}}
declare module "packages/mekanism/common/tile/transmitter/$TileEntityMechanicalPipe" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$TransmitterType, $TransmitterType$Type} from "packages/mekanism/common/block/states/$TransmitterType"
import {$TransmitterModelData, $TransmitterModelData$Type} from "packages/mekanism/client/model/data/$TransmitterModelData"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$BoundMethodHolder, $BoundMethodHolder$Type} from "packages/mekanism/common/integration/computer/$BoundMethodHolder"
import {$IComputerTile, $IComputerTile$Type} from "packages/mekanism/common/integration/computer/$IComputerTile"
import {$ConnectionType, $ConnectionType$Type} from "packages/mekanism/common/lib/transmitter/$ConnectionType"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $TileEntityMechanicalPipe extends $TileEntityTransmitter implements $IComputerTile {
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "getUpdateTag"(): $CompoundTag
public "getTransmitterType"(): $TransmitterType
public "getComputerName"(): string
public "sideChanged"(side: $Direction$Type, old: $ConnectionType$Type, type: $ConnectionType$Type): void
public "redstoneChanged"(powered: boolean): void
public "isComputerCapabilityPersistent"(): boolean
public "hasComputerSupport"(): boolean
public "getComputerMethods"(holder: $BoundMethodHolder$Type): void
get "updateTag"(): $CompoundTag
get "transmitterType"(): $TransmitterType
get "computerName"(): string
get "computerCapabilityPersistent"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityMechanicalPipe$Type = ($TileEntityMechanicalPipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityMechanicalPipe_ = $TileEntityMechanicalPipe$Type;
}}
declare module "packages/mekanism/common/lib/multiblock/$FormationProtocol" {
import {$IValveHandler$ValveData, $IValveHandler$ValveData$Type} from "packages/mekanism/common/lib/multiblock/$IValveHandler$ValveData"
import {$FormationProtocol$FormationResult, $FormationProtocol$FormationResult$Type} from "packages/mekanism/common/lib/multiblock/$FormationProtocol$FormationResult"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$MultiblockCache, $MultiblockCache$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockCache"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Structure, $Structure$Type} from "packages/mekanism/common/lib/multiblock/$Structure"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MultiblockData, $MultiblockData$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockData"
import {$IMultiblock, $IMultiblock$Type} from "packages/mekanism/common/lib/multiblock/$IMultiblock"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $FormationProtocol<T extends $MultiblockData> {
static readonly "MAX_SIZE": integer
readonly "locations": $Set<($BlockPos)>
readonly "internalLocations": $Set<($BlockPos)>
readonly "valves": $Set<($IValveHandler$ValveData)>
readonly "idsFound": $Map<($UUID), ($MultiblockCache<(T)>)>

constructor(tile: $IMultiblock$Type<(T)>, structure: $Structure$Type)

public "doUpdate"(): $FormationProtocol$FormationResult
public static "explore"(start: $BlockPos$Type, checker: $Predicate$Type<($BlockPos$Type)>, maxCount: integer): integer
public static "explore"(start: $BlockPos$Type, checker: $Predicate$Type<($BlockPos$Type)>): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FormationProtocol$Type<T> = ($FormationProtocol<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FormationProtocol_<T> = $FormationProtocol$Type<(T)>;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$ItemChemical" {
import {$ChemicalStackIngredient, $ChemicalStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient"
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$ItemInputCache, $ItemInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$ItemInputCache"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$ChemicalInputCache, $ChemicalInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$ChemicalInputCache"
import {$DoubleInputRecipeCache, $DoubleInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$DoubleInputRecipeCache"
import {$MekanismRecipeType, $MekanismRecipeType$Type} from "packages/mekanism/common/recipe/$MekanismRecipeType"
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"

export class $InputRecipeCache$ItemChemical<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, RECIPE extends ($MekanismRecipe) & ($BiPredicate<($ItemStack), (STACK)>)> extends $DoubleInputRecipeCache<($ItemStack), ($ItemStackIngredient), (STACK), ($ChemicalStackIngredient<(CHEMICAL), (STACK)>), (RECIPE), ($ItemInputCache<(RECIPE)>), ($ChemicalInputCache<(CHEMICAL), (STACK), (RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$Type<(RECIPE), (any)>, inputAExtractor: $Function$Type<(RECIPE), ($ItemStackIngredient$Type)>, inputBExtractor: $Function$Type<(RECIPE), ($ChemicalStackIngredient$Type<(CHEMICAL), (STACK)>)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$ItemChemical$Type<CHEMICAL, STACK, RECIPE> = ($InputRecipeCache$ItemChemical<(CHEMICAL), (STACK), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$ItemChemical_<CHEMICAL, STACK, RECIPE> = $InputRecipeCache$ItemChemical$Type<(CHEMICAL), (STACK), (RECIPE)>;
}}
declare module "packages/mekanism/common/tile/component/$TileComponentUpgrade" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UpgradeInventorySlot, $UpgradeInventorySlot$Type} from "packages/mekanism/common/inventory/slot/$UpgradeInventorySlot"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$ITileComponent, $ITileComponent$Type} from "packages/mekanism/common/tile/component/$ITileComponent"
import {$Upgrade, $Upgrade$Type} from "packages/mekanism/api/$Upgrade"
import {$ISyncableData, $ISyncableData$Type} from "packages/mekanism/common/inventory/container/sync/$ISyncableData"
import {$MekanismContainer$ISpecificContainerTracker, $MekanismContainer$ISpecificContainerTracker$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer$ISpecificContainerTracker"

export class $TileComponentUpgrade implements $ITileComponent, $MekanismContainer$ISpecificContainerTracker {

constructor(tile: $TileEntityMekanism$Type)

public "write"(nbtTags: $CompoundTag$Type): void
public "read"(nbtTags: $CompoundTag$Type): void
public "getSupportedTypes"(): $Set<($Upgrade)>
public "addUpgrades"(upgrade: $Upgrade$Type, maxAvailable: integer): integer
public "readFromUpdateTag"(updateTag: $CompoundTag$Type): void
public "addToUpdateTag"(updateTag: $CompoundTag$Type): void
public "supports"(upgrade: $Upgrade$Type): boolean
public "getUpgradeOutputSlot"(): $UpgradeInventorySlot
public "isUpgradeInstalled"(upgrade: $Upgrade$Type): boolean
public "getUpgrades"(upgrade: $Upgrade$Type): integer
public "removeUpgrade"(upgrade: $Upgrade$Type, removeAll: boolean): void
public "tickServer"(): void
public "getUpgradeSlot"(): $UpgradeInventorySlot
public "getSpecificSyncableData"(): $List<($ISyncableData)>
public "setSupported"(upgrade: $Upgrade$Type): void
public "setSupported"(upgrade: $Upgrade$Type, isSupported: boolean): void
public "getInstalledTypes"(): $Set<($Upgrade)>
public "getScaledUpgradeProgress"(): double
public "removed"(): void
public "invalidate"(): void
public "trackForMainContainer"(container: $MekanismContainer$Type): void
get "supportedTypes"(): $Set<($Upgrade)>
get "upgradeOutputSlot"(): $UpgradeInventorySlot
get "upgradeSlot"(): $UpgradeInventorySlot
get "specificSyncableData"(): $List<($ISyncableData)>
set "supported"(value: $Upgrade$Type)
get "installedTypes"(): $Set<($Upgrade)>
get "scaledUpgradeProgress"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileComponentUpgrade$Type = ($TileComponentUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileComponentUpgrade_ = $TileComponentUpgrade$Type;
}}
declare module "packages/mekanism/common/item/block/transmitter/$ItemBlockPressurizedTube" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemBlockMekanism, $ItemBlockMekanism$Type} from "packages/mekanism/common/item/block/$ItemBlockMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPressurizedTube, $BlockPressurizedTube$Type} from "packages/mekanism/common/block/transmitter/$BlockPressurizedTube"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockPressurizedTube extends $ItemBlockMekanism<($BlockPressurizedTube)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockPressurizedTube$Type)

public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockPressurizedTube$Type = ($ItemBlockPressurizedTube);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockPressurizedTube_ = $ItemBlockPressurizedTube$Type;
}}
declare module "packages/mekanism/common/resource/ore/$BaseOreConfig" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$OreAnchor, $OreAnchor$Type} from "packages/mekanism/common/resource/ore/$OreAnchor"
import {$HeightShape, $HeightShape$Type} from "packages/mekanism/common/world/height/$HeightShape"

export class $BaseOreConfig extends $Record {

constructor(name: string, perChunk: integer, discardChanceOnAirExposure: float, maxVeinSize: integer, shape: $HeightShape$Type, min: $OreAnchor$Type, max: $OreAnchor$Type, plateau: integer)
constructor(name: string, perChunk: integer, discardChanceOnAirExposure: float, maxVeinSize: integer, shape: $HeightShape$Type, min: $OreAnchor$Type, max: $OreAnchor$Type)

public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "min"(): $OreAnchor
public "max"(): $OreAnchor
public "shape"(): $HeightShape
public "discardChanceOnAirExposure"(): float
public "plateau"(): integer
public "maxVeinSize"(): integer
public "perChunk"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseOreConfig$Type = ($BaseOreConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseOreConfig_ = $BaseOreConfig$Type;
}}
declare module "packages/mekanism/common/tile/transmitter/$TileEntityUniversalCable" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$TransmitterType, $TransmitterType$Type} from "packages/mekanism/common/block/states/$TransmitterType"
import {$TransmitterModelData, $TransmitterModelData$Type} from "packages/mekanism/client/model/data/$TransmitterModelData"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$BoundMethodHolder, $BoundMethodHolder$Type} from "packages/mekanism/common/integration/computer/$BoundMethodHolder"
import {$IComputerTile, $IComputerTile$Type} from "packages/mekanism/common/integration/computer/$IComputerTile"
import {$ConnectionType, $ConnectionType$Type} from "packages/mekanism/common/lib/transmitter/$ConnectionType"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $TileEntityUniversalCable extends $TileEntityTransmitter implements $IComputerTile {
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "getUpdateTag"(): $CompoundTag
public "getTransmitterType"(): $TransmitterType
public "getComputerName"(): string
public "sideChanged"(side: $Direction$Type, old: $ConnectionType$Type, type: $ConnectionType$Type): void
public "redstoneChanged"(powered: boolean): void
public "isComputerCapabilityPersistent"(): boolean
public "hasComputerSupport"(): boolean
public "getComputerMethods"(holder: $BoundMethodHolder$Type): void
get "updateTag"(): $CompoundTag
get "transmitterType"(): $TransmitterType
get "computerName"(): string
get "computerCapabilityPersistent"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityUniversalCable$Type = ($TileEntityUniversalCable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityUniversalCable_ = $TileEntityUniversalCable$Type;
}}
declare module "packages/mekanism/common/block/prefab/$BlockTile" {
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IHasTileEntity, $IHasTileEntity$Type} from "packages/mekanism/common/block/interfaces/$IHasTileEntity"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockBase, $BlockBase$Type} from "packages/mekanism/common/block/prefab/$BlockBase"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export class $BlockTile<TILE extends $TileEntityMekanism, TYPE extends $BlockTypeTile<(TILE)>> extends $BlockBase<(TYPE)> implements $IHasTileEntity<(TILE)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(type: TYPE, propertiesModifier: $UnaryOperator$Type<($BlockBehaviour$Properties$Type)>)
constructor(type: TYPE, properties: $BlockBehaviour$Properties$Type)

public "animateTick"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, random: $RandomSource$Type): void
public "canConnectRedstone"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, side: $Direction$Type): boolean
/**
 * 
 * @deprecated
 */
public "neighborChanged"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, neighborBlock: $Block$Type, neighborPos: $BlockPos$Type, isMoving: boolean): void
/**
 * 
 * @deprecated
 */
public "use"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
/**
 * 
 * @deprecated
 */
public "isSignalSource"(state: $BlockState$Type): boolean
/**
 * 
 * @deprecated
 */
public "getSignal"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, side: $Direction$Type): integer
public "getTileType"(): $TileEntityTypeRegistryObject<(TILE)>
public "createDummyBlockEntity"(state: $BlockState$Type): TILE
public "createDummyBlockEntity"(): TILE
public "triggerBlockEntityEvent"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, id: integer, param: integer): boolean
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): TILE
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
get "tileType"(): $TileEntityTypeRegistryObject<(TILE)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTile$Type<TILE, TYPE> = ($BlockTile<(TILE), (TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTile_<TILE, TYPE> = $BlockTile$Type<(TILE), (TYPE)>;
}}
declare module "packages/mekanism/common/recipe/serializer/$PressurizedReactionRecipeSerializer$IFactory" {
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$FluidStackIngredient, $FluidStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$FluidStackIngredient"
import {$PressurizedReactionRecipe, $PressurizedReactionRecipe$Type} from "packages/mekanism/api/recipes/$PressurizedReactionRecipe"
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$ChemicalStackIngredient$GasStackIngredient, $ChemicalStackIngredient$GasStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient$GasStackIngredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"

export interface $PressurizedReactionRecipeSerializer$IFactory<RECIPE extends $PressurizedReactionRecipe> {

 "create"(id: $ResourceLocation$Type, itemInput: $ItemStackIngredient$Type, fluidInput: $FluidStackIngredient$Type, gasInput: $ChemicalStackIngredient$GasStackIngredient$Type, energyRequired: $FloatingLong$Type, duration: integer, outputItem: $ItemStack$Type, outputGas: $GasStack$Type): RECIPE

(id: $ResourceLocation$Type, itemInput: $ItemStackIngredient$Type, fluidInput: $FluidStackIngredient$Type, gasInput: $ChemicalStackIngredient$GasStackIngredient$Type, energyRequired: $FloatingLong$Type, duration: integer, outputItem: $ItemStack$Type, outputGas: $GasStack$Type): RECIPE
}

export namespace $PressurizedReactionRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressurizedReactionRecipeSerializer$IFactory$Type<RECIPE> = ($PressurizedReactionRecipeSerializer$IFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PressurizedReactionRecipeSerializer$IFactory_<RECIPE> = $PressurizedReactionRecipeSerializer$IFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/recipe/serializer/$NucleosynthesizingRecipeSerializer$IFactory" {
import {$NucleosynthesizingRecipe, $NucleosynthesizingRecipe$Type} from "packages/mekanism/api/recipes/$NucleosynthesizingRecipe"
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$ChemicalStackIngredient$GasStackIngredient, $ChemicalStackIngredient$GasStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient$GasStackIngredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $NucleosynthesizingRecipeSerializer$IFactory<RECIPE extends $NucleosynthesizingRecipe> {

 "create"(id: $ResourceLocation$Type, itemInput: $ItemStackIngredient$Type, gasInput: $ChemicalStackIngredient$GasStackIngredient$Type, outputItem: $ItemStack$Type, duration: integer): RECIPE

(id: $ResourceLocation$Type, itemInput: $ItemStackIngredient$Type, gasInput: $ChemicalStackIngredient$GasStackIngredient$Type, outputItem: $ItemStack$Type, duration: integer): RECIPE
}

export namespace $NucleosynthesizingRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NucleosynthesizingRecipeSerializer$IFactory$Type<RECIPE> = ($NucleosynthesizingRecipeSerializer$IFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NucleosynthesizingRecipeSerializer$IFactory_<RECIPE> = $NucleosynthesizingRecipeSerializer$IFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/tile/interfaces/$IFluidContainerManager" {
import {$IFluidContainerManager$ContainerEditMode, $IFluidContainerManager$ContainerEditMode$Type} from "packages/mekanism/common/tile/interfaces/$IFluidContainerManager$ContainerEditMode"
import {$IHasMode, $IHasMode$Type} from "packages/mekanism/common/tile/interfaces/$IHasMode"

export interface $IFluidContainerManager extends $IHasMode {

 "getContainerEditMode"(): $IFluidContainerManager$ContainerEditMode
 "nextMode"(): void
 "previousMode"(): void
}

export namespace $IFluidContainerManager {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFluidContainerManager$Type = ($IFluidContainerManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFluidContainerManager_ = $IFluidContainerManager$Type;
}}
declare module "packages/mekanism/common/tile/component/config/$DataType" {
import {$IHasTranslationKey, $IHasTranslationKey$Type} from "packages/mekanism/api/text/$IHasTranslationKey"
import {$IIncrementalEnum, $IIncrementalEnum$Type} from "packages/mekanism/api/$IIncrementalEnum"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"

export class $DataType extends $Enum<($DataType)> implements $IIncrementalEnum<($DataType)>, $IHasTranslationKey {
static readonly "NONE": $DataType
static readonly "INPUT": $DataType
static readonly "INPUT_1": $DataType
static readonly "INPUT_2": $DataType
static readonly "OUTPUT": $DataType
static readonly "OUTPUT_1": $DataType
static readonly "OUTPUT_2": $DataType
static readonly "INPUT_OUTPUT": $DataType
static readonly "ENERGY": $DataType
static readonly "EXTRA": $DataType


public static "values"(): ($DataType)[]
public static "valueOf"(name: string): $DataType
public "getTranslationKey"(): string
public "canOutput"(): boolean
public "getColor"(): $EnumColor
public static "byIndexStatic"(index: integer): $DataType
public "ordinal"(): integer
public "adjust"(arg0: integer): $DataType
public "adjust"(arg0: integer, arg1: $Predicate$Type<($DataType$Type)>): $DataType
public "getNext"(arg0: $Predicate$Type<($DataType$Type)>): $DataType
public "getNext"(): $DataType
public "getPrevious"(): $DataType
public "getPrevious"(arg0: $Predicate$Type<($DataType$Type)>): $DataType
get "translationKey"(): string
get "color"(): $EnumColor
get "next"(): $DataType
get "previous"(): $DataType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataType$Type = (("output") | ("input") | ("input_output") | ("extra") | ("input_1") | ("input_2") | ("output_2") | ("none") | ("output_1") | ("energy")) | ($DataType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataType_ = $DataType$Type;
}}
declare module "packages/mekanism/common/tier/$EnergyCubeTier" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"
import {$CachedFloatingLongValue, $CachedFloatingLongValue$Type} from "packages/mekanism/common/config/value/$CachedFloatingLongValue"

export class $EnergyCubeTier extends $Enum<($EnergyCubeTier)> implements $ITier, $StringRepresentable {
static readonly "BASIC": $EnergyCubeTier
static readonly "ADVANCED": $EnergyCubeTier
static readonly "ELITE": $EnergyCubeTier
static readonly "ULTIMATE": $EnergyCubeTier
static readonly "CREATIVE": $EnergyCubeTier


public static "values"(): ($EnergyCubeTier)[]
public static "valueOf"(name: string): $EnergyCubeTier
public "getOutput"(): $FloatingLong
public "getSerializedName"(): string
public "getBaseMaxEnergy"(): $FloatingLong
public "getBaseTier"(): $BaseTier
public "getBaseOutput"(): $FloatingLong
public "setConfigReference"(storageReference: $CachedFloatingLongValue$Type, outputReference: $CachedFloatingLongValue$Type): void
public "getMaxEnergy"(): $FloatingLong
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
get "output"(): $FloatingLong
get "serializedName"(): string
get "baseMaxEnergy"(): $FloatingLong
get "baseTier"(): $BaseTier
get "baseOutput"(): $FloatingLong
get "maxEnergy"(): $FloatingLong
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyCubeTier$Type = (("elite") | ("advanced") | ("ultimate") | ("basic") | ("creative")) | ($EnergyCubeTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyCubeTier_ = $EnergyCubeTier$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemHDPEElytra" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$ElytraItem, $ElytraItem$Type} from "packages/net/minecraft/world/item/$ElytraItem"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemHDPEElytra extends $ElytraItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "getEquipmentSlot"(stack: $ItemStack$Type): $EquipmentSlot
public "isValidRepairItem"(toRepair: $ItemStack$Type, repair: $ItemStack$Type): boolean
public static "get"(arg0: $ItemStack$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemHDPEElytra$Type = ($ItemHDPEElytra);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemHDPEElytra_ = $ItemHDPEElytra$Type;
}}
declare module "packages/mekanism/common/upgrade/transmitter/$MechanicalPipeUpgradeData" {
import {$TransmitterUpgradeData, $TransmitterUpgradeData$Type} from "packages/mekanism/common/upgrade/transmitter/$TransmitterUpgradeData"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$ConnectionType, $ConnectionType$Type} from "packages/mekanism/common/lib/transmitter/$ConnectionType"

export class $MechanicalPipeUpgradeData extends $TransmitterUpgradeData {
readonly "contents": $FluidStack
readonly "redstoneReactive": boolean
readonly "connectionTypes": ($ConnectionType)[]

constructor(redstoneReactive: boolean, connectionTypes: ($ConnectionType$Type)[], contents: $FluidStack$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalPipeUpgradeData$Type = ($MechanicalPipeUpgradeData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MechanicalPipeUpgradeData_ = $MechanicalPipeUpgradeData$Type;
}}
declare module "packages/mekanism/common/lib/multiblock/$Structure" {
import {$FormationProtocol$FormationResult, $FormationProtocol$FormationResult$Type} from "packages/mekanism/common/lib/multiblock/$FormationProtocol$FormationResult"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$MultiblockManager, $MultiblockManager$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockManager"
import {$Structure$Axis, $Structure$Axis$Type} from "packages/mekanism/common/lib/multiblock/$Structure$Axis"
import {$VoxelPlane, $VoxelPlane$Type} from "packages/mekanism/common/lib/math/voxel/$VoxelPlane"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IMultiblockBase, $IMultiblockBase$Type} from "packages/mekanism/common/lib/multiblock/$IMultiblockBase"
import {$MultiblockData, $MultiblockData$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockData"
import {$NavigableMap, $NavigableMap$Type} from "packages/java/util/$NavigableMap"
import {$IMultiblock, $IMultiblock$Type} from "packages/mekanism/common/lib/multiblock/$IMultiblock"

export class $Structure {
static readonly "INVALID": $Structure

constructor(node: $IMultiblockBase$Type)

public "add"(s: $Structure$Type): void
public "size"(): integer
public "contains"(pos: $BlockPos$Type): boolean
public "isValid"(): boolean
public "invalidate"(world: $Level$Type): void
public "getController"(): $IMultiblock<(any)>
public "getTile"(pos: $BlockPos$Type): $IMultiblockBase
public "tick"<TILE extends ($BlockEntity) & ($IMultiblockBase)>(tile: TILE, tryValidate: boolean): void
public "getManager"(): $MultiblockManager<(any)>
public "markForUpdate"(world: $Level$Type, invalidate: boolean): void
public "runUpdate"<TILE extends ($BlockEntity) & ($IMultiblockBase)>(tile: TILE): $FormationProtocol$FormationResult
public "doImmediateUpdate"<TILE extends ($BlockEntity) & ($IMultiblockBase)>(tile: TILE, tryValidate: boolean): void
public "getMultiblockData"(): $MultiblockData
public "setMultiblockData"(multiblockData: $MultiblockData$Type): void
public "getMinorAxisMap"(axis: $Structure$Axis$Type): $NavigableMap<(integer), ($VoxelPlane)>
public "getMajorAxisMap"(axis: $Structure$Axis$Type): $NavigableMap<(integer), ($VoxelPlane)>
public "removeMultiblock"(world: $Level$Type): void
get "valid"(): boolean
get "controller"(): $IMultiblock<(any)>
get "manager"(): $MultiblockManager<(any)>
get "multiblockData"(): $MultiblockData
set "multiblockData"(value: $MultiblockData$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Structure$Type = ($Structure);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Structure_ = $Structure$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$PressurizedReactionRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$PressurizedReactionRecipe, $PressurizedReactionRecipe$Type} from "packages/mekanism/api/recipes/$PressurizedReactionRecipe"
import {$PressurizedReactionRecipeSerializer$IFactory, $PressurizedReactionRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$PressurizedReactionRecipeSerializer$IFactory"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $PressurizedReactionRecipeSerializer<RECIPE extends $PressurizedReactionRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(factory: $PressurizedReactionRecipeSerializer$IFactory$Type<(RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressurizedReactionRecipeSerializer$Type<RECIPE> = ($PressurizedReactionRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PressurizedReactionRecipeSerializer_<RECIPE> = $PressurizedReactionRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/lib/frequency/$FrequencyType" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$Type} from "packages/mekanism/common/lib/frequency/$Frequency$FrequencyIdentity"
import {$TeleporterFrequency, $TeleporterFrequency$Type} from "packages/mekanism/common/content/teleporter/$TeleporterFrequency"
import {$QIOFrequency, $QIOFrequency$Type} from "packages/mekanism/common/content/qio/$QIOFrequency"
import {$SecurityFrequency, $SecurityFrequency$Type} from "packages/mekanism/common/lib/security/$SecurityFrequency"
import {$FrequencyManagerWrapper, $FrequencyManagerWrapper$Type} from "packages/mekanism/common/lib/frequency/$FrequencyManagerWrapper"
import {$Frequency, $Frequency$Type} from "packages/mekanism/common/lib/frequency/$Frequency"
import {$FrequencyManager, $FrequencyManager$Type} from "packages/mekanism/common/lib/frequency/$FrequencyManager"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$IdentitySerializer, $IdentitySerializer$Type} from "packages/mekanism/common/lib/frequency/$IdentitySerializer"
import {$InventoryFrequency, $InventoryFrequency$Type} from "packages/mekanism/common/content/entangloporter/$InventoryFrequency"

export class $FrequencyType<FREQ extends $Frequency> {
static readonly "TELEPORTER": $FrequencyType<($TeleporterFrequency)>
static readonly "INVENTORY": $FrequencyType<($InventoryFrequency)>
static readonly "SECURITY": $FrequencyType<($SecurityFrequency)>
static readonly "QIO": $FrequencyType<($QIOFrequency)>


public "getName"(): string
public "toString"(): string
public static "load"<FREQ extends $Frequency>(tag: $CompoundTag$Type): $FrequencyType<(FREQ)>
public static "load"<FREQ extends $Frequency>(buf: $FriendlyByteBuf$Type): $FrequencyType<(FREQ)>
public static "clear"(): void
public static "init"(): void
public "write"(buf: $FriendlyByteBuf$Type): void
public "create"(packet: $FriendlyByteBuf$Type): FREQ
public "create"(tag: $CompoundTag$Type): FREQ
public "create"(key: any, ownerUUID: $UUID$Type): FREQ
public "getIdentitySerializer"(): $IdentitySerializer
public "getFrequency"(identity: $Frequency$FrequencyIdentity$Type, owner: $UUID$Type): FREQ
public "getManager"(owner: $UUID$Type): $FrequencyManager<(FREQ)>
public "getManager"(identity: $Frequency$FrequencyIdentity$Type, owner: $UUID$Type): $FrequencyManager<(FREQ)>
public "getManagerWrapper"(): $FrequencyManagerWrapper<(FREQ)>
public "getFrequencyManager"(freq: FREQ): $FrequencyManager<(FREQ)>
get "name"(): string
get "identitySerializer"(): $IdentitySerializer
get "managerWrapper"(): $FrequencyManagerWrapper<(FREQ)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrequencyType$Type<FREQ> = ($FrequencyType<(FREQ)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FrequencyType_<FREQ> = $FrequencyType$Type<(FREQ)>;
}}
declare module "packages/mekanism/common/tile/interfaces/$IFluidContainerManager$ContainerEditMode" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IIncrementalEnum, $IIncrementalEnum$Type} from "packages/mekanism/api/$IIncrementalEnum"
import {$IHasTextComponent, $IHasTextComponent$Type} from "packages/mekanism/api/text/$IHasTextComponent"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export class $IFluidContainerManager$ContainerEditMode extends $Enum<($IFluidContainerManager$ContainerEditMode)> implements $IIncrementalEnum<($IFluidContainerManager$ContainerEditMode)>, $IHasTextComponent {
static readonly "BOTH": $IFluidContainerManager$ContainerEditMode
static readonly "FILL": $IFluidContainerManager$ContainerEditMode
static readonly "EMPTY": $IFluidContainerManager$ContainerEditMode


public static "values"(): ($IFluidContainerManager$ContainerEditMode)[]
public static "valueOf"(name: string): $IFluidContainerManager$ContainerEditMode
public "byIndex"(index: integer): $IFluidContainerManager$ContainerEditMode
public "getTextComponent"(): $Component
public static "byIndexStatic"(index: integer): $IFluidContainerManager$ContainerEditMode
public "ordinal"(): integer
public "adjust"(arg0: integer): $IFluidContainerManager$ContainerEditMode
public "adjust"(arg0: integer, arg1: $Predicate$Type<($IFluidContainerManager$ContainerEditMode$Type)>): $IFluidContainerManager$ContainerEditMode
public "getNext"(arg0: $Predicate$Type<($IFluidContainerManager$ContainerEditMode$Type)>): $IFluidContainerManager$ContainerEditMode
public "getNext"(): $IFluidContainerManager$ContainerEditMode
public "getPrevious"(): $IFluidContainerManager$ContainerEditMode
public "getPrevious"(arg0: $Predicate$Type<($IFluidContainerManager$ContainerEditMode$Type)>): $IFluidContainerManager$ContainerEditMode
get "textComponent"(): $Component
get "next"(): $IFluidContainerManager$ContainerEditMode
get "previous"(): $IFluidContainerManager$ContainerEditMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFluidContainerManager$ContainerEditMode$Type = (("fill") | ("both") | ("empty")) | ($IFluidContainerManager$ContainerEditMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFluidContainerManager$ContainerEditMode_ = $IFluidContainerManager$ContainerEditMode$Type;
}}
declare module "packages/mekanism/common/integration/computer/$TableType" {
import {$TableType$FieldType, $TableType$FieldType$Type} from "packages/mekanism/common/integration/computer/$TableType$FieldType"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$TableType$Builder, $TableType$Builder$Type} from "packages/mekanism/common/integration/computer/$TableType$Builder"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TableType extends $Record {
static "CODEC": $Codec<($TableType)>
static "TABLE_MAP_CODEC": $Codec<($Map<($Class<(any)>), ($TableType)>)>

constructor(description: string, humanName: string, fields: $Map$Type<(string), ($TableType$FieldType$Type)>, extendedFrom: $Class$Type<(any)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "builder"(clazz: $Class$Type<(any)>, description: string): $TableType$Builder
public "fields"(): $Map<(string), ($TableType$FieldType)>
public "description"(): string
public "extendedFrom"(): $Class<(any)>
public "humanName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TableType$Type = ($TableType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TableType_ = $TableType$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$TripleInputRecipeCache" {
import {$TriPredicate, $TriPredicate$Type} from "packages/net/minecraftforge/common/util/$TriPredicate"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$AbstractInputRecipeCache, $AbstractInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$AbstractInputRecipeCache"
import {$InputIngredient, $InputIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$InputIngredient"
import {$IInputCache, $IInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$IInputCache"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"

export class $TripleInputRecipeCache<INPUT_A, INGREDIENT_A extends $InputIngredient<(INPUT_A)>, INPUT_B, INGREDIENT_B extends $InputIngredient<(INPUT_B)>, INPUT_C, INGREDIENT_C extends $InputIngredient<(INPUT_C)>, RECIPE extends ($MekanismRecipe) & ($TriPredicate<(INPUT_A), (INPUT_B), (INPUT_C)>), CACHE_A extends $IInputCache<(INPUT_A), (INGREDIENT_A), (RECIPE)>, CACHE_B extends $IInputCache<(INPUT_B), (INGREDIENT_B), (RECIPE)>, CACHE_C extends $IInputCache<(INPUT_C), (INGREDIENT_C), (RECIPE)>> extends $AbstractInputRecipeCache<(RECIPE)> {


public "clear"(): void
public "containsInputABC"(world: $Level$Type, inputA: INPUT_A, inputB: INPUT_B, inputC: INPUT_C): boolean
public "containsInputC"(world: $Level$Type, input: INPUT_C): boolean
public "containsInputBAC"(world: $Level$Type, inputA: INPUT_A, inputB: INPUT_B, inputC: INPUT_C): boolean
public "containsInputCAB"(world: $Level$Type, inputA: INPUT_A, inputB: INPUT_B, inputC: INPUT_C): boolean
public "findFirstRecipe"(world: $Level$Type, inputA: INPUT_A, inputB: INPUT_B, inputC: INPUT_C): RECIPE
public "containsInputB"(world: $Level$Type, input: INPUT_B): boolean
public "containsInputA"(world: $Level$Type, input: INPUT_A): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TripleInputRecipeCache$Type<INPUT_A, INGREDIENT_A, INPUT_B, INGREDIENT_B, INPUT_C, INGREDIENT_C, RECIPE, CACHE_A, CACHE_B, CACHE_C> = ($TripleInputRecipeCache<(INPUT_A), (INGREDIENT_A), (INPUT_B), (INGREDIENT_B), (INPUT_C), (INGREDIENT_C), (RECIPE), (CACHE_A), (CACHE_B), (CACHE_C)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TripleInputRecipeCache_<INPUT_A, INGREDIENT_A, INPUT_B, INGREDIENT_B, INPUT_C, INGREDIENT_C, RECIPE, CACHE_A, CACHE_B, CACHE_C> = $TripleInputRecipeCache$Type<(INPUT_A), (INGREDIENT_A), (INPUT_B), (INGREDIENT_B), (INPUT_C), (INGREDIENT_C), (RECIPE), (CACHE_A), (CACHE_B), (CACHE_C)>;
}}
declare module "packages/mekanism/common/tile/$TileEntityEnergyCube$CubeSideState" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $TileEntityEnergyCube$CubeSideState extends $Enum<($TileEntityEnergyCube$CubeSideState)> {
static readonly "ACTIVE_LIT": $TileEntityEnergyCube$CubeSideState
static readonly "ACTIVE_UNLIT": $TileEntityEnergyCube$CubeSideState
static readonly "INACTIVE": $TileEntityEnergyCube$CubeSideState


public static "values"(): ($TileEntityEnergyCube$CubeSideState)[]
public static "valueOf"(name: string): $TileEntityEnergyCube$CubeSideState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityEnergyCube$CubeSideState$Type = (("inactive") | ("active_lit") | ("active_unlit")) | ($TileEntityEnergyCube$CubeSideState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityEnergyCube$CubeSideState_ = $TileEntityEnergyCube$CubeSideState$Type;
}}
declare module "packages/mekanism/common/integration/computer/$TableType$FieldType" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $TableType$FieldType extends $Record {
static readonly "CODEC": $Codec<($TableType$FieldType)>

constructor(description: string, javaType: $Class$Type<(any)>, type: string, javaExtra: ($Class$Type<(any)>)[])

public "type"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "description"(): string
public "javaType"(): $Class<(any)>
public "javaExtra"(): ($Class<(any)>)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TableType$FieldType$Type = ($TableType$FieldType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TableType$FieldType_ = $TableType$FieldType$Type;
}}
declare module "packages/mekanism/common/item/interfaces/$IModeItem" {
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $IModeItem {

 "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
 "getScrollTextComponent"(stack: $ItemStack$Type): $Component
 "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void

(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
}

export namespace $IModeItem {
function displayModeChange(player: $Player$Type): void
function isModeItem(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
function isModeItem(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
function isModeItem(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModeItem$Type = ($IModeItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModeItem_ = $IModeItem$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ItemStackToChemicalRecipeSerializer" {
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ItemStackToChemicalRecipe, $ItemStackToChemicalRecipe$Type} from "packages/mekanism/api/recipes/chemical/$ItemStackToChemicalRecipe"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ItemStackToChemicalRecipeSerializer<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, RECIPE extends $ItemStackToChemicalRecipe<(CHEMICAL), (STACK)>> implements $RecipeSerializer<(RECIPE)> {


public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackToChemicalRecipeSerializer$Type<CHEMICAL, STACK, RECIPE> = ($ItemStackToChemicalRecipeSerializer<(CHEMICAL), (STACK), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackToChemicalRecipeSerializer_<CHEMICAL, STACK, RECIPE> = $ItemStackToChemicalRecipeSerializer$Type<(CHEMICAL), (STACK), (RECIPE)>;
}}
declare module "packages/mekanism/common/lib/inventory/$HashedItem$UUIDAwareHashedItem" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$HashedItem, $HashedItem$Type} from "packages/mekanism/common/lib/inventory/$HashedItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $HashedItem$UUIDAwareHashedItem extends $HashedItem {

constructor(stack: $ItemStack$Type, uuid: $UUID$Type)
constructor(other: $HashedItem$Type, uuid: $UUID$Type)

public "equals"(obj: any): boolean
public "hashCode"(): integer
public "getUUID"(): $UUID
public "asRawHashedItem"(): $HashedItem
get "uUID"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HashedItem$UUIDAwareHashedItem$Type = ($HashedItem$UUIDAwareHashedItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HashedItem$UUIDAwareHashedItem_ = $HashedItem$UUIDAwareHashedItem$Type;
}}
declare module "packages/mekanism/common/item/$ItemDosimeter" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemDosimeter extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "interactLivingEntity"(stack: $ItemStack$Type, player: $Player$Type, entity: $LivingEntity$Type, hand: $InteractionHand$Type): $InteractionResult
public "use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDosimeter$Type = ($ItemDosimeter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDosimeter_ = $ItemDosimeter$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemSpecialArmor" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Equipable, $Equipable$Type} from "packages/net/minecraft/world/item/$Equipable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$ArmorItem, $ArmorItem$Type} from "packages/net/minecraft/world/item/$ArmorItem"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$DispenseItemBehavior, $DispenseItemBehavior$Type} from "packages/net/minecraft/core/dispenser/$DispenseItemBehavior"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ItemSpecialArmor extends $ArmorItem {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Multimap<($Attribute), ($AttributeModifier)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer


public "initCapabilities"(stack: $ItemStack$Type, nbt: $CompoundTag$Type): $ICapabilityProvider
public "canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "isEnchantable"(stack: $ItemStack$Type): boolean
public "isBookEnchantable"(stack: $ItemStack$Type, book: $ItemStack$Type): boolean
public "getArmorTexture"(stack: $ItemStack$Type, entity: $Entity$Type, slot: $EquipmentSlot$Type, type: string): string
public static "get"(arg0: $ItemStack$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemSpecialArmor$Type = ($ItemSpecialArmor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemSpecialArmor_ = $ItemSpecialArmor$Type;
}}
declare module "packages/mekanism/common/registration/$WrappedRegistryObject" {
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$INamedEntry, $INamedEntry$Type} from "packages/mekanism/common/registration/$INamedEntry"

export class $WrappedRegistryObject<T> implements $Supplier<(T)>, $INamedEntry {


public "get"(): T
public "key"(): $ResourceKey<(T)>
public "getInternalRegistryName"(): string
get "internalRegistryName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedRegistryObject$Type<T> = ($WrappedRegistryObject<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedRegistryObject_<T> = $WrappedRegistryObject$Type<(T)>;
}}
declare module "packages/mekanism/common/particle/$LaserParticleType" {
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$LaserParticleData, $LaserParticleData$Type} from "packages/mekanism/common/particle/$LaserParticleData"

export class $LaserParticleType extends $ParticleType<($LaserParticleData)> {

constructor()

public "codec"(): $Codec<($LaserParticleData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LaserParticleType$Type = ($LaserParticleType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LaserParticleType_ = $LaserParticleType$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$RotaryRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$RotaryRecipeSerializer$IFactory, $RotaryRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$RotaryRecipeSerializer$IFactory"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$RotaryRecipe, $RotaryRecipe$Type} from "packages/mekanism/api/recipes/$RotaryRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $RotaryRecipeSerializer<RECIPE extends $RotaryRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(factory: $RotaryRecipeSerializer$IFactory$Type<(RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotaryRecipeSerializer$Type<RECIPE> = ($RotaryRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RotaryRecipeSerializer_<RECIPE> = $RotaryRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/block/states/$IStateFluidLoggable" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$LiquidBlockContainer, $LiquidBlockContainer$Type} from "packages/net/minecraft/world/level/block/$LiquidBlockContainer"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$BucketPickup, $BucketPickup$Type} from "packages/net/minecraft/world/level/block/$BucketPickup"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IStateFluidLoggable extends $BucketPickup, $LiquidBlockContainer {

 "setState"(state: $BlockState$Type, fluid: $Fluid$Type): $BlockState
 "getFluidLightLevel"(state: $BlockState$Type): integer
 "getFluid"(state: $BlockState$Type): $FluidState
 "canPlaceLiquid"(world: $BlockGetter$Type, pos: $BlockPos$Type, state: $BlockState$Type, fluid: $Fluid$Type): boolean
 "pickupBlock"(world: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type): $ItemStack
 "getPickupSound"(state: $BlockState$Type): $Optional<($SoundEvent)>
 "placeLiquid"(world: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type, fluidState: $FluidState$Type): boolean
 "getPickupSound"(): $Optional<($SoundEvent)>
 "getFluidLoggedProperty"(): $EnumProperty<(any)>
 "isValidFluid"(fluid: $Fluid$Type): boolean
 "updateFluids"(state: $BlockState$Type, world: $LevelAccessor$Type, currentPos: $BlockPos$Type): void
}

export namespace $IStateFluidLoggable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IStateFluidLoggable$Type = ($IStateFluidLoggable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IStateFluidLoggable_ = $IStateFluidLoggable$Type;
}}
declare module "packages/mekanism/common/tile/prefab/$TileEntityStructuralMultiblock" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$MultiblockManager, $MultiblockManager$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockManager"
import {$IConfigurable, $IConfigurable$Type} from "packages/mekanism/api/$IConfigurable"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Structure, $Structure$Type} from "packages/mekanism/common/lib/multiblock/$Structure"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IStructuralMultiblock, $IStructuralMultiblock$Type} from "packages/mekanism/common/lib/multiblock/$IStructuralMultiblock"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MultiblockData, $MultiblockData$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockData"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TileEntityStructuralMultiblock extends $TileEntityMekanism implements $IStructuralMultiblock, $IConfigurable {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(provider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "onNeighborChange"(block: $Block$Type, neighborPos: $BlockPos$Type): void
public "setRemoved"(): void
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "shouldDumpRadiation"(): boolean
public "getStructureMap"(): $Map<($MultiblockManager<(any)>), ($Structure)>
public "structuralGuiAccessAllowed"(): boolean
public "hasFormedMultiblock"(): boolean
public "onRightClick"(player: $Player$Type): $InteractionResult
public "onActivate"(player: $Player$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type): $InteractionResult
public "getStructure"(manager: $MultiblockManager$Type<(any)>): $Structure
public "getReducedUpdateTag"(): $CompoundTag
public "onSneakRightClick"(player: $Player$Type): $InteractionResult
public "setStructure"(manager: $MultiblockManager$Type<(any)>, structure: $Structure$Type): void
public "getDefaultData"(): $MultiblockData
public "hasStructure"(structure: $Structure$Type): boolean
public "canInterface"(manager: $MultiblockManager$Type<(any)>): boolean
public "resetForFormed"(): void
public "getMultiblockData"(manager: $MultiblockManager$Type<(any)>): $MultiblockData
public "resetStructure"(manager: $MultiblockManager$Type<(any)>): $Structure
public "setMultiblockData"(manager: $MultiblockManager$Type<(any)>, multiblockData: $MultiblockData$Type): void
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "structureMap"(): $Map<($MultiblockManager<(any)>), ($Structure)>
get "reducedUpdateTag"(): $CompoundTag
get "defaultData"(): $MultiblockData
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityStructuralMultiblock$Type = ($TileEntityStructuralMultiblock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityStructuralMultiblock_ = $TileEntityStructuralMultiblock$Type;
}}
declare module "packages/mekanism/common/item/$ItemGeigerCounter" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemGeigerCounter extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(props: $Item$Properties$Type)

public "use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemGeigerCounter$Type = ($ItemGeigerCounter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemGeigerCounter_ = $ItemGeigerCounter$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$ITileRadioactive" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export interface $ITileRadioactive {

 "getRadiationParticleCount"(): integer
 "getRadiationScale"(): float

(tanks: $List$Type<($IGasTank$Type)>): float
}

export namespace $ITileRadioactive {
function calculateRadiationScale(tanks: $List$Type<($IGasTank$Type)>): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileRadioactive$Type = ($ITileRadioactive);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileRadioactive_ = $ITileRadioactive$Type;
}}
declare module "packages/mekanism/common/resource/$IResource" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IResource {

 "getRegistrySuffix"(): string

(): string
}

export namespace $IResource {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IResource$Type = ($IResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IResource_ = $IResource$Type;
}}
declare module "packages/mekanism/common/tile/factory/$TileEntityFactory" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BooleanSupplier, $BooleanSupplier$Type} from "packages/java/util/function/$BooleanSupplier"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$FactoryTier, $FactoryTier$Type} from "packages/mekanism/common/tier/$FactoryTier"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$TileEntityConfigurableMachine, $TileEntityConfigurableMachine$Type} from "packages/mekanism/common/tile/prefab/$TileEntityConfigurableMachine"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$IMekanismRecipeTypeProvider, $IMekanismRecipeTypeProvider$Type} from "packages/mekanism/common/recipe/$IMekanismRecipeTypeProvider"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ISustainedData, $ISustainedData$Type} from "packages/mekanism/common/tile/interfaces/$ISustainedData"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IRecipeLookupHandler, $IRecipeLookupHandler$Type} from "packages/mekanism/common/recipe/lookup/$IRecipeLookupHandler"
import {$IUpgradeData, $IUpgradeData$Type} from "packages/mekanism/common/upgrade/$IUpgradeData"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$CachedRecipe$OperationTracker$RecipeError, $CachedRecipe$OperationTracker$RecipeError$Type} from "packages/mekanism/api/recipes/cache/$CachedRecipe$OperationTracker$RecipeError"
import {$FactoryType, $FactoryType$Type} from "packages/mekanism/common/content/blocktype/$FactoryType"
import {$TileComponentEjector, $TileComponentEjector$Type} from "packages/mekanism/common/tile/component/$TileComponentEjector"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$CachedRecipe, $CachedRecipe$Type} from "packages/mekanism/api/recipes/cache/$CachedRecipe"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$MachineEnergyContainer, $MachineEnergyContainer$Type} from "packages/mekanism/common/capabilities/energy/$MachineEnergyContainer"
import {$TileComponentConfig, $TileComponentConfig$Type} from "packages/mekanism/common/tile/component/$TileComponentConfig"
import {$Upgrade, $Upgrade$Type} from "packages/mekanism/api/$Upgrade"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TileEntityFactory<RECIPE extends $MekanismRecipe> extends $TileEntityConfigurableMachine implements $IRecipeLookupHandler<(RECIPE)>, $ISustainedData {
 "tier": $FactoryTier
readonly "progress": (integer)[]
 "ejectorComponent": $TileComponentEjector
 "configComponent": $TileComponentConfig
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState


public "getInfo"(upgrade: $Upgrade$Type): $List<($Component)>
public "getEnergyContainer"(): $MachineEnergyContainer<($TileEntityFactory<(any)>)>
public "load"(nbt: $CompoundTag$Type): void
public "m_183515_"(nbtTags: $CompoundTag$Type): void
public "recalculateUpgrades"(upgrade: $Upgrade$Type): void
public "addContainerTrackers"(container: $MekanismContainer$Type): void
public "isConfigurationDataCompatible"(tileType: $BlockEntityType$Type<(any)>): boolean
public "getFactoryType"(): $FactoryType
public "getProgress"(cacheIndex: integer): integer
public "hasSecondaryResourceBar"(): boolean
public "inputProducesOutput"(process: integer, fallbackInput: $ItemStack$Type, outputSlot: $IInventorySlot$Type, secondaryOutputSlot: $IInventorySlot$Type, updateCache: boolean): boolean
public "readSustainedData"(data: $CompoundTag$Type): void
public "writeSustainedData"(data: $CompoundTag$Type): void
public "parseUpgradeData"(upgradeData: $IUpgradeData$Type): void
public "clearRecipeErrors"(cacheIndex: integer): void
public "getWarningCheck"(error: $CachedRecipe$OperationTracker$RecipeError$Type, processIndex: integer): $BooleanSupplier
public "getScaledProgress"(i: integer, process: integer): double
public "getSavedOperatingTicks"(cacheIndex: integer): integer
public "getTileDataRemap"(): $Map<(string), (string)>
public "isValidInputItem"(stack: $ItemStack$Type): boolean
public "isSorting"(): boolean
public "getLastUsage"(): $FloatingLong
public "toggleSorting"(): void
public "getTicksRequired"(): integer
public "getRecipeType"(): $IMekanismRecipeTypeProvider<(RECIPE), (any)>
public "getRecipe"(cacheIndex: integer): RECIPE
public "getHandlerWorld"(): $Level
public "createNewCachedRecipe"(recipe: RECIPE, cacheIndex: integer): $CachedRecipe<(RECIPE)>
public "onCachedRecipeChanged"(cachedRecipe: $CachedRecipe$Type<(RECIPE)>, cacheIndex: integer): void
public "onContentsChanged"(): void
public "getDirection"(): $Direction
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "energyContainer"(): $MachineEnergyContainer<($TileEntityFactory<(any)>)>
get "factoryType"(): $FactoryType
get "tileDataRemap"(): $Map<(string), (string)>
get "sorting"(): boolean
get "lastUsage"(): $FloatingLong
get "ticksRequired"(): integer
get "recipeType"(): $IMekanismRecipeTypeProvider<(RECIPE), (any)>
get "handlerWorld"(): $Level
get "direction"(): $Direction
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityFactory$Type<RECIPE> = ($TileEntityFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityFactory_<RECIPE> = $TileEntityFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/inventory/slot/$UpgradeInventorySlot" {
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$BasicInventorySlot, $BasicInventorySlot$Type} from "packages/mekanism/common/inventory/slot/$BasicInventorySlot"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Upgrade, $Upgrade$Type} from "packages/mekanism/api/$Upgrade"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"

export class $UpgradeInventorySlot extends $BasicInventorySlot {
static readonly "alwaysTrue": $Predicate<($ItemStack)>
static readonly "alwaysFalse": $Predicate<($ItemStack)>
static readonly "alwaysTrueBi": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "DEFAULT_LIMIT": integer


public static "input"(listener: $IContentsListener$Type, supportedTypes: $Set$Type<($Upgrade$Type)>): $UpgradeInventorySlot
public static "output"(listener: $IContentsListener$Type): $UpgradeInventorySlot
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeInventorySlot$Type = ($UpgradeInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradeInventorySlot_ = $UpgradeInventorySlot$Type;
}}
declare module "packages/mekanism/common/capabilities/energy/$EnergyCubeEnergyContainer" {
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$BasicEnergyContainer, $BasicEnergyContainer$Type} from "packages/mekanism/common/capabilities/energy/$BasicEnergyContainer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$EnergyCubeTier, $EnergyCubeTier$Type} from "packages/mekanism/common/tier/$EnergyCubeTier"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"

export class $EnergyCubeEnergyContainer extends $BasicEnergyContainer {
static readonly "alwaysTrue": $Predicate<($AutomationType)>
static readonly "alwaysFalse": $Predicate<($AutomationType)>
static readonly "internalOnly": $Predicate<($AutomationType)>
static readonly "manualOnly": $Predicate<($AutomationType)>
static readonly "notExternal": $Predicate<($AutomationType)>


public "extract"(amount: $FloatingLong$Type, action: $Action$Type, automationType: $AutomationType$Type): $FloatingLong
public "insert"(amount: $FloatingLong$Type, action: $Action$Type, automationType: $AutomationType$Type): $FloatingLong
public static "create"(tier: $EnergyCubeTier$Type, listener: $IContentsListener$Type): $EnergyCubeEnergyContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyCubeEnergyContainer$Type = ($EnergyCubeEnergyContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyCubeEnergyContainer_ = $EnergyCubeEnergyContainer$Type;
}}
declare module "packages/mekanism/common/config/$IMekanismConfig" {
import {$ForgeConfigSpec, $ForgeConfigSpec$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec"
import {$CachedValue, $CachedValue$Type} from "packages/mekanism/common/config/value/$CachedValue"
import {$ModConfig$Type, $ModConfig$Type$Type} from "packages/net/minecraftforge/fml/config/$ModConfig$Type"

export interface $IMekanismConfig {

 "save"(): void
 "getFileName"(): string
 "isLoaded"(): boolean
 "clearCache"(unloading: boolean): void
 "getConfigType"(): $ModConfig$Type
 "getConfigSpec"(): $ForgeConfigSpec
 "addToContainer"(): boolean
 "addCachedValue"(configValue: $CachedValue$Type<(any)>): void
}

export namespace $IMekanismConfig {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMekanismConfig$Type = ($IMekanismConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMekanismConfig_ = $IMekanismConfig$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$ISideConfiguration" {
import {$TileComponentEjector, $TileComponentEjector$Type} from "packages/mekanism/common/tile/component/$TileComponentEjector"
import {$DataType, $DataType$Type} from "packages/mekanism/common/tile/component/config/$DataType"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$TileComponentConfig, $TileComponentConfig$Type} from "packages/mekanism/common/tile/component/$TileComponentConfig"

export interface $ISideConfiguration {

 "getDirection"(): $Direction
 "getConfig"(): $TileComponentConfig
 "getEjector"(): $TileComponentEjector
 "getActiveDataType"(container: any): $DataType
}

export namespace $ISideConfiguration {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISideConfiguration$Type = ($ISideConfiguration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISideConfiguration_ = $ISideConfiguration$Type;
}}
declare module "packages/mekanism/common/lib/frequency/$FrequencyManagerWrapper$Type" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $FrequencyManagerWrapper$Type extends $Enum<($FrequencyManagerWrapper$Type)> {
static readonly "PUBLIC_ONLY": $FrequencyManagerWrapper$Type
static readonly "PRIVATE_ONLY": $FrequencyManagerWrapper$Type
static readonly "PUBLIC_PRIVATE": $FrequencyManagerWrapper$Type


public static "values"(): ($FrequencyManagerWrapper$Type)[]
public static "valueOf"(name: string): $FrequencyManagerWrapper$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrequencyManagerWrapper$Type$Type = (("public_private") | ("public_only") | ("private_only")) | ($FrequencyManagerWrapper$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FrequencyManagerWrapper$Type_ = $FrequencyManagerWrapper$Type$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$IComparatorSupport" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IComparatorSupport {

 "getRedstoneLevel"(): integer
 "getCurrentRedstoneLevel"(): integer
 "supportsComparator"(): boolean
}

export namespace $IComparatorSupport {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IComparatorSupport$Type = ($IComparatorSupport);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IComparatorSupport_ = $IComparatorSupport$Type;
}}
declare module "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager$SlurryHandlerManager" {
import {$ChemicalHandlerManager, $ChemicalHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager"
import {$SlurryStack, $SlurryStack$Type} from "packages/mekanism/api/chemical/slurry/$SlurryStack"
import {$ISlurryHandler$ISidedSlurryHandler, $ISlurryHandler$ISidedSlurryHandler$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryHandler$ISidedSlurryHandler"
import {$Slurry, $Slurry$Type} from "packages/mekanism/api/chemical/slurry/$Slurry"
import {$ISlurryHandler, $ISlurryHandler$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryHandler"
import {$IChemicalTankHolder, $IChemicalTankHolder$Type} from "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder"
import {$ISlurryTank, $ISlurryTank$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryTank"

export class $ChemicalHandlerManager$SlurryHandlerManager extends $ChemicalHandlerManager<($Slurry), ($SlurryStack), ($ISlurryTank), ($ISlurryHandler), ($ISlurryHandler$ISidedSlurryHandler)> {

constructor(holder: $IChemicalTankHolder$Type<($Slurry$Type), ($SlurryStack$Type), ($ISlurryTank$Type)>, baseHandler: $ISlurryHandler$ISidedSlurryHandler$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalHandlerManager$SlurryHandlerManager$Type = ($ChemicalHandlerManager$SlurryHandlerManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalHandlerManager$SlurryHandlerManager_ = $ChemicalHandlerManager$SlurryHandlerManager$Type;
}}
declare module "packages/mekanism/common/tier/$TubeTier" {
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"
import {$CachedLongValue, $CachedLongValue$Type} from "packages/mekanism/common/config/value/$CachedLongValue"

export class $TubeTier extends $Enum<($TubeTier)> implements $ITier {
static readonly "BASIC": $TubeTier
static readonly "ADVANCED": $TubeTier
static readonly "ELITE": $TubeTier
static readonly "ULTIMATE": $TubeTier


public static "get"(tier: $BaseTier$Type): $TubeTier
public static "values"(): ($TubeTier)[]
public static "valueOf"(name: string): $TubeTier
public "getBaseCapacity"(): long
public "getBaseTier"(): $BaseTier
public "setConfigReference"(capacityReference: $CachedLongValue$Type, pullReference: $CachedLongValue$Type): void
public "getTubePullAmount"(): long
public "getTubeCapacity"(): long
public "getBasePull"(): long
get "baseCapacity"(): long
get "baseTier"(): $BaseTier
get "tubePullAmount"(): long
get "tubeCapacity"(): long
get "basePull"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TubeTier$Type = (("elite") | ("advanced") | ("ultimate") | ("basic")) | ($TubeTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TubeTier_ = $TubeTier$Type;
}}
declare module "packages/mekanism/common/upgrade/$BinUpgradeData" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$BinInventorySlot, $BinInventorySlot$Type} from "packages/mekanism/common/inventory/slot/$BinInventorySlot"
import {$IUpgradeData, $IUpgradeData$Type} from "packages/mekanism/common/upgrade/$IUpgradeData"

export class $BinUpgradeData extends $Record implements $IUpgradeData {

constructor(redstone: boolean, binSlot: $BinInventorySlot$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "redstone"(): boolean
public "binSlot"(): $BinInventorySlot
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinUpgradeData$Type = ($BinUpgradeData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinUpgradeData_ = $BinUpgradeData$Type;
}}
declare module "packages/mekanism/common/lib/frequency/$Frequency" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$SecurityMode, $SecurityMode$Type} from "packages/mekanism/api/security/$SecurityMode"
import {$FrequencyType, $FrequencyType$Type} from "packages/mekanism/common/lib/frequency/$FrequencyType"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$Type} from "packages/mekanism/common/lib/frequency/$Frequency$FrequencyIdentity"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$IFrequency, $IFrequency$Type} from "packages/mekanism/api/$IFrequency"

export class $Frequency implements $IFrequency {

constructor(frequencyType: $FrequencyType$Type<(any)>, name: string, uuid: $UUID$Type)
constructor(frequencyType: $FrequencyType$Type<(any)>)

public "getName"(): string
public "equals"(obj: any): boolean
public "hashCode"(): integer
public "update"(tile: $BlockEntity$Type): boolean
public "getKey"(): any
public "write"(buffer: $FriendlyByteBuf$Type): void
public "write"(nbtTags: $CompoundTag$Type): void
public "isPublic"(): boolean
public "getType"(): $FrequencyType<(any)>
public "isValid"(): boolean
public "onRemove"(): void
public "serializeIdentityWithOwner"(): $CompoundTag
public "getClientOwner"(): string
public "tick"(): boolean
public "setValid"(valid: boolean): void
public "ownerMatches"(toCheck: $UUID$Type): boolean
public "isRemoved"(): boolean
public static "readFromPacket"<FREQ extends $Frequency>(dataStream: $FriendlyByteBuf$Type): FREQ
public "getSecurity"(): $SecurityMode
public "writeComponentData"(nbtTags: $CompoundTag$Type): void
public "setPublic"(isPublic: boolean): $Frequency
public "getIdentity"(): $Frequency$FrequencyIdentity
public "onDeactivate"(tile: $BlockEntity$Type): boolean
public "areIdentitiesEqual"(other: $Frequency$Type): boolean
public "getSyncHash"(): integer
public "serializeIdentity"(): $CompoundTag
public "getOwner"(): $UUID
get "name"(): string
get "key"(): any
get "public"(): boolean
get "type"(): $FrequencyType<(any)>
get "valid"(): boolean
get "clientOwner"(): string
set "valid"(value: boolean)
get "removed"(): boolean
get "security"(): $SecurityMode
set "public"(value: boolean)
get "identity"(): $Frequency$FrequencyIdentity
get "syncHash"(): integer
get "owner"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Frequency$Type = ($Frequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Frequency_ = $Frequency$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$DoubleInputRecipeCache$DoubleSameInputRecipeCache" {
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$DoubleInputRecipeCache, $DoubleInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$DoubleInputRecipeCache"
import {$InputIngredient, $InputIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$InputIngredient"
import {$IInputCache, $IInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$IInputCache"

export class $DoubleInputRecipeCache$DoubleSameInputRecipeCache<INPUT, INGREDIENT extends $InputIngredient<(INPUT)>, RECIPE extends ($MekanismRecipe) & ($BiPredicate<(INPUT), (INPUT)>), CACHE extends $IInputCache<(INPUT), (INGREDIENT), (RECIPE)>> extends $DoubleInputRecipeCache<(INPUT), (INGREDIENT), (INPUT), (INGREDIENT), (RECIPE), (CACHE), (CACHE)> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleInputRecipeCache$DoubleSameInputRecipeCache$Type<INPUT, INGREDIENT, RECIPE, CACHE> = ($DoubleInputRecipeCache$DoubleSameInputRecipeCache<(INPUT), (INGREDIENT), (RECIPE), (CACHE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleInputRecipeCache$DoubleSameInputRecipeCache_<INPUT, INGREDIENT, RECIPE, CACHE> = $DoubleInputRecipeCache$DoubleSameInputRecipeCache$Type<(INPUT), (INGREDIENT), (RECIPE), (CACHE)>;
}}
declare module "packages/mekanism/common/block/transmitter/$BlockLargeTransmitter" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$ConnectionType, $ConnectionType$Type} from "packages/mekanism/common/lib/transmitter/$ConnectionType"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockTransmitter, $BlockTransmitter$Type} from "packages/mekanism/common/block/transmitter/$BlockTransmitter"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"

export class $BlockLargeTransmitter extends $BlockTransmitter {
static readonly "CENTER": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties


public static "getSideForType"(type: $ConnectionType$Type, side: $Direction$Type): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockLargeTransmitter$Type = ($BlockLargeTransmitter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockLargeTransmitter_ = $BlockLargeTransmitter$Type;
}}
declare module "packages/mekanism/common/integration/computer/$MethodHelpData$Param" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $MethodHelpData$Param extends $Record {
static readonly "CODEC": $Codec<($MethodHelpData$Param)>

constructor(name: string, type: string, javaType: $Class$Type<(any)>)
constructor(name: string, type: string, javaType: $Class$Type<(any)>, values: $List$Type<(string)>)

public "name"(): string
public "type"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "values"(): $List<(string)>
public "hashCode"(): integer
public "javaType"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodHelpData$Param$Type = ($MethodHelpData$Param);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodHelpData$Param_ = $MethodHelpData$Param$Type;
}}
declare module "packages/mekanism/common/tile/$TileEntityChemicalTank" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IHasGasMode, $IHasGasMode$Type} from "packages/mekanism/common/tile/interfaces/$IHasGasMode"
import {$InfuseType, $InfuseType$Type} from "packages/mekanism/api/chemical/infuse/$InfuseType"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ChemicalTankTier, $ChemicalTankTier$Type} from "packages/mekanism/common/tier/$ChemicalTankTier"
import {$TileEntityConfigurableMachine, $TileEntityConfigurableMachine$Type} from "packages/mekanism/common/tile/prefab/$TileEntityConfigurableMachine"
import {$IPigmentTank, $IPigmentTank$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentTank"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Slurry, $Slurry$Type} from "packages/mekanism/api/chemical/slurry/$Slurry"
import {$Gas, $Gas$Type} from "packages/mekanism/api/chemical/gas/$Gas"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ISustainedData, $ISustainedData$Type} from "packages/mekanism/common/tile/interfaces/$ISustainedData"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IInfusionTank, $IInfusionTank$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionTank"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$PigmentStack, $PigmentStack$Type} from "packages/mekanism/api/chemical/pigment/$PigmentStack"
import {$IUpgradeData, $IUpgradeData$Type} from "packages/mekanism/common/upgrade/$IUpgradeData"
import {$MergedChemicalTank, $MergedChemicalTank$Type} from "packages/mekanism/api/chemical/merged/$MergedChemicalTank"
import {$TileComponentEjector, $TileComponentEjector$Type} from "packages/mekanism/common/tile/component/$TileComponentEjector"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$ISlurryTank, $ISlurryTank$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryTank"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$TileEntityChemicalTank$GasMode, $TileEntityChemicalTank$GasMode$Type} from "packages/mekanism/common/tile/$TileEntityChemicalTank$GasMode"
import {$SlurryStack, $SlurryStack$Type} from "packages/mekanism/api/chemical/slurry/$SlurryStack"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$TileComponentConfig, $TileComponentConfig$Type} from "packages/mekanism/common/tile/component/$TileComponentConfig"
import {$Pigment, $Pigment$Type} from "packages/mekanism/api/chemical/pigment/$Pigment"
import {$InfusionStack, $InfusionStack$Type} from "packages/mekanism/api/chemical/infuse/$InfusionStack"
import {$IChemicalTankHolder, $IChemicalTankHolder$Type} from "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder"
import {$ChemicalTankUpgradeData, $ChemicalTankUpgradeData$Type} from "packages/mekanism/common/upgrade/$ChemicalTankUpgradeData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TileEntityChemicalTank extends $TileEntityConfigurableMachine implements $ISustainedData, $IHasGasMode {
 "dumping": $TileEntityChemicalTank$GasMode
 "ejectorComponent": $TileComponentEjector
 "configComponent": $TileComponentConfig
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "shouldDumpRadiation"(): boolean
public "addContainerTrackers"(container: $MekanismContainer$Type): void
public "nextMode"(tank: integer): void
public "getGasTank"(): $IGasTank
public "getSlurryTank"(): $ISlurryTank
public "getInfusionTank"(): $IInfusionTank
public "getPigmentTank"(): $IPigmentTank
public "getInitialPigmentTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($Pigment), ($PigmentStack), ($IPigmentTank)>
public "getInitialSlurryTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($Slurry), ($SlurryStack), ($ISlurryTank)>
public "getInitialInfusionTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($InfuseType), ($InfusionStack), ($IInfusionTank)>
public "getTier"(): $ChemicalTankTier
public "getUpgradeData"(): $ChemicalTankUpgradeData
public "getInitialGasTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($Gas), ($GasStack), ($IGasTank)>
public "getRedstoneLevel"(): integer
public "readSustainedData"(dataMap: $CompoundTag$Type): void
public "writeSustainedData"(dataMap: $CompoundTag$Type): void
public "parseUpgradeData"(upgradeData: $IUpgradeData$Type): void
public "getChemicalTank"(): $MergedChemicalTank
public "getTileDataRemap"(): $Map<(string), (string)>
public "getDirection"(): $Direction
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "gasTank"(): $IGasTank
get "slurryTank"(): $ISlurryTank
get "infusionTank"(): $IInfusionTank
get "pigmentTank"(): $IPigmentTank
get "tier"(): $ChemicalTankTier
get "upgradeData"(): $ChemicalTankUpgradeData
get "redstoneLevel"(): integer
get "chemicalTank"(): $MergedChemicalTank
get "tileDataRemap"(): $Map<(string), (string)>
get "direction"(): $Direction
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityChemicalTank$Type = ($TileEntityChemicalTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityChemicalTank_ = $TileEntityChemicalTank$Type;
}}
declare module "packages/mekanism/common/registration/impl/$ContainerTypeRegistryObject" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$WrappedRegistryObject, $WrappedRegistryObject$Type} from "packages/mekanism/common/registration/$WrappedRegistryObject"
import {$MenuProvider, $MenuProvider$Type} from "packages/net/minecraft/world/$MenuProvider"
import {$ILangEntry, $ILangEntry$Type} from "packages/mekanism/api/text/$ILangEntry"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"

export class $ContainerTypeRegistryObject<CONTAINER extends $AbstractContainerMenu> extends $WrappedRegistryObject<($MenuType<(CONTAINER)>)> {

constructor(registryObject: $RegistryObject$Type<($MenuType$Type<(CONTAINER)>)>)

public "getProvider"(name: $Component$Type, object: any): $MenuProvider
public "getProvider"(name: $ILangEntry$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type): $MenuProvider
public "getProvider"(name: $Component$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type): $MenuProvider
public "getProvider"(name: $ILangEntry$Type, object: any): $MenuProvider
public "tryOpenGui"(player: $ServerPlayer$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerTypeRegistryObject$Type<CONTAINER> = ($ContainerTypeRegistryObject<(CONTAINER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContainerTypeRegistryObject_<CONTAINER> = $ContainerTypeRegistryObject$Type<(CONTAINER)>;
}}
declare module "packages/mekanism/common/registration/$WrappedDeferredRegister" {
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"
import {$IForgeRegistry, $IForgeRegistry$Type} from "packages/net/minecraftforge/registries/$IForgeRegistry"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RegistryBuilder, $RegistryBuilder$Type} from "packages/net/minecraftforge/registries/$RegistryBuilder"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $WrappedDeferredRegister<T> {


public "register"(bus: $IEventBus$Type): void
public "createAndRegisterChemical"(bus: $IEventBus$Type): $Supplier<($IForgeRegistry<(T)>)>
public "createAndRegister"(bus: $IEventBus$Type, builder: $UnaryOperator$Type<($RegistryBuilder$Type<(T)>)>): $Supplier<($IForgeRegistry<(T)>)>
public "createAndRegister"(bus: $IEventBus$Type): $Supplier<($IForgeRegistry<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedDeferredRegister$Type<T> = ($WrappedDeferredRegister<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedDeferredRegister_<T> = $WrappedDeferredRegister$Type<(T)>;
}}
declare module "packages/mekanism/common/capabilities/resolver/$ICapabilityResolver" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export interface $ICapabilityResolver {

 "resolve"<T>(capability: $Capability$Type<(T)>, side: $Direction$Type): $LazyOptional<(T)>
 "invalidate"(capability: $Capability$Type<(any)>, side: $Direction$Type): void
 "invalidateAll"(): void
 "getSupportedCapabilities"(): $List<($Capability<(any)>)>
}

export namespace $ICapabilityResolver {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICapabilityResolver$Type = ($ICapabilityResolver);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICapabilityResolver_ = $ICapabilityResolver$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ItemStackChemicalToItemStackRecipeSerializer$IFactory" {
import {$ChemicalStackIngredient, $ChemicalStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient"
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ItemStackChemicalToItemStackRecipe, $ItemStackChemicalToItemStackRecipe$Type} from "packages/mekanism/api/recipes/chemical/$ItemStackChemicalToItemStackRecipe"

export interface $ItemStackChemicalToItemStackRecipeSerializer$IFactory<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, INGREDIENT extends $ChemicalStackIngredient<(CHEMICAL), (STACK)>, RECIPE extends $ItemStackChemicalToItemStackRecipe<(CHEMICAL), (STACK), (INGREDIENT)>> {

 "create"(id: $ResourceLocation$Type, itemInput: $ItemStackIngredient$Type, chemicalInput: INGREDIENT, output: $ItemStack$Type): RECIPE

(id: $ResourceLocation$Type, itemInput: $ItemStackIngredient$Type, chemicalInput: INGREDIENT, output: $ItemStack$Type): RECIPE
}

export namespace $ItemStackChemicalToItemStackRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackChemicalToItemStackRecipeSerializer$IFactory$Type<CHEMICAL, STACK, INGREDIENT, RECIPE> = ($ItemStackChemicalToItemStackRecipeSerializer$IFactory<(CHEMICAL), (STACK), (INGREDIENT), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackChemicalToItemStackRecipeSerializer$IFactory_<CHEMICAL, STACK, INGREDIENT, RECIPE> = $ItemStackChemicalToItemStackRecipeSerializer$IFactory$Type<(CHEMICAL), (STACK), (INGREDIENT), (RECIPE)>;
}}
declare module "packages/mekanism/common/capabilities/resolver/$BasicSidedCapabilityResolver$ProxyCreator" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IHolder, $IHolder$Type} from "packages/mekanism/common/capabilities/holder/$IHolder"

export interface $BasicSidedCapabilityResolver$ProxyCreator<HANDLER, SIDED_HANDLER extends HANDLER> {

 "create"(handler: SIDED_HANDLER, side: $Direction$Type, holder: $IHolder$Type): HANDLER

(handler: SIDED_HANDLER, side: $Direction$Type, holder: $IHolder$Type): HANDLER
}

export namespace $BasicSidedCapabilityResolver$ProxyCreator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicSidedCapabilityResolver$ProxyCreator$Type<HANDLER, SIDED_HANDLER> = ($BasicSidedCapabilityResolver$ProxyCreator<(HANDLER), (SIDED_HANDLER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicSidedCapabilityResolver$ProxyCreator_<HANDLER, SIDED_HANDLER> = $BasicSidedCapabilityResolver$ProxyCreator$Type<(HANDLER), (SIDED_HANDLER)>;
}}
declare module "packages/mekanism/common/recipe/serializer/$FluidSlurryToSlurryRecipeSerializer$IFactory" {
import {$FluidStackIngredient, $FluidStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$FluidStackIngredient"
import {$SlurryStack, $SlurryStack$Type} from "packages/mekanism/api/chemical/slurry/$SlurryStack"
import {$ChemicalStackIngredient$SlurryStackIngredient, $ChemicalStackIngredient$SlurryStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient$SlurryStackIngredient"
import {$FluidSlurryToSlurryRecipe, $FluidSlurryToSlurryRecipe$Type} from "packages/mekanism/api/recipes/$FluidSlurryToSlurryRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $FluidSlurryToSlurryRecipeSerializer$IFactory<RECIPE extends $FluidSlurryToSlurryRecipe> {

 "create"(id: $ResourceLocation$Type, fluidInput: $FluidStackIngredient$Type, slurryInput: $ChemicalStackIngredient$SlurryStackIngredient$Type, output: $SlurryStack$Type): RECIPE

(id: $ResourceLocation$Type, fluidInput: $FluidStackIngredient$Type, slurryInput: $ChemicalStackIngredient$SlurryStackIngredient$Type, output: $SlurryStack$Type): RECIPE
}

export namespace $FluidSlurryToSlurryRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidSlurryToSlurryRecipeSerializer$IFactory$Type<RECIPE> = ($FluidSlurryToSlurryRecipeSerializer$IFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidSlurryToSlurryRecipeSerializer$IFactory_<RECIPE> = $FluidSlurryToSlurryRecipeSerializer$IFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/capabilities/merged/$MergedTank$CurrentType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $MergedTank$CurrentType extends $Enum<($MergedTank$CurrentType)> {
static readonly "EMPTY": $MergedTank$CurrentType
static readonly "FLUID": $MergedTank$CurrentType
static readonly "GAS": $MergedTank$CurrentType
static readonly "INFUSION": $MergedTank$CurrentType
static readonly "PIGMENT": $MergedTank$CurrentType
static readonly "SLURRY": $MergedTank$CurrentType


public static "values"(): ($MergedTank$CurrentType)[]
public static "valueOf"(name: string): $MergedTank$CurrentType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MergedTank$CurrentType$Type = (("infusion") | ("gas") | ("pigment") | ("fluid") | ("slurry") | ("empty")) | ($MergedTank$CurrentType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MergedTank$CurrentType_ = $MergedTank$CurrentType$Type;
}}
declare module "packages/mekanism/common/resource/ore/$OreType" {
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$Type} from "packages/net/minecraft/util/$StringRepresentable$EnumCodec"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Keyable, $Keyable$Type} from "packages/com/mojang/serialization/$Keyable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$IResource, $IResource$Type} from "packages/mekanism/common/resource/$IResource"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BaseOreConfig, $BaseOreConfig$Type} from "packages/mekanism/common/resource/ore/$BaseOreConfig"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $OreType extends $Enum<($OreType)> implements $StringRepresentable {
static readonly "TIN": $OreType
static readonly "OSMIUM": $OreType
static readonly "URANIUM": $OreType
static readonly "FLUORITE": $OreType
static readonly "LEAD": $OreType
static "CODEC": $Codec<($OreType)>


public static "get"(resource: $IResource$Type): $OreType
public static "values"(): ($OreType)[]
public static "valueOf"(name: string): $OreType
public "getResource"(): $IResource
public "getSerializedName"(): string
public "getBaseConfigs"(): $List<($BaseOreConfig)>
public "getMaxExp"(): integer
public "getMinExp"(): integer
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$Type<((E)[])>, arg1: $Function$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$Type)[]): $Keyable
get "resource"(): $IResource
get "serializedName"(): string
get "baseConfigs"(): $List<($BaseOreConfig)>
get "maxExp"(): integer
get "minExp"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreType$Type = (("tin") | ("osmium") | ("fluorite") | ("uranium") | ("lead")) | ($OreType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OreType_ = $OreType$Type;
}}
declare module "packages/mekanism/common/capabilities/resolver/manager/$CapabilityHandlerManager" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$BasicSidedCapabilityResolver, $BasicSidedCapabilityResolver$Type} from "packages/mekanism/common/capabilities/resolver/$BasicSidedCapabilityResolver"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IHolder, $IHolder$Type} from "packages/mekanism/common/capabilities/holder/$IHolder"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$ICapabilityHandlerManager, $ICapabilityHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$ICapabilityHandlerManager"

export class $CapabilityHandlerManager<HOLDER extends $IHolder, CONTAINER, HANDLER, SIDED_HANDLER extends HANDLER> extends $BasicSidedCapabilityResolver<(HANDLER), (SIDED_HANDLER)> implements $ICapabilityHandlerManager<(CONTAINER)> {


public "resolve"<T>(capability: $Capability$Type<(T)>, side: $Direction$Type): $LazyOptional<(T)>
public "canHandle"(): boolean
public "getContainers"(side: $Direction$Type): $List<(CONTAINER)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CapabilityHandlerManager$Type<HOLDER, CONTAINER, HANDLER, SIDED_HANDLER> = ($CapabilityHandlerManager<(HOLDER), (CONTAINER), (HANDLER), (SIDED_HANDLER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CapabilityHandlerManager_<HOLDER, CONTAINER, HANDLER, SIDED_HANDLER> = $CapabilityHandlerManager$Type<(HOLDER), (CONTAINER), (HANDLER), (SIDED_HANDLER)>;
}}
declare module "packages/mekanism/common/tile/transmitter/$TileEntityLogisticalTransporter" {
import {$TileEntityLogisticalTransporterBase, $TileEntityLogisticalTransporterBase$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityLogisticalTransporterBase"
import {$TransmitterType, $TransmitterType$Type} from "packages/mekanism/common/block/states/$TransmitterType"
import {$TransmitterModelData, $TransmitterModelData$Type} from "packages/mekanism/client/model/data/$TransmitterModelData"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $TileEntityLogisticalTransporter extends $TileEntityLogisticalTransporterBase {
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "getTransmitterType"(): $TransmitterType
get "transmitterType"(): $TransmitterType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityLogisticalTransporter$Type = ($TileEntityLogisticalTransporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityLogisticalTransporter_ = $TileEntityLogisticalTransporter$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemMekaTool" {
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IBlastingItem, $IBlastingItem$Type} from "packages/mekanism/common/content/gear/$IBlastingItem"
import {$IModuleDataProvider, $IModuleDataProvider$Type} from "packages/mekanism/api/providers/$IModuleDataProvider"
import {$IHUDElement, $IHUDElement$Type} from "packages/mekanism/api/gear/$IHUDElement"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ICustomModule, $ICustomModule$Type} from "packages/mekanism/api/gear/$ICustomModule"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ToolAction, $ToolAction$Type} from "packages/net/minecraftforge/common/$ToolAction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IModuleContainerItem, $IModuleContainerItem$Type} from "packages/mekanism/common/content/gear/$IModuleContainerItem"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$IModule, $IModule$Type} from "packages/mekanism/api/gear/$IModule"
import {$Module, $Module$Type} from "packages/mekanism/common/content/gear/$Module"
import {$IGenericRadialModeItem, $IGenericRadialModeItem$Type} from "packages/mekanism/common/lib/radial/$IGenericRadialModeItem"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$ItemEnergized, $ItemEnergized$Type} from "packages/mekanism/common/item/$ItemEnergized"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$UseOnContext, $UseOnContext$Type} from "packages/net/minecraft/world/item/context/$UseOnContext"
import {$ModuleData, $ModuleData$Type} from "packages/mekanism/api/gear/$ModuleData"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$IRadialMode, $IRadialMode$Type} from "packages/mekanism/api/radial/mode/$IRadialMode"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$RadialData, $RadialData$Type} from "packages/mekanism/api/radial/$RadialData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemMekaTool extends $ItemEnergized implements $IModuleContainerItem, $IBlastingItem, $IGenericRadialModeItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "setMode"<M extends $IRadialMode>(stack: $ItemStack$Type, player: $Player$Type, radialData: $RadialData$Type<(M)>, mode: M): void
public "getMode"<M extends $IRadialMode>(stack: $ItemStack$Type, radialData: $RadialData$Type<(M)>): M
public "getEnchantmentLevel"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): integer
public "canPerformAction"(stack: $ItemStack$Type, action: $ToolAction$Type): boolean
public "getBlastedBlocks"(world: $Level$Type, player: $Player$Type, stack: $ItemStack$Type, pos: $BlockPos$Type, state: $BlockState$Type): $Map<($BlockPos), ($BlockState)>
public "getAllEnchantments"(stack: $ItemStack$Type): $Map<($Enchantment), (integer)>
public "getDestroyEnergy"(itemStack: $ItemStack$Type, hardness: float, silk: boolean): $FloatingLong
public "getAttributeModifiers"(slot: $EquipmentSlot$Type, stack: $ItemStack$Type): $Multimap<($Attribute), ($AttributeModifier)>
public "isNotReplaceableByPickAction"(stack: $ItemStack$Type, player: $Player$Type, inventorySlot: integer): boolean
public "canApplyAtEnchantingTable"(stack: $ItemStack$Type, enchantment: $Enchantment$Type): boolean
public "supportsSlotType"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public "isCorrectToolForDrops"(state: $BlockState$Type): boolean
public "interactLivingEntity"(stack: $ItemStack$Type, player: $Player$Type, entity: $LivingEntity$Type, hand: $InteractionHand$Type): $InteractionResult
public "mineBlock"(stack: $ItemStack$Type, world: $Level$Type, state: $BlockState$Type, pos: $BlockPos$Type, entityliving: $LivingEntity$Type): boolean
public "use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$Type): $InteractionResult
public "getDestroySpeed"(stack: $ItemStack$Type, state: $BlockState$Type): float
public "hurtEnemy"(stack: $ItemStack$Type, target: $LivingEntity$Type, attacker: $LivingEntity$Type): boolean
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "isEnchantable"(stack: $ItemStack$Type): boolean
public "onBlockStartBreak"(stack: $ItemStack$Type, pos: $BlockPos$Type, player: $Player$Type): boolean
public "isBookEnchantable"(stack: $ItemStack$Type, book: $ItemStack$Type): boolean
public "getScrollTextComponent"(stack: $ItemStack$Type): $Component
public "getRadialData"(stack: $ItemStack$Type): $RadialData<(any)>
public "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
public "hasEnergyForDigAction"(stack: $ItemStack$Type): boolean
public "getModule"<MODULE extends $ICustomModule<(MODULE)>>(stack: $ItemStack$Type, typeProvider: $IModuleDataProvider$Type<(MODULE)>): $IModule<(MODULE)>
public "addModuleDetails"(stack: $ItemStack$Type, tooltip: $List$Type<($Component$Type)>): void
public "isModuleEnabled"(stack: $ItemStack$Type, type: $IModuleDataProvider$Type<(any)>): boolean
public "supportsModule"(stack: $ItemStack$Type, typeProvider: $IModuleDataProvider$Type<(any)>): boolean
public "getHUDElements"(player: $Player$Type, stack: $ItemStack$Type): $List<($IHUDElement)>
public "removeModule"(stack: $ItemStack$Type, type: $ModuleData$Type<(any)>): void
public "hasModule"(stack: $ItemStack$Type, type: $IModuleDataProvider$Type<(any)>): boolean
public "addModule"(stack: $ItemStack$Type, type: $ModuleData$Type<(any)>): void
public "getModules"(stack: $ItemStack$Type): $List<($Module<(any)>)>
public "addHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): void
public static "canBlastBlock"(world: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type): boolean
public static "findPositions"(world: $Level$Type, targetPos: $BlockPos$Type, player: $Player$Type, radius: integer): $Map<($BlockPos), ($BlockState)>
public "addCurioHUDStrings"(list: $List$Type<($Component$Type)>, player: $Player$Type, stack: $ItemStack$Type): void
public static "displayModeChange"(player: $Player$Type): void
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$Type, slotType: $EquipmentSlot$Type, allowRadial: boolean): boolean
public static "isModeItem"(player: $Player$Type, slotType: $EquipmentSlot$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemMekaTool$Type = ($ItemMekaTool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemMekaTool_ = $ItemMekaTool$Type;
}}
declare module "packages/mekanism/common/inventory/container/$QIOItemViewerContainer$SortDirection" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiComponents$IToggleEnum, $GuiComponents$IToggleEnum$Type} from "packages/mekanism/common/inventory/$GuiComponents$IToggleEnum"

export class $QIOItemViewerContainer$SortDirection extends $Enum<($QIOItemViewerContainer$SortDirection)> implements $GuiComponents$IToggleEnum<($QIOItemViewerContainer$SortDirection)> {
static readonly "ASCENDING": $QIOItemViewerContainer$SortDirection
static readonly "DESCENDING": $QIOItemViewerContainer$SortDirection


public static "values"(): ($QIOItemViewerContainer$SortDirection)[]
public static "valueOf"(name: string): $QIOItemViewerContainer$SortDirection
public "getIcon"(): $ResourceLocation
public "isAscending"(): boolean
public "getTooltip"(): $Component
get "icon"(): $ResourceLocation
get "ascending"(): boolean
get "tooltip"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOItemViewerContainer$SortDirection$Type = (("ascending") | ("descending")) | ($QIOItemViewerContainer$SortDirection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOItemViewerContainer$SortDirection_ = $QIOItemViewerContainer$SortDirection$Type;
}}
declare module "packages/mekanism/common/tile/transmitter/$TileEntityThermodynamicConductor" {
import {$TransmitterType, $TransmitterType$Type} from "packages/mekanism/common/block/states/$TransmitterType"
import {$TransmitterModelData, $TransmitterModelData$Type} from "packages/mekanism/client/model/data/$TransmitterModelData"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ConnectionType, $ConnectionType$Type} from "packages/mekanism/common/lib/transmitter/$ConnectionType"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $TileEntityThermodynamicConductor extends $TileEntityTransmitter {
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "getTransmitterType"(): $TransmitterType
public "sideChanged"(side: $Direction$Type, old: $ConnectionType$Type, type: $ConnectionType$Type): void
public "redstoneChanged"(powered: boolean): void
get "transmitterType"(): $TransmitterType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityThermodynamicConductor$Type = ($TileEntityThermodynamicConductor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityThermodynamicConductor_ = $TileEntityThermodynamicConductor$Type;
}}
declare module "packages/mekanism/common/tile/component/$TileComponentEjector" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FloatingLongSupplier, $FloatingLongSupplier$Type} from "packages/mekanism/api/math/$FloatingLongSupplier"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntSupplier, $IntSupplier$Type} from "packages/java/util/function/$IntSupplier"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$ITileComponent, $ITileComponent$Type} from "packages/mekanism/common/tile/component/$ITileComponent"
import {$TransmissionType, $TransmissionType$Type} from "packages/mekanism/common/lib/transmitter/$TransmissionType"
import {$RelativeSide, $RelativeSide$Type} from "packages/mekanism/api/$RelativeSide"
import {$ConfigInfo, $ConfigInfo$Type} from "packages/mekanism/common/tile/component/config/$ConfigInfo"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$IChemicalTank, $IChemicalTank$Type} from "packages/mekanism/api/chemical/$IChemicalTank"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TileComponentConfig, $TileComponentConfig$Type} from "packages/mekanism/common/tile/component/$TileComponentConfig"
import {$LongSupplier, $LongSupplier$Type} from "packages/java/util/function/$LongSupplier"
import {$ISyncableData, $ISyncableData$Type} from "packages/mekanism/common/inventory/container/sync/$ISyncableData"
import {$MekanismContainer$ISpecificContainerTracker, $MekanismContainer$ISpecificContainerTracker$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer$ISpecificContainerTracker"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"

export class $TileComponentEjector implements $ITileComponent, $MekanismContainer$ISpecificContainerTracker {

constructor(tile: $TileEntityMekanism$Type, chemicalEjectRate: $LongSupplier$Type, fluidEjectRate: $IntSupplier$Type, energyEjectRate: $FloatingLongSupplier$Type)
constructor(tile: $TileEntityMekanism$Type, energyEjectRate: $FloatingLongSupplier$Type)
constructor(tile: $TileEntityMekanism$Type, chemicalEjectRate: $LongSupplier$Type, fluidEjectRate: $IntSupplier$Type)
constructor(tile: $TileEntityMekanism$Type, chemicalEjectRate: $LongSupplier$Type)
constructor(tile: $TileEntityMekanism$Type)

public "write"(nbtTags: $CompoundTag$Type): void
public "read"(nbtTags: $CompoundTag$Type): void
public "setCanEject"(canEject: $Predicate$Type<($TransmissionType$Type)>): $TileComponentEjector
public "setOutputColor"(color: $EnumColor$Type): void
public "setInputColor"(side: $RelativeSide$Type, color: $EnumColor$Type): void
public "getInputColor"(side: $RelativeSide$Type): $EnumColor
public "getOutputColor"(): $EnumColor
public "hasStrictInput"(): boolean
public "setStrictInput"(strict: boolean): void
public "tickServer"(): void
public "getSpecificSyncableData"(): $List<($ISyncableData)>
public "setOutputData"(config: $TileComponentConfig$Type, ...types: ($TransmissionType$Type)[]): $TileComponentEjector
public "setCanTankEject"(canTankEject: $Predicate$Type<($IChemicalTank$Type<(any), (any)>)>): $TileComponentEjector
public "isEjecting"(info: $ConfigInfo$Type, type: $TransmissionType$Type): boolean
public "isInputSideEnabled"(side: $RelativeSide$Type): boolean
public "removed"(): void
public "invalidate"(): void
public "trackForMainContainer"(container: $MekanismContainer$Type): void
public "readFromUpdateTag"(updateTag: $CompoundTag$Type): void
public "addToUpdateTag"(updateTag: $CompoundTag$Type): void
set "canEject"(value: $Predicate$Type<($TransmissionType$Type)>)
set "outputColor"(value: $EnumColor$Type)
get "outputColor"(): $EnumColor
set "strictInput"(value: boolean)
get "specificSyncableData"(): $List<($ISyncableData)>
set "canTankEject"(value: $Predicate$Type<($IChemicalTank$Type<(any), (any)>)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileComponentEjector$Type = ($TileComponentEjector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileComponentEjector_ = $TileComponentEjector$Type;
}}
declare module "packages/mekanism/common/lib/transmitter/acceptor/$AbstractAcceptorCache" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractAcceptorInfo, $AbstractAcceptorInfo$Type} from "packages/mekanism/common/lib/transmitter/acceptor/$AbstractAcceptorInfo"

export class $AbstractAcceptorCache<ACCEPTOR, INFO extends $AbstractAcceptorInfo> {
 "currentAcceptorConnections": byte


public "clear"(): void
public "invalidateCachedAcceptor"(side: $Direction$Type): void
public "getCachedAcceptor"(side: $Direction$Type): $LazyOptional<(ACCEPTOR)>
public "getConnectedAcceptors"(sides: $Set$Type<($Direction$Type)>): $List<(ACCEPTOR)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractAcceptorCache$Type<ACCEPTOR, INFO> = ($AbstractAcceptorCache<(ACCEPTOR), (INFO)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractAcceptorCache_<ACCEPTOR, INFO> = $AbstractAcceptorCache$Type<(ACCEPTOR), (INFO)>;
}}
declare module "packages/mekanism/common/block/prefab/$BlockFactoryMachine$BlockFactoryMachineModel" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IStateFluidLoggable, $IStateFluidLoggable$Type} from "packages/mekanism/common/block/states/$IStateFluidLoggable"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$BlockFactoryMachine, $BlockFactoryMachine$Type} from "packages/mekanism/common/block/prefab/$BlockFactoryMachine"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Machine$FactoryMachine, $Machine$FactoryMachine$Type} from "packages/mekanism/common/content/blocktype/$Machine$FactoryMachine"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockFactoryMachine$BlockFactoryMachineModel<TILE extends $TileEntityMekanism, MACHINE extends $Machine$FactoryMachine<(TILE)>> extends $BlockFactoryMachine<(TILE), (MACHINE)> implements $IStateFluidLoggable {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(machineType: MACHINE, propertiesModifier: $UnaryOperator$Type<($BlockBehaviour$Properties$Type)>)

public "setState"(state: $BlockState$Type, fluid: $Fluid$Type): $BlockState
public "getFluidLightLevel"(state: $BlockState$Type): integer
public "getFluid"(state: $BlockState$Type): $FluidState
public "canPlaceLiquid"(world: $BlockGetter$Type, pos: $BlockPos$Type, state: $BlockState$Type, fluid: $Fluid$Type): boolean
public "pickupBlock"(world: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type): $ItemStack
public "getPickupSound"(state: $BlockState$Type): $Optional<($SoundEvent)>
public "placeLiquid"(world: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type, fluidState: $FluidState$Type): boolean
public "getPickupSound"(): $Optional<($SoundEvent)>
public "getFluidLoggedProperty"(): $EnumProperty<(any)>
public "isValidFluid"(fluid: $Fluid$Type): boolean
public "updateFluids"(state: $BlockState$Type, world: $LevelAccessor$Type, currentPos: $BlockPos$Type): void
get "pickupSound"(): $Optional<($SoundEvent)>
get "fluidLoggedProperty"(): $EnumProperty<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockFactoryMachine$BlockFactoryMachineModel$Type<TILE, MACHINE> = ($BlockFactoryMachine$BlockFactoryMachineModel<(TILE), (MACHINE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockFactoryMachine$BlockFactoryMachineModel_<TILE, MACHINE> = $BlockFactoryMachine$BlockFactoryMachineModel$Type<(TILE), (MACHINE)>;
}}
declare module "packages/mekanism/common/tile/component/$TileComponentSecurity" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$SecurityMode, $SecurityMode$Type} from "packages/mekanism/api/security/$SecurityMode"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$ITileComponent, $ITileComponent$Type} from "packages/mekanism/common/tile/component/$ITileComponent"
import {$SecurityFrequency, $SecurityFrequency$Type} from "packages/mekanism/common/lib/security/$SecurityFrequency"

export class $TileComponentSecurity implements $ITileComponent {
readonly "tile": $TileEntityMekanism

constructor(tile: $TileEntityMekanism$Type)

public "write"(nbtTags: $CompoundTag$Type): void
public "read"(nbtTags: $CompoundTag$Type): void
public "setMode"(mode: $SecurityMode$Type): void
public "getMode"(): $SecurityMode
public "trackForMainContainer"(container: $MekanismContainer$Type): void
public "readFromUpdateTag"(updateTag: $CompoundTag$Type): void
public "addToUpdateTag"(updateTag: $CompoundTag$Type): void
public "getFrequency"(): $SecurityFrequency
public "setOwnerUUID"(uuid: $UUID$Type): void
public "getOwnerName"(): string
public "getOwnerUUID"(): $UUID
public "removed"(): void
public "invalidate"(): void
set "mode"(value: $SecurityMode$Type)
get "mode"(): $SecurityMode
get "frequency"(): $SecurityFrequency
set "ownerUUID"(value: $UUID$Type)
get "ownerName"(): string
get "ownerUUID"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileComponentSecurity$Type = ($TileComponentSecurity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileComponentSecurity_ = $TileComponentSecurity$Type;
}}
declare module "packages/mekanism/common/item/block/transmitter/$ItemBlockMechanicalPipe" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemBlockMekanism, $ItemBlockMekanism$Type} from "packages/mekanism/common/item/block/$ItemBlockMekanism"
import {$BlockMechanicalPipe, $BlockMechanicalPipe$Type} from "packages/mekanism/common/block/transmitter/$BlockMechanicalPipe"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockMechanicalPipe extends $ItemBlockMekanism<($BlockMechanicalPipe)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockMechanicalPipe$Type)

public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockMechanicalPipe$Type = ($ItemBlockMechanicalPipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockMechanicalPipe_ = $ItemBlockMechanicalPipe$Type;
}}
declare module "packages/mekanism/common/item/block/transmitter/$ItemBlockUniversalCable" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemBlockMekanism, $ItemBlockMekanism$Type} from "packages/mekanism/common/item/block/$ItemBlockMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockUniversalCable, $BlockUniversalCable$Type} from "packages/mekanism/common/block/transmitter/$BlockUniversalCable"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockUniversalCable extends $ItemBlockMekanism<($BlockUniversalCable)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockUniversalCable$Type)

public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockUniversalCable$Type = ($ItemBlockUniversalCable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockUniversalCable_ = $ItemBlockUniversalCable$Type;
}}
declare module "packages/mekanism/common/block/$BlockPersonalBarrel" {
import {$BlockPersonalStorage, $BlockPersonalStorage$Type} from "packages/mekanism/common/block/$BlockPersonalStorage"
import {$Attribute, $Attribute$Type} from "packages/mekanism/common/block/attribute/$Attribute"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$TileEntityPersonalBarrel, $TileEntityPersonalBarrel$Type} from "packages/mekanism/common/tile/$TileEntityPersonalBarrel"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockPersonalBarrel extends $BlockPersonalStorage<($TileEntityPersonalBarrel), ($BlockTypeTile<($TileEntityPersonalBarrel)>)> {
static readonly "PERSONAL_STORAGE_INVENTORY": $Attribute
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor()

/**
 * 
 * @deprecated
 */
public "tick"(state: $BlockState$Type, level: $ServerLevel$Type, pos: $BlockPos$Type, random: $RandomSource$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPersonalBarrel$Type = ($BlockPersonalBarrel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPersonalBarrel_ = $BlockPersonalBarrel$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ItemStackToEnergyRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ItemStackToEnergyRecipe, $ItemStackToEnergyRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackToEnergyRecipe"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ItemStackToEnergyRecipeSerializer$IFactory, $ItemStackToEnergyRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackToEnergyRecipeSerializer$IFactory"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ItemStackToEnergyRecipeSerializer<RECIPE extends $ItemStackToEnergyRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(factory: $ItemStackToEnergyRecipeSerializer$IFactory$Type<(RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackToEnergyRecipeSerializer$Type<RECIPE> = ($ItemStackToEnergyRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackToEnergyRecipeSerializer_<RECIPE> = $ItemStackToEnergyRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/item/interfaces/$IGuiItem" {
import {$ContainerTypeRegistryObject, $ContainerTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$ContainerTypeRegistryObject"

export interface $IGuiItem {

 "getContainerType"(): $ContainerTypeRegistryObject<(any)>

(): $ContainerTypeRegistryObject<(any)>
}

export namespace $IGuiItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGuiItem$Type = ($IGuiItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGuiItem_ = $IGuiItem$Type;
}}
declare module "packages/mekanism/common/tile/base/$CapabilityTileEntity" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$TileEntityUpdateable, $TileEntityUpdateable$Type} from "packages/mekanism/common/tile/base/$TileEntityUpdateable"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $CapabilityTileEntity extends $TileEntityUpdateable {
 "blockState": $BlockState

constructor(type: $TileEntityTypeRegistryObject$Type<(any)>, pos: $BlockPos$Type, state: $BlockState$Type)

public "invalidateCaps"(): void
public "getCapability"<T>(capability: $Capability$Type<(T)>, side: $Direction$Type): $LazyOptional<(T)>
public "invalidateCachedCapabilities"(): void
public "invalidateCapability"(capability: $Capability$Type<(any)>, side: $Direction$Type): void
public "invalidateCapability"(capability: $Capability$Type<(any)>, ...sides: ($Direction$Type)[]): void
public "invalidateCapabilities"(capabilities: $Collection$Type<($Capability$Type<(any)>)>, side: $Direction$Type): void
public "invalidateCapabilities"(capabilities: $Collection$Type<($Capability$Type<(any)>)>, ...sides: ($Direction$Type)[]): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CapabilityTileEntity$Type = ($CapabilityTileEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CapabilityTileEntity_ = $CapabilityTileEntity$Type;
}}
declare module "packages/mekanism/common/block/$BlockBounding" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$TileEntityTypeRegistryObject"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IHasTileEntity, $IHasTileEntity$Type} from "packages/mekanism/common/block/interfaces/$IHasTileEntity"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IStateFluidLoggable, $IStateFluidLoggable$Type} from "packages/mekanism/common/block/states/$IStateFluidLoggable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$PathComputationType, $PathComputationType$Type} from "packages/net/minecraft/world/level/pathfinder/$PathComputationType"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$IClientBlockExtensions, $IClientBlockExtensions$Type} from "packages/net/minecraftforge/client/extensions/common/$IClientBlockExtensions"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$TileEntityBoundingBlock, $TileEntityBoundingBlock$Type} from "packages/mekanism/common/tile/$TileEntityBoundingBlock"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"
import {$RenderShape, $RenderShape$Type} from "packages/net/minecraft/world/level/block/$RenderShape"

export class $BlockBounding extends $Block implements $IHasTileEntity<($TileEntityBoundingBlock)>, $IStateFluidLoggable {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor()

public "playerDestroy"(world: $Level$Type, player: $Player$Type, pos: $BlockPos$Type, state: $BlockState$Type, te: $BlockEntity$Type, stack: $ItemStack$Type): void
public "getStateForPlacement"(context: $BlockPlaceContext$Type): $BlockState
public "initializeClient"(consumer: $Consumer$Type<($IClientBlockExtensions$Type)>): void
public "onBlockExploded"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, explosion: $Explosion$Type): void
public "getExplosionResistance"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, explosion: $Explosion$Type): float
public "onDestroyedByPlayer"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, willHarvest: boolean, fluidState: $FluidState$Type): boolean
/**
 * 
 * @deprecated
 */
public "neighborChanged"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, neighborBlock: $Block$Type, neighborPos: $BlockPos$Type, isMoving: boolean): void
/**
 * 
 * @deprecated
 */
public "updateShape"(state: $BlockState$Type, facing: $Direction$Type, facingState: $BlockState$Type, world: $LevelAccessor$Type, currentPos: $BlockPos$Type, facingPos: $BlockPos$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "isPathfindable"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, type: $PathComputationType$Type): boolean
/**
 * 
 * @deprecated
 */
public "onRemove"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, newState: $BlockState$Type, isMoving: boolean): void
/**
 * 
 * @deprecated
 */
public "triggerEvent"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, id: integer, param: integer): boolean
/**
 * 
 * @deprecated
 */
public "use"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
/**
 * 
 * @deprecated
 */
public "getRenderShape"(state: $BlockState$Type): $RenderShape
/**
 * 
 * @deprecated
 */
public "getFluidState"(state: $BlockState$Type): $FluidState
/**
 * 
 * @deprecated
 */
public "hasAnalogOutputSignal"(blockState: $BlockState$Type): boolean
/**
 * 
 * @deprecated
 */
public "getOcclusionShape"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type): $VoxelShape
/**
 * 
 * @deprecated
 */
public "getBlockSupportShape"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type): $VoxelShape
/**
 * 
 * @deprecated
 */
public "getInteractionShape"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type): $VoxelShape
/**
 * 
 * @deprecated
 */
public "getCollisionShape"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
/**
 * 
 * @deprecated
 */
public "getAnalogOutputSignal"(blockState: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type): integer
/**
 * 
 * @deprecated
 */
public "getVisualShape"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
/**
 * 
 * @deprecated
 */
public "getShape"(state: $BlockState$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
/**
 * 
 * @deprecated
 */
public "getDestroyProgress"(state: $BlockState$Type, player: $Player$Type, world: $BlockGetter$Type, pos: $BlockPos$Type): float
/**
 * 
 * @deprecated
 */
public "spawnAfterBreak"(state: $BlockState$Type, level: $ServerLevel$Type, pos: $BlockPos$Type, stack: $ItemStack$Type, dropExperience: boolean): void
public "getTileType"(): $TileEntityTypeRegistryObject<($TileEntityBoundingBlock)>
public "getCloneItemStack"(state: $BlockState$Type, target: $HitResult$Type, world: $BlockGetter$Type, pos: $BlockPos$Type, player: $Player$Type): $ItemStack
public static "getMainBlockPos"(world: $BlockGetter$Type, thisPos: $BlockPos$Type): $BlockPos
public "createDummyBlockEntity"(state: $BlockState$Type): $TileEntityBoundingBlock
public "createDummyBlockEntity"(): $TileEntityBoundingBlock
public "triggerBlockEntityEvent"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, id: integer, param: integer): boolean
public "newBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type): $TileEntityBoundingBlock
public "getTicker"<T extends $BlockEntity>(level: $Level$Type, state: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
public "setState"(state: $BlockState$Type, fluid: $Fluid$Type): $BlockState
public "getFluidLightLevel"(state: $BlockState$Type): integer
public "getFluid"(state: $BlockState$Type): $FluidState
public "canPlaceLiquid"(world: $BlockGetter$Type, pos: $BlockPos$Type, state: $BlockState$Type, fluid: $Fluid$Type): boolean
public "pickupBlock"(world: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type): $ItemStack
public "getPickupSound"(state: $BlockState$Type): $Optional<($SoundEvent)>
public "placeLiquid"(world: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type, fluidState: $FluidState$Type): boolean
public "getPickupSound"(): $Optional<($SoundEvent)>
public "getFluidLoggedProperty"(): $EnumProperty<(any)>
public "isValidFluid"(fluid: $Fluid$Type): boolean
public "updateFluids"(state: $BlockState$Type, world: $LevelAccessor$Type, currentPos: $BlockPos$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
get "tileType"(): $TileEntityTypeRegistryObject<($TileEntityBoundingBlock)>
get "pickupSound"(): $Optional<($SoundEvent)>
get "fluidLoggedProperty"(): $EnumProperty<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBounding$Type = ($BlockBounding);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBounding_ = $BlockBounding$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemAtomicDisassembler$DisassemblerMode" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IHasTextComponent, $IHasTextComponent$Type} from "packages/mekanism/api/text/$IHasTextComponent"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IDisableableEnum, $IDisableableEnum$Type} from "packages/mekanism/api/$IDisableableEnum"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IRadialMode, $IRadialMode$Type} from "packages/mekanism/api/radial/mode/$IRadialMode"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"

export class $ItemAtomicDisassembler$DisassemblerMode extends $Enum<($ItemAtomicDisassembler$DisassemblerMode)> implements $IDisableableEnum<($ItemAtomicDisassembler$DisassemblerMode)>, $IHasTextComponent, $IRadialMode {
static readonly "NORMAL": $ItemAtomicDisassembler$DisassemblerMode
static readonly "SLOW": $ItemAtomicDisassembler$DisassemblerMode
static readonly "FAST": $ItemAtomicDisassembler$DisassemblerMode
static readonly "VEIN": $ItemAtomicDisassembler$DisassemblerMode
static readonly "OFF": $ItemAtomicDisassembler$DisassemblerMode


public static "values"(): ($ItemAtomicDisassembler$DisassemblerMode)[]
public static "valueOf"(name: string): $ItemAtomicDisassembler$DisassemblerMode
public "color"(): $EnumColor
public "isEnabled"(): boolean
public "icon"(): $ResourceLocation
public "sliceName"(): $Component
public "getEfficiency"(): integer
public "getTextComponent"(): $Component
public static "byIndexStatic"(index: integer): $ItemAtomicDisassembler$DisassemblerMode
public "adjust"(arg0: integer): $ItemAtomicDisassembler$DisassemblerMode
public "getNext"(arg0: $Predicate$Type<($ItemAtomicDisassembler$DisassemblerMode$Type)>): $ItemAtomicDisassembler$DisassemblerMode
public "getPrevious"(arg0: $Predicate$Type<($ItemAtomicDisassembler$DisassemblerMode$Type)>): $ItemAtomicDisassembler$DisassemblerMode
public "adjust"(arg0: integer, arg1: $Predicate$Type<($ItemAtomicDisassembler$DisassemblerMode$Type)>): $ItemAtomicDisassembler$DisassemblerMode
public "getNext"(): $ItemAtomicDisassembler$DisassemblerMode
public "getPrevious"(): $ItemAtomicDisassembler$DisassemblerMode
get "enabled"(): boolean
get "efficiency"(): integer
get "textComponent"(): $Component
get "next"(): $ItemAtomicDisassembler$DisassemblerMode
get "previous"(): $ItemAtomicDisassembler$DisassemblerMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemAtomicDisassembler$DisassemblerMode$Type = (("normal") | ("fast") | ("vein") | ("slow") | ("off")) | ($ItemAtomicDisassembler$DisassemblerMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemAtomicDisassembler$DisassemblerMode_ = $ItemAtomicDisassembler$DisassemblerMode$Type;
}}
declare module "packages/mekanism/common/item/interfaces/$IColoredItem" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnumColor, $EnumColor$Type} from "packages/mekanism/api/text/$EnumColor"

export interface $IColoredItem {

 "setColor"(stack: $ItemStack$Type, color: $EnumColor$Type): void
 "getColor"(stack: $ItemStack$Type): $EnumColor
}

export namespace $IColoredItem {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IColoredItem$Type = ($IColoredItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IColoredItem_ = $IColoredItem$Type;
}}
declare module "packages/mekanism/common/tier/$InductionProviderTier" {
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"
import {$CachedFloatingLongValue, $CachedFloatingLongValue$Type} from "packages/mekanism/common/config/value/$CachedFloatingLongValue"

export class $InductionProviderTier extends $Enum<($InductionProviderTier)> implements $ITier {
static readonly "BASIC": $InductionProviderTier
static readonly "ADVANCED": $InductionProviderTier
static readonly "ELITE": $InductionProviderTier
static readonly "ULTIMATE": $InductionProviderTier


public static "values"(): ($InductionProviderTier)[]
public static "valueOf"(name: string): $InductionProviderTier
public "getOutput"(): $FloatingLong
public "getBaseTier"(): $BaseTier
public "getBaseOutput"(): $FloatingLong
public "setConfigReference"(outputReference: $CachedFloatingLongValue$Type): void
get "output"(): $FloatingLong
get "baseTier"(): $BaseTier
get "baseOutput"(): $FloatingLong
set "configReference"(value: $CachedFloatingLongValue$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InductionProviderTier$Type = (("elite") | ("advanced") | ("ultimate") | ("basic")) | ($InductionProviderTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InductionProviderTier_ = $InductionProviderTier$Type;
}}
declare module "packages/mekanism/common/registration/impl/$RecipeTypeDeferredRegister" {
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$IMekanismRecipeTypeProvider, $IMekanismRecipeTypeProvider$Type} from "packages/mekanism/common/recipe/$IMekanismRecipeTypeProvider"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$IInputRecipeCache, $IInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$IInputRecipeCache"
import {$WrappedDeferredRegister, $WrappedDeferredRegister$Type} from "packages/mekanism/common/registration/$WrappedDeferredRegister"
import {$RecipeTypeRegistryObject, $RecipeTypeRegistryObject$Type} from "packages/mekanism/common/registration/impl/$RecipeTypeRegistryObject"

export class $RecipeTypeDeferredRegister extends $WrappedDeferredRegister<($RecipeType<(any)>)> {

constructor(modid: string)

public "register"<RECIPE extends $MekanismRecipe, INPUT_CACHE extends $IInputRecipeCache>(name: string, sup: $Supplier$Type<(any)>): $RecipeTypeRegistryObject<(RECIPE), (INPUT_CACHE)>
public "getAllRecipeTypes"(): $List<($IMekanismRecipeTypeProvider<(any), (any)>)>
get "allRecipeTypes"(): $List<($IMekanismRecipeTypeProvider<(any), (any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeTypeDeferredRegister$Type = ($RecipeTypeDeferredRegister);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeTypeDeferredRegister_ = $RecipeTypeDeferredRegister$Type;
}}
declare module "packages/mekanism/common/content/network/transmitter/$UniversalCable" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IUpgradeableTransmitter, $IUpgradeableTransmitter$Type} from "packages/mekanism/common/content/network/transmitter/$IUpgradeableTransmitter"
import {$BufferedTransmitter, $BufferedTransmitter$Type} from "packages/mekanism/common/content/network/transmitter/$BufferedTransmitter"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$UniversalCableUpgradeData, $UniversalCableUpgradeData$Type} from "packages/mekanism/common/upgrade/transmitter/$UniversalCableUpgradeData"
import {$EnergyNetwork, $EnergyNetwork$Type} from "packages/mekanism/common/content/network/$EnergyNetwork"
import {$IMekanismStrictEnergyHandler, $IMekanismStrictEnergyHandler$Type} from "packages/mekanism/api/energy/$IMekanismStrictEnergyHandler"
import {$IEnergyContainer, $IEnergyContainer$Type} from "packages/mekanism/api/energy/$IEnergyContainer"
import {$TransmitterUpgradeData, $TransmitterUpgradeData$Type} from "packages/mekanism/common/upgrade/transmitter/$TransmitterUpgradeData"
import {$BasicEnergyContainer, $BasicEnergyContainer$Type} from "packages/mekanism/common/capabilities/energy/$BasicEnergyContainer"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$IStrictEnergyHandler, $IStrictEnergyHandler$Type} from "packages/mekanism/api/energy/$IStrictEnergyHandler"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$CableTier, $CableTier$Type} from "packages/mekanism/common/tier/$CableTier"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$AlloyTier, $AlloyTier$Type} from "packages/mekanism/api/tier/$AlloyTier"

export class $UniversalCable extends $BufferedTransmitter<($IStrictEnergyHandler), ($EnergyNetwork), ($FloatingLong), ($UniversalCable)> implements $IMekanismStrictEnergyHandler, $IUpgradeableTransmitter<($UniversalCableUpgradeData)> {
readonly "tier": $CableTier
readonly "buffer": $BasicEnergyContainer
 "lastWrite": $FloatingLong
 "currentTransmitterConnections": byte

constructor(blockProvider: $IBlockProvider$Type, tile: $TileEntityTransmitter$Type)

public "write"(nbtTags: $CompoundTag$Type): $CompoundTag
public "read"(nbtTags: $CompoundTag$Type): void
public "getCapacity"(): long
public "onContentsChanged"(): void
public "getTier"(): $CableTier
public "getUpgradeData"(): $UniversalCableUpgradeData
public "getShare"(): $FloatingLong
public "getEnergyContainers"(side: $Direction$Type): $List<($IEnergyContainer)>
public "parseUpgradeData"(data: $UniversalCableUpgradeData$Type): void
public "takeShare"(): void
public "releaseShare"(): $FloatingLong
public "getCapacityAsFloatingLong"(): $FloatingLong
public "createEmptyNetworkWithID"(networkID: $UUID$Type): $EnergyNetwork
public "createNetworkByMerging"(networks: $Collection$Type<($EnergyNetwork$Type)>): $EnergyNetwork
public "dataTypeMatches"(data: $TransmitterUpgradeData$Type): boolean
public "isValidAcceptor"(tile: $BlockEntity$Type, side: $Direction$Type): boolean
public "pullFromAcceptors"(): void
public "noBufferOrFallback"(): boolean
public "getEnergyContainer"(arg0: integer, arg1: $Direction$Type): $IEnergyContainer
public "getEnergyContainerCount"(arg0: $Direction$Type): integer
public "extractEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type, arg3: $Action$Type): $FloatingLong
public "getEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "setEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type): void
public "canHandleEnergy"(): boolean
public "getMaxEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "getNeededEnergy"(arg0: integer, arg1: $Direction$Type): $FloatingLong
public "insertEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Direction$Type, arg3: $Action$Type): $FloatingLong
public "canUpgrade"(alloyTier: $AlloyTier$Type): boolean
public "getEnergyContainerCount"(): integer
public "extractEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Action$Type): $FloatingLong
public "extractEnergy"(arg0: $FloatingLong$Type, arg1: $Direction$Type, arg2: $Action$Type): $FloatingLong
public "getEnergy"(arg0: integer): $FloatingLong
public "setEnergy"(arg0: integer, arg1: $FloatingLong$Type): void
public "getMaxEnergy"(arg0: integer): $FloatingLong
public "getNeededEnergy"(arg0: integer): $FloatingLong
public "insertEnergy"(arg0: integer, arg1: $FloatingLong$Type, arg2: $Action$Type): $FloatingLong
public "insertEnergy"(arg0: $FloatingLong$Type, arg1: $Direction$Type, arg2: $Action$Type): $FloatingLong
public "getEnergySideFor"(): $Direction
public "extractEnergy"(arg0: $FloatingLong$Type, arg1: $Action$Type): $FloatingLong
public "insertEnergy"(arg0: $FloatingLong$Type, arg1: $Action$Type): $FloatingLong
get "capacity"(): long
get "tier"(): $CableTier
get "upgradeData"(): $UniversalCableUpgradeData
get "share"(): $FloatingLong
get "capacityAsFloatingLong"(): $FloatingLong
get "energyContainerCount"(): integer
get "energySideFor"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UniversalCable$Type = ($UniversalCable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UniversalCable_ = $UniversalCable$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$SawmillRecipeSerializer" {
import {$SawmillRecipe, $SawmillRecipe$Type} from "packages/mekanism/api/recipes/$SawmillRecipe"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$SawmillRecipeSerializer$IFactory, $SawmillRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$SawmillRecipeSerializer$IFactory"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $SawmillRecipeSerializer<RECIPE extends $SawmillRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(factory: $SawmillRecipeSerializer$IFactory$Type<(RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SawmillRecipeSerializer$Type<RECIPE> = ($SawmillRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SawmillRecipeSerializer_<RECIPE> = $SawmillRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/type/$ItemInputCache" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$HashedItem, $HashedItem$Type} from "packages/mekanism/common/lib/inventory/$HashedItem"
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$NBTSensitiveInputCache, $NBTSensitiveInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$NBTSensitiveInputCache"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ItemInputCache<RECIPE extends $MekanismRecipe> extends $NBTSensitiveInputCache<($Item), ($HashedItem), ($ItemStack), ($ItemStackIngredient), (RECIPE)> {

constructor()

public "isEmpty"(input: $ItemStack$Type): boolean
public "mapInputs"(recipe: RECIPE, inputIngredient: $ItemStackIngredient$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemInputCache$Type<RECIPE> = ($ItemInputCache<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemInputCache_<RECIPE> = $ItemInputCache$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/content/network/transmitter/$MechanicalPipe" {
import {$IFluidHandler, $IFluidHandler$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$AcceptorCache, $AcceptorCache$Type} from "packages/mekanism/common/lib/transmitter/acceptor/$AcceptorCache"
import {$BasicFluidTank, $BasicFluidTank$Type} from "packages/mekanism/common/capabilities/fluid/$BasicFluidTank"
import {$CompatibleTransmitterValidator, $CompatibleTransmitterValidator$Type} from "packages/mekanism/common/lib/transmitter/$CompatibleTransmitterValidator"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IUpgradeableTransmitter, $IUpgradeableTransmitter$Type} from "packages/mekanism/common/content/network/transmitter/$IUpgradeableTransmitter"
import {$BufferedTransmitter, $BufferedTransmitter$Type} from "packages/mekanism/common/content/network/transmitter/$BufferedTransmitter"
import {$FluidNetwork, $FluidNetwork$Type} from "packages/mekanism/common/content/network/$FluidNetwork"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$Type} from "packages/net/minecraftforge/fluids/capability/$IFluidHandler$FluidAction"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$TransmitterUpgradeData, $TransmitterUpgradeData$Type} from "packages/mekanism/common/upgrade/transmitter/$TransmitterUpgradeData"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IMekanismFluidHandler, $IMekanismFluidHandler$Type} from "packages/mekanism/api/fluid/$IMekanismFluidHandler"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$PipeTier, $PipeTier$Type} from "packages/mekanism/common/tier/$PipeTier"
import {$MechanicalPipeUpgradeData, $MechanicalPipeUpgradeData$Type} from "packages/mekanism/common/upgrade/transmitter/$MechanicalPipeUpgradeData"
import {$AlloyTier, $AlloyTier$Type} from "packages/mekanism/api/tier/$AlloyTier"
import {$IExtendedFluidTank, $IExtendedFluidTank$Type} from "packages/mekanism/api/fluid/$IExtendedFluidTank"

export class $MechanicalPipe extends $BufferedTransmitter<($IFluidHandler), ($FluidNetwork), ($FluidStack), ($MechanicalPipe)> implements $IMekanismFluidHandler, $IUpgradeableTransmitter<($MechanicalPipeUpgradeData)> {
readonly "tier": $PipeTier
 "saveShare": $FluidStack
readonly "buffer": $BasicFluidTank
 "currentTransmitterConnections": byte

constructor(blockProvider: $IBlockProvider$Type, tile: $TileEntityTransmitter$Type)

public "write"(nbtTags: $CompoundTag$Type): $CompoundTag
public "read"(nbtTags: $CompoundTag$Type): void
public "getCapacity"(): long
public "onContentsChanged"(): void
public "getTier"(): $PipeTier
public "getUpgradeData"(): $MechanicalPipeUpgradeData
public "getShare"(): $FluidStack
public "parseUpgradeData"(data: $MechanicalPipeUpgradeData$Type): void
public "takeShare"(): void
public "releaseShare"(): $FluidStack
public "getFluidTanks"(side: $Direction$Type): $List<($IExtendedFluidTank)>
public "getNewOrphanValidator"(): $CompatibleTransmitterValidator<($IFluidHandler), ($FluidNetwork), ($MechanicalPipe)>
public "dataTypeMatches"(data: $TransmitterUpgradeData$Type): boolean
public "getAcceptorCache"(): $AcceptorCache<($IFluidHandler)>
public "isValidTransmitter"(transmitter: $TileEntityTransmitter$Type, side: $Direction$Type): boolean
public "isValidAcceptor"(tile: $BlockEntity$Type, side: $Direction$Type): boolean
public "pullFromAcceptors"(): void
public "noBufferOrFallback"(): boolean
public "takeFluid"(fluid: $FluidStack$Type, action: $Action$Type): $FluidStack
public "getTanks"(arg0: $Direction$Type): integer
public "getTankCapacity"(arg0: integer, arg1: $Direction$Type): integer
public "getFluidInTank"(arg0: integer, arg1: $Direction$Type): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type): boolean
public "getFluidTank"(arg0: integer, arg1: $Direction$Type): $IExtendedFluidTank
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type): void
public "insertFluid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Direction$Type, arg3: $Action$Type): $FluidStack
public "canHandleFluid"(): boolean
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Direction$Type, arg3: $Action$Type): $FluidStack
public "canUpgrade"(alloyTier: $AlloyTier$Type): boolean
public "getTanks"(): integer
public "getTankCapacity"(arg0: integer): integer
public "getFluidInTank"(arg0: integer): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$Type): void
public "insertFluid"(arg0: integer, arg1: $FluidStack$Type, arg2: $Action$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$Type, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "getFluidSideFor"(): $Direction
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Action$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$Type, arg1: $Direction$Type, arg2: $Action$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "fill"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): integer
/**
 * 
 * @deprecated
 */
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "drain"(arg0: $FluidStack$Type, arg1: $IFluidHandler$FluidAction$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$Type, arg1: $Action$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Action$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$Type, arg1: $Action$Type): $FluidStack
get "capacity"(): long
get "tier"(): $PipeTier
get "upgradeData"(): $MechanicalPipeUpgradeData
get "share"(): $FluidStack
get "newOrphanValidator"(): $CompatibleTransmitterValidator<($IFluidHandler), ($FluidNetwork), ($MechanicalPipe)>
get "acceptorCache"(): $AcceptorCache<($IFluidHandler)>
get "tanks"(): integer
get "fluidSideFor"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalPipe$Type = ($MechanicalPipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MechanicalPipe_ = $MechanicalPipe$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/chemical/$IInfusionTile" {
import {$InfuseType, $InfuseType$Type} from "packages/mekanism/api/chemical/infuse/$InfuseType"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IInfusionTracker, $IInfusionTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IInfusionTracker"
import {$IContentsListener, $IContentsListener$Type} from "packages/mekanism/api/$IContentsListener"
import {$InfusionStack, $InfusionStack$Type} from "packages/mekanism/api/chemical/infuse/$InfusionStack"
import {$IInfusionTank, $IInfusionTank$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionTank"
import {$IChemicalTankHolder, $IChemicalTankHolder$Type} from "packages/mekanism/common/capabilities/holder/chemical/$IChemicalTankHolder"
import {$ChemicalHandlerManager$InfusionHandlerManager, $ChemicalHandlerManager$InfusionHandlerManager$Type} from "packages/mekanism/common/capabilities/resolver/manager/$ChemicalHandlerManager$InfusionHandlerManager"

export interface $IInfusionTile extends $IInfusionTracker {

 "getInitialInfusionManager"(listener: $IContentsListener$Type): $ChemicalHandlerManager$InfusionHandlerManager
 "extractInfusionCheck"(tank: integer, side: $Direction$Type): boolean
 "insertInfusionCheck"(tank: integer, side: $Direction$Type): boolean
 "getInitialInfusionTanks"(listener: $IContentsListener$Type): $IChemicalTankHolder<($InfuseType), ($InfusionStack), ($IInfusionTank)>
 "getInfusionManager"(): $ChemicalHandlerManager$InfusionHandlerManager
 "getInfusionTanks"(side: $Direction$Type): $List<($IInfusionTank)>
 "canHandleInfusion"(): boolean
 "onContentsChanged"(): void
}

export namespace $IInfusionTile {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInfusionTile$Type = ($IInfusionTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInfusionTile_ = $IInfusionTile$Type;
}}
declare module "packages/mekanism/common/config/value/$CachedResolvableConfigValue" {
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$CachedValue, $CachedValue$Type} from "packages/mekanism/common/config/value/$CachedValue"

export class $CachedResolvableConfigValue<TYPE, REAL> extends $CachedValue<(REAL)> implements $Supplier<(TYPE)> {


public "get"(): TYPE
public "set"(value: TYPE): void
public "getOrDefault"(): TYPE
get "orDefault"(): TYPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedResolvableConfigValue$Type<TYPE, REAL> = ($CachedResolvableConfigValue<(TYPE), (REAL)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedResolvableConfigValue_<TYPE, REAL> = $CachedResolvableConfigValue$Type<(TYPE), (REAL)>;
}}
declare module "packages/mekanism/common/content/gear/$Module" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$Type} from "packages/mekanism/common/item/interfaces/$IModeItem$DisplayChange"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$FloatingLongSupplier, $FloatingLongSupplier$Type} from "packages/mekanism/api/math/$FloatingLongSupplier"
import {$IHasTextComponent, $IHasTextComponent$Type} from "packages/mekanism/api/text/$IHasTextComponent"
import {$IModule, $IModule$Type} from "packages/mekanism/api/gear/$IModule"
import {$IHUDElement, $IHUDElement$Type} from "packages/mekanism/api/gear/$IHUDElement"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$ICustomModule, $ICustomModule$Type} from "packages/mekanism/api/gear/$ICustomModule"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$IEnergyContainer, $IEnergyContainer$Type} from "packages/mekanism/api/energy/$IEnergyContainer"
import {$ModuleData, $ModuleData$Type} from "packages/mekanism/api/gear/$ModuleData"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$NestedRadialMode, $NestedRadialMode$Type} from "packages/mekanism/api/radial/mode/$NestedRadialMode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IRadialMode, $IRadialMode$Type} from "packages/mekanism/api/radial/mode/$IRadialMode"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$RadialData, $RadialData$Type} from "packages/mekanism/api/radial/$RadialData"
import {$ModuleConfigItem, $ModuleConfigItem$Type} from "packages/mekanism/common/content/gear/$ModuleConfigItem"

export class $Module<MODULE extends $ICustomModule<(MODULE)>> implements $IModule<(MODULE)> {
static readonly "ENABLED_KEY": string

constructor(data: $ModuleData$Type<(MODULE)>, container: $ItemStack$Type)

public "init"(): void
public "read"(nbt: $CompoundTag$Type): void
public "save"(callback: $Runnable$Type): void
public "getData"(): $ModuleData<(MODULE)>
public "setMode"<M extends $IRadialMode>(player: $Player$Type, stack: $ItemStack$Type, radialData: $RadialData$Type<(M)>, mode: M): boolean
public "getMode"<M extends $IRadialMode>(stack: $ItemStack$Type, radialData: $RadialData$Type<(M)>): M
public "isEnabled"(): boolean
public "setInstalledCount"(installed: integer): void
public "renderHUD"(): boolean
public "getEnergyContainer"(): $IEnergyContainer
public "getContainer"(): $ItemStack
public "handlesModeChange"(): boolean
public "tick"(player: $Player$Type): void
public "displayModeChange"(player: $Player$Type, modeName: $Component$Type, mode: $IHasTextComponent$Type): void
public "onAdded"(first: boolean): void
public "getContainerEnergy"(): $FloatingLong
public "toggleEnabled"(player: $Player$Type, modeName: $Component$Type): void
public "hasEnoughEnergy"(cost: $FloatingLong$Type): boolean
public "hasEnoughEnergy"(energySupplier: $FloatingLongSupplier$Type): boolean
public "getModeScrollComponent"(stack: $ItemStack$Type): $Component
public "getInstalledCount"(): integer
public "onRemoved"(last: boolean): void
public "addRadialModes"(stack: $ItemStack$Type, adder: $Consumer$Type<($NestedRadialMode$Type)>): void
public "addHUDElements"(player: $Player$Type, list: $List$Type<($IHUDElement$Type)>): void
public "getCustomInstance"(): MODULE
public "canUseEnergy"(wearer: $LivingEntity$Type, energyContainer: $IEnergyContainer$Type, energy: $FloatingLong$Type, ignoreCreative: boolean): boolean
public "canUseEnergy"(wearer: $LivingEntity$Type, energy: $FloatingLong$Type): boolean
public "canUseEnergy"(wearer: $LivingEntity$Type, energy: $FloatingLong$Type, ignoreCreative: boolean): boolean
public "useEnergy"(wearer: $LivingEntity$Type, energy: $FloatingLong$Type): $FloatingLong
public "useEnergy"(wearer: $LivingEntity$Type, energy: $FloatingLong$Type, freeCreative: boolean): $FloatingLong
public "useEnergy"(wearer: $LivingEntity$Type, energyContainer: $IEnergyContainer$Type, energy: $FloatingLong$Type, freeCreative: boolean): $FloatingLong
public "addHUDStrings"(player: $Player$Type, list: $List$Type<($Component$Type)>): void
public "changeMode"(player: $Player$Type, stack: $ItemStack$Type, shift: integer, displayChange: $IModeItem$DisplayChange$Type): void
public "handlesAnyModeChange"(): boolean
public "handlesRadialModeChange"(): boolean
public "getConfigItems"(): $List<($ModuleConfigItem<(any)>)>
public "setDisabledForce"(hasCallback: boolean): void
public "setModeHandlingDisabledForce"(): void
get "data"(): $ModuleData<(MODULE)>
get "enabled"(): boolean
set "installedCount"(value: integer)
get "energyContainer"(): $IEnergyContainer
get "container"(): $ItemStack
get "containerEnergy"(): $FloatingLong
get "installedCount"(): integer
get "customInstance"(): MODULE
get "configItems"(): $List<($ModuleConfigItem<(any)>)>
set "disabledForce"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Module$Type<MODULE> = ($Module<(MODULE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Module_<MODULE> = $Module$Type<(MODULE)>;
}}
declare module "packages/mekanism/common/recipe/serializer/$ItemStackToEnergyRecipeSerializer$IFactory" {
import {$ItemStackToEnergyRecipe, $ItemStackToEnergyRecipe$Type} from "packages/mekanism/api/recipes/$ItemStackToEnergyRecipe"
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"

export interface $ItemStackToEnergyRecipeSerializer$IFactory<RECIPE extends $ItemStackToEnergyRecipe> {

 "create"(id: $ResourceLocation$Type, input: $ItemStackIngredient$Type, output: $FloatingLong$Type): RECIPE

(id: $ResourceLocation$Type, input: $ItemStackIngredient$Type, output: $FloatingLong$Type): RECIPE
}

export namespace $ItemStackToEnergyRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackToEnergyRecipeSerializer$IFactory$Type<RECIPE> = ($ItemStackToEnergyRecipeSerializer$IFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackToEnergyRecipeSerializer$IFactory_<RECIPE> = $ItemStackToEnergyRecipeSerializer$IFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$RotaryInputRecipeCache" {
import {$GasStack, $GasStack$Type} from "packages/mekanism/api/chemical/gas/$GasStack"
import {$AbstractInputRecipeCache, $AbstractInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$AbstractInputRecipeCache"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$MekanismRecipeType, $MekanismRecipeType$Type} from "packages/mekanism/common/recipe/$MekanismRecipeType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$RotaryRecipe, $RotaryRecipe$Type} from "packages/mekanism/api/recipes/$RotaryRecipe"

export class $RotaryInputRecipeCache extends $AbstractInputRecipeCache<($RotaryRecipe)> {

constructor(recipeType: $MekanismRecipeType$Type<($RotaryRecipe$Type), (any)>)

public "clear"(): void
public "findFirstRecipe"(world: $Level$Type, input: $GasStack$Type): $RotaryRecipe
public "findFirstRecipe"(world: $Level$Type, input: $FluidStack$Type): $RotaryRecipe
public "containsInput"(world: $Level$Type, input: $GasStack$Type): boolean
public "containsInput"(world: $Level$Type, input: $FluidStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotaryInputRecipeCache$Type = ($RotaryInputRecipeCache);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RotaryInputRecipeCache_ = $RotaryInputRecipeCache$Type;
}}
declare module "packages/mekanism/common/capabilities/resolver/manager/$ICapabilityHandlerManager" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$ICapabilityResolver, $ICapabilityResolver$Type} from "packages/mekanism/common/capabilities/resolver/$ICapabilityResolver"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export interface $ICapabilityHandlerManager<CONTAINER> extends $ICapabilityResolver {

 "canHandle"(): boolean
 "getContainers"(side: $Direction$Type): $List<(CONTAINER)>
 "resolve"<T>(capability: $Capability$Type<(T)>, side: $Direction$Type): $LazyOptional<(T)>
 "invalidate"(capability: $Capability$Type<(any)>, side: $Direction$Type): void
 "invalidateAll"(): void
 "getSupportedCapabilities"(): $List<($Capability<(any)>)>
}

export namespace $ICapabilityHandlerManager {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICapabilityHandlerManager$Type<CONTAINER> = ($ICapabilityHandlerManager<(CONTAINER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICapabilityHandlerManager_<CONTAINER> = $ICapabilityHandlerManager$Type<(CONTAINER)>;
}}
declare module "packages/mekanism/common/config/value/$CachedFloatingLongValue" {
import {$FloatingLongSupplier, $FloatingLongSupplier$Type} from "packages/mekanism/api/math/$FloatingLongSupplier"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IMekanismConfig, $IMekanismConfig$Type} from "packages/mekanism/common/config/$IMekanismConfig"
import {$ForgeConfigSpec$Builder, $ForgeConfigSpec$Builder$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$Builder"
import {$FloatingLong, $FloatingLong$Type} from "packages/mekanism/api/math/$FloatingLong"
import {$CachedResolvableConfigValue, $CachedResolvableConfigValue$Type} from "packages/mekanism/common/config/value/$CachedResolvableConfigValue"

export class $CachedFloatingLongValue extends $CachedResolvableConfigValue<($FloatingLong), (string)> implements $FloatingLongSupplier {
static readonly "POSITIVE": $Predicate<(any)>
static readonly "ENERGY_CONVERSION": $Predicate<(any)>


public static "define"(config: $IMekanismConfig$Type, builder: $ForgeConfigSpec$Builder$Type, comment: string, path: string, defaultValue: $FloatingLong$Type): $CachedFloatingLongValue
public static "define"(config: $IMekanismConfig$Type, builder: $ForgeConfigSpec$Builder$Type, comment: string, path: string, defaultValue: $FloatingLong$Type, validator: $Predicate$Type<(any)>): $CachedFloatingLongValue
public static "define"(config: $IMekanismConfig$Type, builder: $ForgeConfigSpec$Builder$Type, comment: string, path: string, defaultValue: $FloatingLong$Type, worldRestart: boolean, validator: $Predicate$Type<(any)>): $CachedFloatingLongValue
public static "define"(config: $IMekanismConfig$Type, builder: $ForgeConfigSpec$Builder$Type, comment: string, path: string, defaultValue: $FloatingLong$Type, worldRestart: boolean): $CachedFloatingLongValue
public static "greaterZeroLessThan"(max: $FloatingLong$Type): $Predicate<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedFloatingLongValue$Type = ($CachedFloatingLongValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedFloatingLongValue_ = $CachedFloatingLongValue$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$ChemicalCrystallizerRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ChemicalCrystallizerRecipe, $ChemicalCrystallizerRecipe$Type} from "packages/mekanism/api/recipes/$ChemicalCrystallizerRecipe"
import {$ChemicalCrystallizerRecipeSerializer$IFactory, $ChemicalCrystallizerRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$ChemicalCrystallizerRecipeSerializer$IFactory"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ChemicalCrystallizerRecipeSerializer<RECIPE extends $ChemicalCrystallizerRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(factory: $ChemicalCrystallizerRecipeSerializer$IFactory$Type<(RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalCrystallizerRecipeSerializer$Type<RECIPE> = ($ChemicalCrystallizerRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalCrystallizerRecipeSerializer_<RECIPE> = $ChemicalCrystallizerRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/content/filter/$FilterManager" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$IFilter, $IFilter$Type} from "packages/mekanism/common/content/filter/$IFilter"

export class $FilterManager<FILTER extends $IFilter<(any)>> {

constructor(filterClass: $Class$Type<(any)>, markForSave: $Runnable$Type)

public "count"(): integer
public "addContainerTrackers"(container: $MekanismContainer$Type): void
public "addFilter"(filter: FILTER): boolean
public "removeFilter"(filter: FILTER): boolean
public "getFilters"(): $List<(FILTER)>
public "getEnabledFilters"(): $List<(FILTER)>
public "anyEnabledMatch"(validator: $Predicate$Type<(FILTER)>): boolean
public "writeToNBT"(nbt: $CompoundTag$Type): void
public "readFromNBT"(nbt: $CompoundTag$Type): void
public "tryAddFilter"(toAdd: $IFilter$Type<(any)>, save: boolean): void
public "toggleState"(index: integer): void
public "tryEditFilter"<F extends $IFilter<(F)>>(currentFilter: F, newFilter: F): void
public "hasEnabledFilters"(): boolean
get "filters"(): $List<(FILTER)>
get "enabledFilters"(): $List<(FILTER)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterManager$Type<FILTER> = ($FilterManager<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterManager_<FILTER> = $FilterManager$Type<(FILTER)>;
}}
declare module "packages/mekanism/common/registration/$DoubleWrappedRegistryObject" {
import {$INamedEntry, $INamedEntry$Type} from "packages/mekanism/common/registration/$INamedEntry"
import {$RegistryObject, $RegistryObject$Type} from "packages/net/minecraftforge/registries/$RegistryObject"

export class $DoubleWrappedRegistryObject<PRIMARY, SECONDARY> implements $INamedEntry {

constructor(primaryRO: $RegistryObject$Type<(PRIMARY)>, secondaryRO: $RegistryObject$Type<(SECONDARY)>)

public "getPrimary"(): PRIMARY
public "getSecondary"(): SECONDARY
public "getInternalRegistryName"(): string
get "primary"(): PRIMARY
get "secondary"(): SECONDARY
get "internalRegistryName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleWrappedRegistryObject$Type<PRIMARY, SECONDARY> = ($DoubleWrappedRegistryObject<(PRIMARY), (SECONDARY)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleWrappedRegistryObject_<PRIMARY, SECONDARY> = $DoubleWrappedRegistryObject$Type<(PRIMARY), (SECONDARY)>;
}}
declare module "packages/mekanism/common/lib/math/voxel/$IShape" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IShape {

}

export namespace $IShape {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IShape$Type = ($IShape);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IShape_ = $IShape$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$SingleInputRecipeCache" {
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$AbstractInputRecipeCache, $AbstractInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$AbstractInputRecipeCache"
import {$InputIngredient, $InputIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$InputIngredient"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IInputCache, $IInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$IInputCache"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"

export class $SingleInputRecipeCache<INPUT, INGREDIENT extends $InputIngredient<(INPUT)>, RECIPE extends ($MekanismRecipe) & ($Predicate<(INPUT)>), CACHE extends $IInputCache<(INPUT), (INGREDIENT), (RECIPE)>> extends $AbstractInputRecipeCache<(RECIPE)> {


public "clear"(): void
public "findTypeBasedRecipe"(world: $Level$Type, input: INPUT, matchCriteria: $Predicate$Type<(RECIPE)>): RECIPE
public "findTypeBasedRecipe"(world: $Level$Type, input: INPUT): RECIPE
public "findFirstRecipe"(world: $Level$Type, input: INPUT): RECIPE
public "containsInput"(world: $Level$Type, input: INPUT): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SingleInputRecipeCache$Type<INPUT, INGREDIENT, RECIPE, CACHE> = ($SingleInputRecipeCache<(INPUT), (INGREDIENT), (RECIPE), (CACHE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SingleInputRecipeCache_<INPUT, INGREDIENT, RECIPE, CACHE> = $SingleInputRecipeCache$Type<(INPUT), (INGREDIENT), (RECIPE), (CACHE)>;
}}
declare module "packages/mekanism/common/block/$BlockPersonalChest" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Attribute, $Attribute$Type} from "packages/mekanism/common/block/attribute/$Attribute"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$IStateFluidLoggable, $IStateFluidLoggable$Type} from "packages/mekanism/common/block/states/$IStateFluidLoggable"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockPersonalStorage, $BlockPersonalStorage$Type} from "packages/mekanism/common/block/$BlockPersonalStorage"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$TileEntityPersonalChest, $TileEntityPersonalChest$Type} from "packages/mekanism/common/tile/$TileEntityPersonalChest"

export class $BlockPersonalChest extends $BlockPersonalStorage<($TileEntityPersonalChest), ($BlockTypeTile<($TileEntityPersonalChest)>)> implements $IStateFluidLoggable {
static readonly "PERSONAL_STORAGE_INVENTORY": $Attribute
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor()

/**
 * 
 * @deprecated
 */
public "tick"(state: $BlockState$Type, level: $ServerLevel$Type, pos: $BlockPos$Type, random: $RandomSource$Type): void
public "setState"(state: $BlockState$Type, fluid: $Fluid$Type): $BlockState
public "getFluidLightLevel"(state: $BlockState$Type): integer
public "getFluid"(state: $BlockState$Type): $FluidState
public "canPlaceLiquid"(world: $BlockGetter$Type, pos: $BlockPos$Type, state: $BlockState$Type, fluid: $Fluid$Type): boolean
public "pickupBlock"(world: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type): $ItemStack
public "getPickupSound"(state: $BlockState$Type): $Optional<($SoundEvent)>
public "placeLiquid"(world: $LevelAccessor$Type, pos: $BlockPos$Type, state: $BlockState$Type, fluidState: $FluidState$Type): boolean
public "getPickupSound"(): $Optional<($SoundEvent)>
public "getFluidLoggedProperty"(): $EnumProperty<(any)>
public "isValidFluid"(fluid: $Fluid$Type): boolean
public "updateFluids"(state: $BlockState$Type, world: $LevelAccessor$Type, currentPos: $BlockPos$Type): void
get "pickupSound"(): $Optional<($SoundEvent)>
get "fluidLoggedProperty"(): $EnumProperty<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPersonalChest$Type = ($BlockPersonalChest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPersonalChest_ = $BlockPersonalChest$Type;
}}
declare module "packages/mekanism/common/inventory/$GuiComponents$IToggleEnum" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $GuiComponents$IToggleEnum<TYPE extends ($Enum<(TYPE)>) & ($GuiComponents$IToggleEnum<(TYPE)>)> {

 "getIcon"(): $ResourceLocation
 "getTooltip"(): $Component
}

export namespace $GuiComponents$IToggleEnum {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiComponents$IToggleEnum$Type<TYPE> = ($GuiComponents$IToggleEnum<(TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiComponents$IToggleEnum_<TYPE> = $GuiComponents$IToggleEnum$Type<(TYPE)>;
}}
declare module "packages/mekanism/common/block/basic/$BlockChargepad" {
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$Type} from "packages/mekanism/common/block/prefab/$BlockTile$BlockTileModel"
import {$TileEntityChargepad, $TileEntityChargepad$Type} from "packages/mekanism/common/tile/$TileEntityChargepad"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockChargepad extends $BlockTile$BlockTileModel<($TileEntityChargepad), ($BlockTypeTile<($TileEntityChargepad)>)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor()

/**
 * 
 * @deprecated
 */
public "getCollisionShape"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockChargepad$Type = ($BlockChargepad);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockChargepad_ = $BlockChargepad$Type;
}}
declare module "packages/mekanism/common/item/gear/$ItemFreeRunners$FreeRunnerMode" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IIncrementalEnum, $IIncrementalEnum$Type} from "packages/mekanism/api/$IIncrementalEnum"
import {$IHasTextComponent, $IHasTextComponent$Type} from "packages/mekanism/api/text/$IHasTextComponent"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export class $ItemFreeRunners$FreeRunnerMode extends $Enum<($ItemFreeRunners$FreeRunnerMode)> implements $IIncrementalEnum<($ItemFreeRunners$FreeRunnerMode)>, $IHasTextComponent {
static readonly "NORMAL": $ItemFreeRunners$FreeRunnerMode
static readonly "SAFETY": $ItemFreeRunners$FreeRunnerMode
static readonly "DISABLED": $ItemFreeRunners$FreeRunnerMode


public static "values"(): ($ItemFreeRunners$FreeRunnerMode)[]
public static "valueOf"(name: string): $ItemFreeRunners$FreeRunnerMode
public "providesStepBoost"(): boolean
public "preventsFallDamage"(): boolean
public "getTextComponent"(): $Component
public static "byIndexStatic"(index: integer): $ItemFreeRunners$FreeRunnerMode
public "ordinal"(): integer
public "adjust"(arg0: integer): $ItemFreeRunners$FreeRunnerMode
public "adjust"(arg0: integer, arg1: $Predicate$Type<($ItemFreeRunners$FreeRunnerMode$Type)>): $ItemFreeRunners$FreeRunnerMode
public "getNext"(arg0: $Predicate$Type<($ItemFreeRunners$FreeRunnerMode$Type)>): $ItemFreeRunners$FreeRunnerMode
public "getNext"(): $ItemFreeRunners$FreeRunnerMode
public "getPrevious"(): $ItemFreeRunners$FreeRunnerMode
public "getPrevious"(arg0: $Predicate$Type<($ItemFreeRunners$FreeRunnerMode$Type)>): $ItemFreeRunners$FreeRunnerMode
get "textComponent"(): $Component
get "next"(): $ItemFreeRunners$FreeRunnerMode
get "previous"(): $ItemFreeRunners$FreeRunnerMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFreeRunners$FreeRunnerMode$Type = (("normal") | ("safety") | ("disabled")) | ($ItemFreeRunners$FreeRunnerMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFreeRunners$FreeRunnerMode_ = $ItemFreeRunners$FreeRunnerMode$Type;
}}
declare module "packages/mekanism/common/item/block/transmitter/$ItemBlockThermodynamicConductor" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ItemBlockMekanism, $ItemBlockMekanism$Type} from "packages/mekanism/common/item/block/$ItemBlockMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$BlockThermodynamicConductor, $BlockThermodynamicConductor$Type} from "packages/mekanism/common/block/transmitter/$BlockThermodynamicConductor"

export class $ItemBlockThermodynamicConductor extends $ItemBlockMekanism<($BlockThermodynamicConductor)> {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockThermodynamicConductor$Type)

public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockThermodynamicConductor$Type = ($ItemBlockThermodynamicConductor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockThermodynamicConductor_ = $ItemBlockThermodynamicConductor$Type;
}}
declare module "packages/mekanism/common/lib/inventory/$HashedItem" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$IHashedItem, $IHashedItem$Type} from "packages/mekanism/api/inventory/$IHashedItem"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $HashedItem implements $IHashedItem {


public "equals"(obj: any): boolean
public "hashCode"(): integer
public static "create"(stack: $ItemStack$Type): $HashedItem
/**
 * 
 * @deprecated
 */
public "getStack"(): $ItemStack
public static "raw"(stack: $ItemStack$Type): $HashedItem
public "recreate"(): $HashedItem
public "createStack"(size: integer): $ItemStack
public "getInternalStack"(): $ItemStack
public "internalToNBT"(): $CompoundTag
public "getItem"(): $Item
public "getMaxStackSize"(): integer
public "getInternalTag"(): $CompoundTag
get "stack"(): $ItemStack
get "internalStack"(): $ItemStack
get "item"(): $Item
get "maxStackSize"(): integer
get "internalTag"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HashedItem$Type = ($HashedItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HashedItem_ = $HashedItem$Type;
}}
declare module "packages/mekanism/common/lib/transmitter/acceptor/$AbstractAcceptorInfo" {
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"

export class $AbstractAcceptorInfo {


public "getTile"(): $BlockEntity
get "tile"(): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractAcceptorInfo$Type = ($AbstractAcceptorInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractAcceptorInfo_ = $AbstractAcceptorInfo$Type;
}}
declare module "packages/mekanism/common/capabilities/resolver/$BasicSidedCapabilityResolver" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$BasicSidedCapabilityResolver$BasicProxyCreator, $BasicSidedCapabilityResolver$BasicProxyCreator$Type} from "packages/mekanism/common/capabilities/resolver/$BasicSidedCapabilityResolver$BasicProxyCreator"
import {$ICapabilityResolver, $ICapabilityResolver$Type} from "packages/mekanism/common/capabilities/resolver/$ICapabilityResolver"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export class $BasicSidedCapabilityResolver<HANDLER, SIDED_HANDLER extends HANDLER> implements $ICapabilityResolver {

constructor(baseHandler: SIDED_HANDLER, supportedCapability: $Capability$Type<(HANDLER)>, proxyCreator: $BasicSidedCapabilityResolver$BasicProxyCreator$Type<(HANDLER), (SIDED_HANDLER)>)

public "resolve"<T>(capability: $Capability$Type<(T)>, side: $Direction$Type): $LazyOptional<(T)>
public "invalidate"(capability: $Capability$Type<(any)>, side: $Direction$Type): void
public "getInternal"(): SIDED_HANDLER
public "invalidateAll"(): void
public "getSupportedCapabilities"(): $List<($Capability<(any)>)>
get "internal"(): SIDED_HANDLER
get "supportedCapabilities"(): $List<($Capability<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicSidedCapabilityResolver$Type<HANDLER, SIDED_HANDLER> = ($BasicSidedCapabilityResolver<(HANDLER), (SIDED_HANDLER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicSidedCapabilityResolver_<HANDLER, SIDED_HANDLER> = $BasicSidedCapabilityResolver$Type<(HANDLER), (SIDED_HANDLER)>;
}}
declare module "packages/mekanism/common/capabilities/$IOffsetCapability" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Vec3i, $Vec3i$Type} from "packages/net/minecraft/core/$Vec3i"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"

export interface $IOffsetCapability {

 "getOffsetCapability"<T>(capability: $Capability$Type<(T)>, side: $Direction$Type, offset: $Vec3i$Type): $LazyOptional<(T)>
 "isOffsetCapabilityDisabled"(capability: $Capability$Type<(any)>, side: $Direction$Type, offset: $Vec3i$Type): boolean
 "getOffsetCapabilityIfEnabled"<T>(capability: $Capability$Type<(T)>, side: $Direction$Type, offset: $Vec3i$Type): $LazyOptional<(T)>

(capability: $Capability$Type<(T)>, side: $Direction$Type, offset: $Vec3i$Type): $LazyOptional<(T)>
}

export namespace $IOffsetCapability {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IOffsetCapability$Type = ($IOffsetCapability);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IOffsetCapability_ = $IOffsetCapability$Type;
}}
declare module "packages/mekanism/common/lib/frequency/$IdentitySerializer" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$Type} from "packages/mekanism/common/lib/frequency/$Frequency$FrequencyIdentity"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"

export interface $IdentitySerializer {

 "load"(data: $CompoundTag$Type): $Frequency$FrequencyIdentity
 "write"(buf: $FriendlyByteBuf$Type, data: $Frequency$FrequencyIdentity$Type): void
 "read"(buf: $FriendlyByteBuf$Type): $Frequency$FrequencyIdentity
 "serialize"(data: $Frequency$FrequencyIdentity$Type): $CompoundTag
}

export namespace $IdentitySerializer {
const NAME: $IdentitySerializer
const UUID: $IdentitySerializer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdentitySerializer$Type = ($IdentitySerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdentitySerializer_ = $IdentitySerializer$Type;
}}
declare module "packages/mekanism/common/registration/$INamedEntry" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $INamedEntry {

 "getInternalRegistryName"(): string

(): string
}

export namespace $INamedEntry {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $INamedEntry$Type = ($INamedEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $INamedEntry_ = $INamedEntry$Type;
}}
declare module "packages/mekanism/common/tile/transmitter/$TileEntityRestrictiveTransporter" {
import {$TileEntityLogisticalTransporterBase, $TileEntityLogisticalTransporterBase$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityLogisticalTransporterBase"
import {$TransmitterType, $TransmitterType$Type} from "packages/mekanism/common/block/states/$TransmitterType"
import {$TransmitterModelData, $TransmitterModelData$Type} from "packages/mekanism/client/model/data/$TransmitterModelData"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $TileEntityRestrictiveTransporter extends $TileEntityLogisticalTransporterBase {
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "getTransmitterType"(): $TransmitterType
get "transmitterType"(): $TransmitterType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityRestrictiveTransporter$Type = ($TileEntityRestrictiveTransporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityRestrictiveTransporter_ = $TileEntityRestrictiveTransporter$Type;
}}
declare module "packages/mekanism/common/integration/computer/$ComputerMethodFactory$ComputerFunctionCaller" {
import {$BaseComputerHelper, $BaseComputerHelper$Type} from "packages/mekanism/common/integration/computer/$BaseComputerHelper"

export interface $ComputerMethodFactory$ComputerFunctionCaller<T> {

 "apply"(t: T, u: $BaseComputerHelper$Type): any

(t: T, u: $BaseComputerHelper$Type): any
}

export namespace $ComputerMethodFactory$ComputerFunctionCaller {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComputerMethodFactory$ComputerFunctionCaller$Type<T> = ($ComputerMethodFactory$ComputerFunctionCaller<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComputerMethodFactory$ComputerFunctionCaller_<T> = $ComputerMethodFactory$ComputerFunctionCaller$Type<(T)>;
}}
declare module "packages/mekanism/common/item/gear/$ItemFlamethrower$FlamethrowerMode" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$IIncrementalEnum, $IIncrementalEnum$Type} from "packages/mekanism/api/$IIncrementalEnum"
import {$IHasTextComponent, $IHasTextComponent$Type} from "packages/mekanism/api/text/$IHasTextComponent"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export class $ItemFlamethrower$FlamethrowerMode extends $Enum<($ItemFlamethrower$FlamethrowerMode)> implements $IIncrementalEnum<($ItemFlamethrower$FlamethrowerMode)>, $IHasTextComponent {
static readonly "COMBAT": $ItemFlamethrower$FlamethrowerMode
static readonly "HEAT": $ItemFlamethrower$FlamethrowerMode
static readonly "INFERNO": $ItemFlamethrower$FlamethrowerMode


public static "values"(): ($ItemFlamethrower$FlamethrowerMode)[]
public static "valueOf"(name: string): $ItemFlamethrower$FlamethrowerMode
public "byIndex"(index: integer): $ItemFlamethrower$FlamethrowerMode
public "getTextComponent"(): $Component
public static "byIndexStatic"(index: integer): $ItemFlamethrower$FlamethrowerMode
public "ordinal"(): integer
public "adjust"(arg0: integer): $ItemFlamethrower$FlamethrowerMode
public "adjust"(arg0: integer, arg1: $Predicate$Type<($ItemFlamethrower$FlamethrowerMode$Type)>): $ItemFlamethrower$FlamethrowerMode
public "getNext"(arg0: $Predicate$Type<($ItemFlamethrower$FlamethrowerMode$Type)>): $ItemFlamethrower$FlamethrowerMode
public "getNext"(): $ItemFlamethrower$FlamethrowerMode
public "getPrevious"(): $ItemFlamethrower$FlamethrowerMode
public "getPrevious"(arg0: $Predicate$Type<($ItemFlamethrower$FlamethrowerMode$Type)>): $ItemFlamethrower$FlamethrowerMode
get "textComponent"(): $Component
get "next"(): $ItemFlamethrower$FlamethrowerMode
get "previous"(): $ItemFlamethrower$FlamethrowerMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFlamethrower$FlamethrowerMode$Type = (("heat") | ("combat") | ("inferno")) | ($ItemFlamethrower$FlamethrowerMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFlamethrower$FlamethrowerMode_ = $ItemFlamethrower$FlamethrowerMode$Type;
}}
declare module "packages/mekanism/common/lib/transmitter/acceptor/$AcceptorCache$AcceptorInfo" {
import {$AbstractAcceptorInfo, $AbstractAcceptorInfo$Type} from "packages/mekanism/common/lib/transmitter/acceptor/$AbstractAcceptorInfo"

export class $AcceptorCache$AcceptorInfo<ACCEPTOR> extends $AbstractAcceptorInfo {


public "equals"(o: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AcceptorCache$AcceptorInfo$Type<ACCEPTOR> = ($AcceptorCache$AcceptorInfo<(ACCEPTOR)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AcceptorCache$AcceptorInfo_<ACCEPTOR> = $AcceptorCache$AcceptorInfo$Type<(ACCEPTOR)>;
}}
declare module "packages/mekanism/common/inventory/container/type/$MekanismItemContainerType$IMekanismItemContainerFactory" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export interface $MekanismItemContainerType$IMekanismItemContainerFactory<ITEM extends $Item, CONTAINER extends $AbstractContainerMenu> {

 "create"(id: integer, inv: $Inventory$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type): CONTAINER

(id: integer, inv: $Inventory$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type): CONTAINER
}

export namespace $MekanismItemContainerType$IMekanismItemContainerFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismItemContainerType$IMekanismItemContainerFactory$Type<ITEM, CONTAINER> = ($MekanismItemContainerType$IMekanismItemContainerFactory<(ITEM), (CONTAINER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismItemContainerType$IMekanismItemContainerFactory_<ITEM, CONTAINER> = $MekanismItemContainerType$IMekanismItemContainerFactory$Type<(ITEM), (CONTAINER)>;
}}
declare module "packages/mekanism/common/config/value/$CachedLongValue" {
import {$IMekanismConfig, $IMekanismConfig$Type} from "packages/mekanism/common/config/$IMekanismConfig"
import {$ForgeConfigSpec$ConfigValue, $ForgeConfigSpec$ConfigValue$Type} from "packages/net/minecraftforge/common/$ForgeConfigSpec$ConfigValue"
import {$LongSupplier, $LongSupplier$Type} from "packages/java/util/function/$LongSupplier"
import {$CachedValue, $CachedValue$Type} from "packages/mekanism/common/config/value/$CachedValue"

export class $CachedLongValue extends $CachedValue<(long)> implements $LongSupplier {


public "get"(): long
public static "wrap"(config: $IMekanismConfig$Type, internal: $ForgeConfigSpec$ConfigValue$Type<(long)>): $CachedLongValue
public "set"(value: long): void
public "getOrDefault"(): long
public "getAsLong"(): long
get "orDefault"(): long
get "asLong"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedLongValue$Type = ($CachedLongValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedLongValue_ = $CachedLongValue$Type;
}}
declare module "packages/mekanism/common/item/$ItemEnergized" {
import {$FloatingLongSupplier, $FloatingLongSupplier$Type} from "packages/mekanism/api/math/$FloatingLongSupplier"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$CreativeModeTab$Output, $CreativeModeTab$Output$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$Output"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CapabilityItem, $CapabilityItem$Type} from "packages/mekanism/common/item/$CapabilityItem"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$Type} from "packages/mekanism/common/registration/impl/$CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemEnergized extends $CapabilityItem implements $CreativeTabDeferredRegister$ICustomCreativeTabContents {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(chargeRateSupplier: $FloatingLongSupplier$Type, maxEnergySupplier: $FloatingLongSupplier$Type, properties: $Item$Properties$Type)
constructor(chargeRateSupplier: $FloatingLongSupplier$Type, maxEnergySupplier: $FloatingLongSupplier$Type, canExtract: $Predicate$Type<($AutomationType$Type)>, canInsert: $Predicate$Type<($AutomationType$Type)>, properties: $Item$Properties$Type)

public "addItems"(tabOutput: $CreativeModeTab$Output$Type): void
public "shouldCauseBlockBreakReset"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type): boolean
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$Type, newStack: $ItemStack$Type, slotChanged: boolean): boolean
public "isBarVisible"(stack: $ItemStack$Type): boolean
public "getBarWidth"(stack: $ItemStack$Type): integer
public "getBarColor"(stack: $ItemStack$Type): integer
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "addDefault"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEnergized$Type = ($ItemEnergized);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemEnergized_ = $ItemEnergized$Type;
}}
declare module "packages/mekanism/common/resource/ore/$OreType$OreVeinType" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$OreType, $OreType$Type} from "packages/mekanism/common/resource/ore/$OreType"

export class $OreType$OreVeinType extends $Record {
static readonly "CODEC": $Codec<($OreType$OreVeinType)>

constructor(type: $OreType$Type, index: integer)

public "index"(): integer
public "name"(): string
public "type"(): $OreType
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreType$OreVeinType$Type = ($OreType$OreVeinType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OreType$OreVeinType_ = $OreType$OreVeinType$Type;
}}
declare module "packages/mekanism/common/inventory/container/slot/$InventoryContainerSlot" {
import {$IInsertableSlot, $IInsertableSlot$Type} from "packages/mekanism/common/inventory/container/slot/$IInsertableSlot"
import {$ContainerSlotType, $ContainerSlotType$Type} from "packages/mekanism/common/inventory/container/slot/$ContainerSlotType"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$SelectedWindowData, $SelectedWindowData$Type} from "packages/mekanism/common/inventory/container/$SelectedWindowData"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$SlotOverlay, $SlotOverlay$Type} from "packages/mekanism/common/inventory/container/slot/$SlotOverlay"
import {$ISupportsWarning, $ISupportsWarning$Type} from "packages/mekanism/common/inventory/warning/$ISupportsWarning"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BasicInventorySlot, $BasicInventorySlot$Type} from "packages/mekanism/common/inventory/slot/$BasicInventorySlot"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $InventoryContainerSlot extends $Slot implements $IInsertableSlot {
readonly "slot": integer
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(slot: $BasicInventorySlot$Type, x: integer, y: integer, slotType: $ContainerSlotType$Type, slotOverlay: $SlotOverlay$Type, warningAdder: $Consumer$Type<($ISupportsWarning$Type<(any)>)>, uncheckedSetter: $Consumer$Type<($ItemStack$Type)>)

public "mayPickup"(player: $Player$Type): boolean
public "mayPlace"(stack: $ItemStack$Type): boolean
public "hasItem"(): boolean
public "getMaxStackSize"(stack: $ItemStack$Type): integer
public "setChanged"(): void
public "set"(stack: $ItemStack$Type): void
public "getMaxStackSize"(): integer
public "addWarnings"(slot: $ISupportsWarning$Type<(any)>): void
public "getSlotOverlay"(): $SlotOverlay
public "getItem"(): $ItemStack
public "getSlotType"(): $ContainerSlotType
public "insertItem"(stack: $ItemStack$Type, action: $Action$Type): $ItemStack
public "remove"(amount: integer): $ItemStack
public "getInventorySlot"(): $IInventorySlot
public "exists"(windowData: $SelectedWindowData$Type): boolean
public "canMergeWith"(stack: $ItemStack$Type): boolean
get "maxStackSize"(): integer
get "slotOverlay"(): $SlotOverlay
get "item"(): $ItemStack
get "slotType"(): $ContainerSlotType
get "inventorySlot"(): $IInventorySlot
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryContainerSlot$Type = ($InventoryContainerSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryContainerSlot_ = $InventoryContainerSlot$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$InputRecipeCache$FluidChemical" {
import {$ChemicalStackIngredient, $ChemicalStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient"
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$ChemicalInputCache, $ChemicalInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$ChemicalInputCache"
import {$DoubleInputRecipeCache, $DoubleInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$DoubleInputRecipeCache"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$MekanismRecipeType, $MekanismRecipeType$Type} from "packages/mekanism/common/recipe/$MekanismRecipeType"
import {$FluidInputCache, $FluidInputCache$Type} from "packages/mekanism/common/recipe/lookup/cache/type/$FluidInputCache"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$FluidStackIngredient, $FluidStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$FluidStackIngredient"

export class $InputRecipeCache$FluidChemical<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>, RECIPE extends ($MekanismRecipe) & ($BiPredicate<($FluidStack), (STACK)>)> extends $DoubleInputRecipeCache<($FluidStack), ($FluidStackIngredient), (STACK), ($ChemicalStackIngredient<(CHEMICAL), (STACK)>), (RECIPE), ($FluidInputCache<(RECIPE)>), ($ChemicalInputCache<(CHEMICAL), (STACK), (RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$Type<(RECIPE), (any)>, inputAExtractor: $Function$Type<(RECIPE), ($FluidStackIngredient$Type)>, inputBExtractor: $Function$Type<(RECIPE), ($ChemicalStackIngredient$Type<(CHEMICAL), (STACK)>)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$FluidChemical$Type<CHEMICAL, STACK, RECIPE> = ($InputRecipeCache$FluidChemical<(CHEMICAL), (STACK), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$FluidChemical_<CHEMICAL, STACK, RECIPE> = $InputRecipeCache$FluidChemical$Type<(CHEMICAL), (STACK), (RECIPE)>;
}}
declare module "packages/mekanism/common/block/prefab/$BlockBasicMultiblock" {
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$BlockTile, $BlockTile$Type} from "packages/mekanism/common/block/prefab/$BlockTile"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockBasicMultiblock<TILE extends $TileEntityMekanism> extends $BlockTile<(TILE), ($BlockTypeTile<(TILE)>)> {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(type: $BlockTypeTile$Type<(TILE)>, propertiesModifier: $UnaryOperator$Type<($BlockBehaviour$Properties$Type)>)
constructor(type: $BlockTypeTile$Type<(TILE)>, properties: $BlockBehaviour$Properties$Type)

/**
 * 
 * @deprecated
 */
public "use"(state: $BlockState$Type, world: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBasicMultiblock$Type<TILE> = ($BlockBasicMultiblock<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBasicMultiblock_<TILE> = $BlockBasicMultiblock$Type<(TILE)>;
}}
declare module "packages/mekanism/common/registration/impl/$CreativeTabDeferredRegister$ICustomCreativeTabContents" {
import {$CreativeModeTab$Output, $CreativeModeTab$Output$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$Output"

export interface $CreativeTabDeferredRegister$ICustomCreativeTabContents {

 "addItems"(tabOutput: $CreativeModeTab$Output$Type): void
 "addDefault"(): boolean

(tabOutput: $CreativeModeTab$Output$Type): void
}

export namespace $CreativeTabDeferredRegister$ICustomCreativeTabContents {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabDeferredRegister$ICustomCreativeTabContents$Type = ($CreativeTabDeferredRegister$ICustomCreativeTabContents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabDeferredRegister$ICustomCreativeTabContents_ = $CreativeTabDeferredRegister$ICustomCreativeTabContents$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$IBoundingBlock" {
import {$LazyOptional, $LazyOptional$Type} from "packages/net/minecraftforge/common/util/$LazyOptional"
import {$Vec3i, $Vec3i$Type} from "packages/net/minecraft/core/$Vec3i"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IUpgradeTile, $IUpgradeTile$Type} from "packages/mekanism/common/tile/interfaces/$IUpgradeTile"
import {$IOffsetCapability, $IOffsetCapability$Type} from "packages/mekanism/common/capabilities/$IOffsetCapability"
import {$Capability, $Capability$Type} from "packages/net/minecraftforge/common/capabilities/$Capability"
import {$TileComponentUpgrade, $TileComponentUpgrade$Type} from "packages/mekanism/common/tile/component/$TileComponentUpgrade"
import {$IComparatorSupport, $IComparatorSupport$Type} from "packages/mekanism/common/tile/interfaces/$IComparatorSupport"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$Upgrade, $Upgrade$Type} from "packages/mekanism/api/$Upgrade"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $IBoundingBlock extends $ICapabilityProvider, $IComparatorSupport, $IOffsetCapability, $IUpgradeTile {

 "onBoundingBlockPowerChange"(boundingPos: $BlockPos$Type, oldLevel: integer, newLevel: integer): void
 "triggerBoundingEvent"(offset: $Vec3i$Type, id: integer, param: integer): boolean
 "getBoundingComparatorSignal"(offset: $Vec3i$Type): integer
 "isOffsetCapabilityDisabled"(capability: $Capability$Type<(any)>, side: $Direction$Type, offset: $Vec3i$Type): boolean
 "getOffsetCapabilityIfEnabled"<T>(capability: $Capability$Type<(T)>, side: $Direction$Type, offset: $Vec3i$Type): $LazyOptional<(T)>
 "getCapability"<T>(arg0: $Capability$Type<(T)>, arg1: $Direction$Type): $LazyOptional<(T)>
 "getCapability"<T>(arg0: $Capability$Type<(T)>): $LazyOptional<(T)>
 "getRedstoneLevel"(): integer
 "getCurrentRedstoneLevel"(): integer
 "supportsComparator"(): boolean
 "getOffsetCapability"<T>(capability: $Capability$Type<(T)>, side: $Direction$Type, offset: $Vec3i$Type): $LazyOptional<(T)>
 "recalculateUpgrades"(upgradeType: $Upgrade$Type): void
 "supportsUpgrades"(): boolean
 "supportsUpgrade"(upgradeType: $Upgrade$Type): boolean
 "getComponent"(): $TileComponentUpgrade
}

export namespace $IBoundingBlock {
const ALWAYS_PROXY: $Set<($Capability<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IBoundingBlock$Type = ($IBoundingBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IBoundingBlock_ = $IBoundingBlock$Type;
}}
declare module "packages/mekanism/common/item/$ItemCraftingFormula" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemCraftingFormula extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "isInvalid"(stack: $ItemStack$Type): boolean
public "setInventory"(stack: $ItemStack$Type, inv: $NonNullList$Type<($ItemStack$Type)>): void
public "getMaxStackSize"(stack: $ItemStack$Type): integer
public "getInventory"(stack: $ItemStack$Type): $NonNullList<($ItemStack)>
public "setInvalid"(stack: $ItemStack$Type, invalid: boolean): void
public "use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "appendHoverText"(itemStack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
public "getName"(stack: $ItemStack$Type): $Component
public "hasInventory"(stack: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemCraftingFormula$Type = ($ItemCraftingFormula);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemCraftingFormula_ = $ItemCraftingFormula$Type;
}}
declare module "packages/mekanism/common/inventory/container/entity/$IEntityContainer" {
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $IEntityContainer<ENTITY extends $Entity> {

 "getEntity"(): ENTITY

(): ENTITY
}

export namespace $IEntityContainer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEntityContainer$Type<ENTITY> = ($IEntityContainer<(ENTITY)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEntityContainer_<ENTITY> = $IEntityContainer$Type<(ENTITY)>;
}}
declare module "packages/mekanism/common/capabilities/$GenericTankSpec" {
import {$TriPredicate, $TriPredicate$Type} from "packages/net/minecraftforge/common/util/$TriPredicate"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$AutomationType, $AutomationType$Type} from "packages/mekanism/api/$AutomationType"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $GenericTankSpec<TYPE> {
readonly "isValid": $Predicate<(TYPE)>
readonly "canExtract": $BiPredicate<(TYPE), ($AutomationType)>
readonly "canInsert": $TriPredicate<(TYPE), ($AutomationType), ($ItemStack)>


public "supportsStack"(stack: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenericTankSpec$Type<TYPE> = ($GenericTankSpec<(TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenericTankSpec_<TYPE> = $GenericTankSpec$Type<(TYPE)>;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/type/$IInputCache" {
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$InputIngredient, $InputIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$InputIngredient"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IMultiIngredient, $IMultiIngredient$Type} from "packages/mekanism/common/recipe/ingredient/$IMultiIngredient"

export interface $IInputCache<INPUT, INGREDIENT extends $InputIngredient<(INPUT)>, RECIPE extends $MekanismRecipe> {

 "clear"(): void
 "isEmpty"(input: INPUT): boolean
 "contains"(input: INPUT): boolean
 "contains"(input: INPUT, matchCriteria: $Predicate$Type<(RECIPE)>): boolean
 "findFirstRecipe"(input: INPUT, matchCriteria: $Predicate$Type<(RECIPE)>): RECIPE
 "mapInputs"(recipe: RECIPE, inputIngredient: INGREDIENT): boolean
 "mapMultiInputs"(recipe: RECIPE, multi: $IMultiIngredient$Type<(INPUT), (any)>): boolean
}

export namespace $IInputCache {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInputCache$Type<INPUT, INGREDIENT, RECIPE> = ($IInputCache<(INPUT), (INGREDIENT), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInputCache_<INPUT, INGREDIENT, RECIPE> = $IInputCache$Type<(INPUT), (INGREDIENT), (RECIPE)>;
}}
declare module "packages/mekanism/common/recipe/serializer/$WrappedShapedRecipeSerializer" {
import {$ShapedRecipe, $ShapedRecipe$Type} from "packages/net/minecraft/world/item/crafting/$ShapedRecipe"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$WrappedShapedRecipe, $WrappedShapedRecipe$Type} from "packages/mekanism/common/recipe/$WrappedShapedRecipe"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $WrappedShapedRecipeSerializer<RECIPE extends $WrappedShapedRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(wrapper: $Function$Type<($ShapedRecipe$Type), (RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedShapedRecipeSerializer$Type<RECIPE> = ($WrappedShapedRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedShapedRecipeSerializer_<RECIPE> = $WrappedShapedRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/recipe/$IMekanismRecipeTypeProvider" {
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$MekanismRecipeType, $MekanismRecipeType$Type} from "packages/mekanism/common/recipe/$MekanismRecipeType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IInputRecipeCache, $IInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$IInputRecipeCache"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $IMekanismRecipeTypeProvider<RECIPE extends $MekanismRecipe, INPUT_CACHE extends $IInputRecipeCache> {

 "stream"(world: $Level$Type): $Stream<(RECIPE)>
 "contains"(world: $Level$Type, matchCriteria: $Predicate$Type<(RECIPE)>): boolean
 "findFirst"(world: $Level$Type, matchCriteria: $Predicate$Type<(RECIPE)>): RECIPE
 "getRecipeType"(): $MekanismRecipeType<(RECIPE), (INPUT_CACHE)>
 "getRegistryName"(): $ResourceLocation
 "getInputCache"(): INPUT_CACHE
 "getRecipes"(world: $Level$Type): $List<(RECIPE)>

(world: $Level$Type): $Stream<(RECIPE)>
}

export namespace $IMekanismRecipeTypeProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMekanismRecipeTypeProvider$Type<RECIPE, INPUT_CACHE> = ($IMekanismRecipeTypeProvider<(RECIPE), (INPUT_CACHE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMekanismRecipeTypeProvider_<RECIPE, INPUT_CACHE> = $IMekanismRecipeTypeProvider$Type<(RECIPE), (INPUT_CACHE)>;
}}
declare module "packages/mekanism/common/content/network/transmitter/$BoxedPressurizedTube" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$CompatibleTransmitterValidator, $CompatibleTransmitterValidator$Type} from "packages/mekanism/common/lib/transmitter/$CompatibleTransmitterValidator"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$IUpgradeableTransmitter, $IUpgradeableTransmitter$Type} from "packages/mekanism/common/content/network/transmitter/$IUpgradeableTransmitter"
import {$IGasTracker, $IGasTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IGasTracker"
import {$BoxedChemicalStack, $BoxedChemicalStack$Type} from "packages/mekanism/api/chemical/merged/$BoxedChemicalStack"
import {$IPigmentTank, $IPigmentTank$Type} from "packages/mekanism/api/chemical/pigment/$IPigmentTank"
import {$IPigmentTracker, $IPigmentTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IPigmentTracker"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BoxedChemicalHandler, $BoxedChemicalHandler$Type} from "packages/mekanism/common/capabilities/chemical/$BoxedChemicalHandler"
import {$IInfusionTank, $IInfusionTank$Type} from "packages/mekanism/api/chemical/infuse/$IInfusionTank"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$PressurizedTubeUpgradeData, $PressurizedTubeUpgradeData$Type} from "packages/mekanism/common/upgrade/transmitter/$PressurizedTubeUpgradeData"
import {$MergedChemicalTank, $MergedChemicalTank$Type} from "packages/mekanism/api/chemical/merged/$MergedChemicalTank"
import {$TubeTier, $TubeTier$Type} from "packages/mekanism/common/tier/$TubeTier"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$BufferedTransmitter, $BufferedTransmitter$Type} from "packages/mekanism/common/content/network/transmitter/$BufferedTransmitter"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$ISlurryTank, $ISlurryTank$Type} from "packages/mekanism/api/chemical/slurry/$ISlurryTank"
import {$BoxedChemicalNetwork, $BoxedChemicalNetwork$Type} from "packages/mekanism/common/content/network/$BoxedChemicalNetwork"
import {$TransmitterUpgradeData, $TransmitterUpgradeData$Type} from "packages/mekanism/common/upgrade/transmitter/$TransmitterUpgradeData"
import {$ISlurryTracker, $ISlurryTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$ISlurryTracker"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$IInfusionTracker, $IInfusionTracker$Type} from "packages/mekanism/common/capabilities/chemical/dynamic/$IInfusionTracker"
import {$AlloyTier, $AlloyTier$Type} from "packages/mekanism/api/tier/$AlloyTier"

export class $BoxedPressurizedTube extends $BufferedTransmitter<($BoxedChemicalHandler), ($BoxedChemicalNetwork), ($BoxedChemicalStack), ($BoxedPressurizedTube)> implements $IGasTracker, $IInfusionTracker, $IPigmentTracker, $ISlurryTracker, $IUpgradeableTransmitter<($PressurizedTubeUpgradeData)> {
readonly "tier": $TubeTier
readonly "chemicalTank": $MergedChemicalTank
 "saveShare": $BoxedChemicalStack
 "currentTransmitterConnections": byte

constructor(blockProvider: $IBlockProvider$Type, tile: $TileEntityTransmitter$Type)

public "write"(nbtTags: $CompoundTag$Type): $CompoundTag
public "read"(nbtTags: $CompoundTag$Type): void
public "getCapacity"(): long
public "onContentsChanged"(): void
public "getGasTank"(): $IGasTank
public "getSlurryTank"(): $ISlurryTank
public "getInfusionTank"(): $IInfusionTank
public "getPigmentTank"(): $IPigmentTank
public "getShare"(): $BoxedChemicalStack
public "parseUpgradeData"(data: $PressurizedTubeUpgradeData$Type): void
public "takeShare"(): void
public "getInfusionTanks"(side: $Direction$Type): $List<($IInfusionTank)>
public "getPigmentTanks"(side: $Direction$Type): $List<($IPigmentTank)>
public "getGasTanks"(side: $Direction$Type): $List<($IGasTank)>
public "getSlurryTanks"(side: $Direction$Type): $List<($ISlurryTank)>
public "createEmptyNetworkWithID"(networkID: $UUID$Type): $BoxedChemicalNetwork
public "createNetworkByMerging"(toMerge: $Collection$Type<($BoxedChemicalNetwork$Type)>): $BoxedChemicalNetwork
public "getNewOrphanValidator"(): $CompatibleTransmitterValidator<($BoxedChemicalHandler), ($BoxedChemicalNetwork), ($BoxedPressurizedTube)>
public "dataTypeMatches"(data: $TransmitterUpgradeData$Type): boolean
public "isValidTransmitter"(transmitter: $TileEntityTransmitter$Type, side: $Direction$Type): boolean
public "isValidAcceptor"(tile: $BlockEntity$Type, side: $Direction$Type): boolean
public "pullFromAcceptors"(): void
public "noBufferOrFallback"(): boolean
public "takeChemical"(stack: $BoxedChemicalStack$Type, action: $Action$Type): void
public "canUpgrade"(alloyTier: $AlloyTier$Type): boolean
get "capacity"(): long
get "gasTank"(): $IGasTank
get "slurryTank"(): $ISlurryTank
get "infusionTank"(): $IInfusionTank
get "pigmentTank"(): $IPigmentTank
get "share"(): $BoxedChemicalStack
get "newOrphanValidator"(): $CompatibleTransmitterValidator<($BoxedChemicalHandler), ($BoxedChemicalNetwork), ($BoxedPressurizedTube)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoxedPressurizedTube$Type = ($BoxedPressurizedTube);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoxedPressurizedTube_ = $BoxedPressurizedTube$Type;
}}
declare module "packages/mekanism/common/tile/transmitter/$TileEntityPressurizedTube" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$TransmitterType, $TransmitterType$Type} from "packages/mekanism/common/block/states/$TransmitterType"
import {$TransmitterModelData, $TransmitterModelData$Type} from "packages/mekanism/client/model/data/$TransmitterModelData"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$BoundMethodHolder, $BoundMethodHolder$Type} from "packages/mekanism/common/integration/computer/$BoundMethodHolder"
import {$ITileRadioactive, $ITileRadioactive$Type} from "packages/mekanism/common/tile/interfaces/$ITileRadioactive"
import {$IComputerTile, $IComputerTile$Type} from "packages/mekanism/common/integration/computer/$IComputerTile"
import {$ConnectionType, $ConnectionType$Type} from "packages/mekanism/common/lib/transmitter/$ConnectionType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"

export class $TileEntityPressurizedTube extends $TileEntityTransmitter implements $IComputerTile, $ITileRadioactive {
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "getUpdateTag"(): $CompoundTag
public "getRadiationParticleCount"(): integer
public "getTransmitterType"(): $TransmitterType
public "getRadiationScale"(): float
public "getComputerName"(): string
public "sideChanged"(side: $Direction$Type, old: $ConnectionType$Type, type: $ConnectionType$Type): void
public "redstoneChanged"(powered: boolean): void
public "isComputerCapabilityPersistent"(): boolean
public "hasComputerSupport"(): boolean
public "getComputerMethods"(holder: $BoundMethodHolder$Type): void
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
get "updateTag"(): $CompoundTag
get "radiationParticleCount"(): integer
get "transmitterType"(): $TransmitterType
get "radiationScale"(): float
get "computerName"(): string
get "computerCapabilityPersistent"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityPressurizedTube$Type = ($TileEntityPressurizedTube);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityPressurizedTube_ = $TileEntityPressurizedTube$Type;
}}
declare module "packages/mekanism/common/capabilities/chemical/variable/$VariableCapacityChemicalTank" {
import {$ChemicalStack, $ChemicalStack$Type} from "packages/mekanism/api/chemical/$ChemicalStack"
import {$BasicChemicalTank, $BasicChemicalTank$Type} from "packages/mekanism/api/chemical/$BasicChemicalTank"
import {$Chemical, $Chemical$Type} from "packages/mekanism/api/chemical/$Chemical"
import {$Action, $Action$Type} from "packages/mekanism/api/$Action"

export class $VariableCapacityChemicalTank<CHEMICAL extends $Chemical<(CHEMICAL)>, STACK extends $ChemicalStack<(CHEMICAL)>> extends $BasicChemicalTank<(CHEMICAL), (STACK)> {


public "getCapacity"(): long
public "setStackSize"(amount: long, action: $Action$Type): long
get "capacity"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariableCapacityChemicalTank$Type<CHEMICAL, STACK> = ($VariableCapacityChemicalTank<(CHEMICAL), (STACK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariableCapacityChemicalTank_<CHEMICAL, STACK> = $VariableCapacityChemicalTank$Type<(CHEMICAL), (STACK)>;
}}
declare module "packages/mekanism/common/tile/component/$TileComponentChunkLoader" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$ITileComponent, $ITileComponent$Type} from "packages/mekanism/common/tile/component/$ITileComponent"
import {$IChunkLoader, $IChunkLoader$Type} from "packages/mekanism/common/lib/chunkloading/$IChunkLoader"

export class $TileComponentChunkLoader<T extends ($TileEntityMekanism) & ($IChunkLoader)> implements $ITileComponent {

constructor(tile: T)
constructor(tile: T, forceTicks: boolean)

public "write"(nbtTags: $CompoundTag$Type): void
public "read"(nbtTags: $CompoundTag$Type): void
public "removed"(): void
public "tickServer"(): void
public "canOperate"(): boolean
public "refreshChunkTickets"(): void
public "invalidate"(): void
public "trackForMainContainer"(container: $MekanismContainer$Type): void
public "readFromUpdateTag"(updateTag: $CompoundTag$Type): void
public "addToUpdateTag"(updateTag: $CompoundTag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileComponentChunkLoader$Type<T> = ($TileComponentChunkLoader<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileComponentChunkLoader_<T> = $TileComponentChunkLoader$Type<(T)>;
}}
declare module "packages/mekanism/common/world/height/$AnchorType" {
import {$WorldGenerationContext, $WorldGenerationContext$Type} from "packages/net/minecraft/world/level/levelgen/$WorldGenerationContext"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $AnchorType extends $Enum<($AnchorType)> {
static readonly "ABSOLUTE": $AnchorType
static readonly "ABOVE_BOTTOM": $AnchorType
static readonly "BELOW_TOP": $AnchorType


public static "values"(): ($AnchorType)[]
public static "valueOf"(name: string): $AnchorType
public "resolveY"(context: $WorldGenerationContext$Type, value: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnchorType$Type = (("absolute") | ("below_top") | ("above_bottom")) | ($AnchorType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnchorType_ = $AnchorType$Type;
}}
declare module "packages/mekanism/common/lib/math/voxel/$VoxelCuboid$WallRelative" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $VoxelCuboid$WallRelative extends $Enum<($VoxelCuboid$WallRelative)> {
static readonly "SIDE": $VoxelCuboid$WallRelative
static readonly "EDGE": $VoxelCuboid$WallRelative
static readonly "CORNER": $VoxelCuboid$WallRelative
static readonly "INVALID": $VoxelCuboid$WallRelative


public static "values"(): ($VoxelCuboid$WallRelative)[]
public static "valueOf"(name: string): $VoxelCuboid$WallRelative
public "isWall"(): boolean
public "isOnEdge"(): boolean
public "isOnCorner"(): boolean
get "wall"(): boolean
get "onEdge"(): boolean
get "onCorner"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VoxelCuboid$WallRelative$Type = (("side") | ("edge") | ("corner") | ("invalid")) | ($VoxelCuboid$WallRelative);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VoxelCuboid$WallRelative_ = $VoxelCuboid$WallRelative$Type;
}}
declare module "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ModelData, $ModelData$Type} from "packages/net/minecraftforge/client/model/data/$ModelData"
import {$TransmitterType, $TransmitterType$Type} from "packages/mekanism/common/block/states/$TransmitterType"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$TransmitterModelData, $TransmitterModelData$Type} from "packages/mekanism/client/model/data/$TransmitterModelData"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$CapabilityTileEntity, $CapabilityTileEntity$Type} from "packages/mekanism/common/tile/base/$CapabilityTileEntity"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ProxyConfigurable$ISidedConfigurable, $ProxyConfigurable$ISidedConfigurable$Type} from "packages/mekanism/common/capabilities/proxy/$ProxyConfigurable$ISidedConfigurable"
import {$IAlloyInteraction, $IAlloyInteraction$Type} from "packages/mekanism/api/$IAlloyInteraction"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ConnectionType, $ConnectionType$Type} from "packages/mekanism/common/lib/transmitter/$ConnectionType"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$AlloyTier, $AlloyTier$Type} from "packages/mekanism/api/tier/$AlloyTier"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"
import {$Transmitter, $Transmitter$Type} from "packages/mekanism/common/content/network/transmitter/$Transmitter"

export class $TileEntityTransmitter extends $CapabilityTileEntity implements $ProxyConfigurable$ISidedConfigurable, $IAlloyInteraction {
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "isLoaded"(): boolean
public "getRenderBoundingBox"(): $AABB
public "load"(nbt: $CompoundTag$Type): void
public "m_183515_"(nbtTags: $CompoundTag$Type): void
public "setRemoved"(): void
public "clearRemoved"(): void
public "onChunkUnloaded"(): void
public "onNeighborBlockChange"(side: $Direction$Type): void
public "getModelData"(): $ModelData
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "onAlloyInteraction"(player: $Player$Type, stack: $ItemStack$Type, tier: $AlloyTier$Type): void
public "getCollisionBoxes"(): $List<($VoxelShape)>
public "getTransmitterType"(): $TransmitterType
public "onRightClick"(player: $Player$Type, side: $Direction$Type): $InteractionResult
public static "tickServer"(level: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, transmitter: $TileEntityTransmitter$Type): void
public "handleUpdatePacket"(tag: $CompoundTag$Type): void
public "onAdded"(): void
public "getReducedUpdateTag"(): $CompoundTag
public "getTransmitter"(): $Transmitter<(any), (any), (any)>
public "sideChanged"(side: $Direction$Type, old: $ConnectionType$Type, type: $ConnectionType$Type): void
public "onSneakRightClick"(player: $Player$Type, side: $Direction$Type): $InteractionResult
public "onNeighborTileChange"(side: $Direction$Type): void
public "chunkAccessibilityChange"(loaded: boolean): void
public "getSideLookingAt"(player: $Player$Type, fallback: $Direction$Type): $Direction
public "getSideLookingAt"(player: $Player$Type): $Direction
public "setForceUpdate"(): void
public "redstoneChanged"(powered: boolean): void
public "onRightClick"(player: $Player$Type): $InteractionResult
public "onSneakRightClick"(player: $Player$Type): $InteractionResult
get "loaded"(): boolean
get "renderBoundingBox"(): $AABB
get "modelData"(): $ModelData
get "collisionBoxes"(): $List<($VoxelShape)>
get "transmitterType"(): $TransmitterType
get "reducedUpdateTag"(): $CompoundTag
get "transmitter"(): $Transmitter<(any), (any), (any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityTransmitter$Type = ($TileEntityTransmitter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityTransmitter_ = $TileEntityTransmitter$Type;
}}
declare module "packages/mekanism/common/inventory/container/item/$MekanismItemContainer" {
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ICapabilityProvider, $ICapabilityProvider$Type} from "packages/net/minecraftforge/common/capabilities/$ICapabilityProvider"
import {$MekanismContainer, $MekanismContainer$Type} from "packages/mekanism/common/inventory/container/$MekanismContainer"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ContainerListener, $ContainerListener$Type} from "packages/net/minecraft/world/inventory/$ContainerListener"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $MekanismItemContainer extends $MekanismContainer {
static readonly "BASE_Y_OFFSET": integer
static readonly "TRANSPORTER_CONFIG_WINDOW": integer
static readonly "SIDE_CONFIG_WINDOW": integer
static readonly "UPGRADE_WINDOW": integer
static readonly "SKIN_SELECT_WINDOW": integer
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
 "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
 "remoteSlots": $NonNullList<($ItemStack)>
 "stateId": integer
 "containerId": integer
readonly "containerListeners": $List<($ContainerListener)>


public "stillValid"(player: $Player$Type): boolean
public "getSecurityObject"(): $ICapabilityProvider
get "securityObject"(): $ICapabilityProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismItemContainer$Type = ($MekanismItemContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismItemContainer_ = $MekanismItemContainer$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$ISustainedInventory" {
import {$ListTag, $ListTag$Type} from "packages/net/minecraft/nbt/$ListTag"

export interface $ISustainedInventory {

 "getSustainedInventory"(): $ListTag
 "setSustainedInventory"(nbtTags: $ListTag$Type): void
 "hasSustainedInventory"(): boolean
}

export namespace $ISustainedInventory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISustainedInventory$Type = ($ISustainedInventory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISustainedInventory_ = $ISustainedInventory$Type;
}}
declare module "packages/mekanism/common/lib/multiblock/$IMultiblockBase" {
import {$MultiblockManager, $MultiblockManager$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockManager"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Structure, $Structure$Type} from "packages/mekanism/common/lib/multiblock/$Structure"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ITileWrapper, $ITileWrapper$Type} from "packages/mekanism/common/tile/interfaces/$ITileWrapper"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MultiblockData, $MultiblockData$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockData"

export interface $IMultiblockBase extends $ITileWrapper {

 "onActivate"(player: $Player$Type, hand: $InteractionHand$Type, stack: $ItemStack$Type): $InteractionResult
 "getStructure"(manager: $MultiblockManager$Type<(any)>): $Structure
 "setStructure"(manager: $MultiblockManager$Type<(any)>, structure: $Structure$Type): void
 "getDefaultData"(): $MultiblockData
 "resetForFormed"(): void
 "hasStructure"(structure: $Structure$Type): boolean
 "getMultiblockData"(manager: $MultiblockManager$Type<(any)>): $MultiblockData
 "resetStructure"(manager: $MultiblockManager$Type<(any)>): $Structure
 "setMultiblockData"(manager: $MultiblockManager$Type<(any)>, multiblockData: $MultiblockData$Type): void
 "getTilePos"(): $BlockPos
 "getTileWorld"(): $Level
 "getTileCoord"(): $Coord4D
 "getTileChunk"(): $Chunk3D
}

export namespace $IMultiblockBase {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMultiblockBase$Type = ($IMultiblockBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMultiblockBase_ = $IMultiblockBase$Type;
}}
declare module "packages/mekanism/common/item/$ItemSeismicReader" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemEnergized, $ItemEnergized$Type} from "packages/mekanism/common/item/$ItemEnergized"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionResultHolder, $InteractionResultHolder$Type} from "packages/net/minecraft/world/$InteractionResultHolder"
import {$TooltipFlag, $TooltipFlag$Type} from "packages/net/minecraft/world/item/$TooltipFlag"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemSeismicReader extends $ItemEnergized {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(properties: $Item$Properties$Type)

public "use"(world: $Level$Type, player: $Player$Type, hand: $InteractionHand$Type): $InteractionResultHolder<($ItemStack)>
public "appendHoverText"(stack: $ItemStack$Type, world: $Level$Type, tooltip: $List$Type<($Component$Type)>, flag: $TooltipFlag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemSeismicReader$Type = ($ItemSeismicReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemSeismicReader_ = $ItemSeismicReader$Type;
}}
declare module "packages/mekanism/common/block/$BlockPersonalStorage" {
import {$Attribute, $Attribute$Type} from "packages/mekanism/common/block/attribute/$Attribute"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$BlockTile, $BlockTile$Type} from "packages/mekanism/common/block/prefab/$BlockTile"
import {$BlockTypeTile, $BlockTypeTile$Type} from "packages/mekanism/common/content/blocktype/$BlockTypeTile"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$TileEntityPersonalStorage, $TileEntityPersonalStorage$Type} from "packages/mekanism/common/tile/$TileEntityPersonalStorage"

export class $BlockPersonalStorage<TILE extends $TileEntityPersonalStorage, BLOCK extends $BlockTypeTile<(TILE)>> extends $BlockTile<(TILE), (BLOCK)> {
static readonly "PERSONAL_STORAGE_INVENTORY": $Attribute
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "properties": $BlockBehaviour$Properties

constructor(type: BLOCK, propertiesModifier: $UnaryOperator$Type<($BlockBehaviour$Properties$Type)>)

public "setPlacedBy"(world: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, placer: $LivingEntity$Type, stack: $ItemStack$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPersonalStorage$Type<TILE, BLOCK> = ($BlockPersonalStorage<(TILE), (BLOCK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPersonalStorage_<TILE, BLOCK> = $BlockPersonalStorage$Type<(TILE), (BLOCK)>;
}}
declare module "packages/mekanism/common/tile/prefab/$TileEntityInternalMultiblock" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TileEntityMekanism, $TileEntityMekanism$Type} from "packages/mekanism/common/tile/base/$TileEntityMekanism"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$MultiblockData, $MultiblockData$Type} from "packages/mekanism/common/lib/multiblock/$MultiblockData"
import {$IGasTank, $IGasTank$Type} from "packages/mekanism/api/chemical/gas/$IGasTank"
import {$IInternalMultiblock, $IInternalMultiblock$Type} from "packages/mekanism/common/lib/multiblock/$IInternalMultiblock"

export class $TileEntityInternalMultiblock extends $TileEntityMekanism implements $IInternalMultiblock {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
 "blockState": $BlockState

constructor(blockProvider: $IBlockProvider$Type, pos: $BlockPos$Type, state: $BlockState$Type)

public "onNeighborChange"(block: $Block$Type, neighborPos: $BlockPos$Type): void
public "handleUpdateTag"(tag: $CompoundTag$Type): void
public "getMultiblock"(): $MultiblockData
public "blockRemoved"(): void
public "getReducedUpdateTag"(): $CompoundTag
public "setMultiblock"(multiblock: $MultiblockData$Type): void
public "getMultiblockUUID"(): $UUID
public "hasFormedMultiblock"(): boolean
public static "calculateRadiationScale"(tanks: $List$Type<($IGasTank$Type)>): float
public "getTilePos"(): $BlockPos
public "getTileWorld"(): $Level
public "getTileCoord"(): $Coord4D
public "getTileChunk"(): $Chunk3D
get "multiblock"(): $MultiblockData
get "reducedUpdateTag"(): $CompoundTag
set "multiblock"(value: $MultiblockData$Type)
get "multiblockUUID"(): $UUID
get "tilePos"(): $BlockPos
get "tileWorld"(): $Level
get "tileCoord"(): $Coord4D
get "tileChunk"(): $Chunk3D
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityInternalMultiblock$Type = ($TileEntityInternalMultiblock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityInternalMultiblock_ = $TileEntityInternalMultiblock$Type;
}}
declare module "packages/mekanism/common/tile/interfaces/$ITileSound" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Chunk3D, $Chunk3D$Type} from "packages/mekanism/api/$Chunk3D"
import {$ITileWrapper, $ITileWrapper$Type} from "packages/mekanism/common/tile/interfaces/$ITileWrapper"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$SoundSource, $SoundSource$Type} from "packages/net/minecraft/sounds/$SoundSource"
import {$Coord4D, $Coord4D$Type} from "packages/mekanism/api/$Coord4D"

export interface $ITileSound extends $ITileWrapper {

 "hasSound"(): boolean
 "getSoundCategory"(): $SoundSource
 "getSoundPos"(): $BlockPos
 "getInitialVolume"(): float
 "getVolume"(): float
 "getTilePos"(): $BlockPos
 "getTileWorld"(): $Level
 "getTileCoord"(): $Coord4D
 "getTileChunk"(): $Chunk3D
}

export namespace $ITileSound {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileSound$Type = ($ITileSound);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileSound_ = $ITileSound$Type;
}}
declare module "packages/mekanism/common/recipe/lookup/cache/$AbstractInputRecipeCache" {
import {$MekanismRecipe, $MekanismRecipe$Type} from "packages/mekanism/api/recipes/$MekanismRecipe"
import {$IInputRecipeCache, $IInputRecipeCache$Type} from "packages/mekanism/common/recipe/lookup/cache/$IInputRecipeCache"

export class $AbstractInputRecipeCache<RECIPE extends $MekanismRecipe> implements $IInputRecipeCache {


public "clear"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractInputRecipeCache$Type<RECIPE> = ($AbstractInputRecipeCache<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractInputRecipeCache_<RECIPE> = $AbstractInputRecipeCache$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/capabilities/heat/$ITileHeatHandler" {
import {$IMekanismHeatHandler, $IMekanismHeatHandler$Type} from "packages/mekanism/api/heat/$IMekanismHeatHandler"
import {$IHeatCapacitor, $IHeatCapacitor$Type} from "packages/mekanism/api/heat/$IHeatCapacitor"
import {$HeatAPI$HeatTransfer, $HeatAPI$HeatTransfer$Type} from "packages/mekanism/api/heat/$HeatAPI$HeatTransfer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IHeatHandler, $IHeatHandler$Type} from "packages/mekanism/api/heat/$IHeatHandler"

export interface $ITileHeatHandler extends $IMekanismHeatHandler {

 "simulate"(): $HeatAPI$HeatTransfer
 "getAmbientTemperature"(side: $Direction$Type): double
 "simulateEnvironment"(): double
 "updateHeatCapacitors"(side: $Direction$Type): void
 "incrementAdjacentTransfer"(currentAdjacentTransfer: double, tempToTransfer: double, side: $Direction$Type): double
 "getAdjacent"(side: $Direction$Type): $IHeatHandler
 "simulateAdjacent"(): double
 "canHandleHeat"(): boolean
 "getHeatCapacity"(arg0: integer, arg1: $Direction$Type): double
 "getHeatCapacitor"(arg0: integer, arg1: $Direction$Type): $IHeatCapacitor
 "handleHeat"(arg0: integer, arg1: double, arg2: $Direction$Type): void
 "getTemperature"(arg0: integer, arg1: $Direction$Type): double
 "getHeatCapacitors"(arg0: $Direction$Type): $List<($IHeatCapacitor)>
 "getHeatCapacitorCount"(arg0: $Direction$Type): integer
 "getTotalInverseInsulation"(arg0: $Direction$Type): double
 "getInverseConduction"(arg0: integer, arg1: $Direction$Type): double
 "getInverseInsulation"(arg0: integer, arg1: $Direction$Type): double
 "getHeatCapacity"(arg0: integer): double
 "handleHeat"(arg0: double, arg1: $Direction$Type): void
 "handleHeat"(arg0: integer, arg1: double): void
 "getHeatSideFor"(): $Direction
 "getTotalInverseConductionCoefficient"(arg0: $Direction$Type): double
 "getTemperature"(arg0: integer): double
 "getTotalHeatCapacity"(arg0: $Direction$Type): double
 "getHeatCapacitorCount"(): integer
 "getInverseConduction"(arg0: integer): double
 "getTotalTemperature"(arg0: $Direction$Type): double
 "onContentsChanged"(): void
 "handleHeat"(arg0: double): void
 "getTotalHeatCapacity"(): double
 "getTotalInverseConduction"(): double
 "getTotalTemperature"(): double
}

export namespace $ITileHeatHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileHeatHandler$Type = ($ITileHeatHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileHeatHandler_ = $ITileHeatHandler$Type;
}}
declare module "packages/mekanism/common/integration/computer/$MethodHelpData" {
import {$BoundMethodHolder$BoundMethodData, $BoundMethodHolder$BoundMethodData$Type} from "packages/mekanism/common/integration/computer/$BoundMethodHolder$BoundMethodData"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MethodData, $MethodData$Type} from "packages/mekanism/common/integration/computer/$MethodData"
import {$MethodHelpData$Param, $MethodHelpData$Param$Type} from "packages/mekanism/common/integration/computer/$MethodHelpData$Param"
import {$MethodHelpData$Returns, $MethodHelpData$Returns$Type} from "packages/mekanism/common/integration/computer/$MethodHelpData$Returns"
import {$MethodRestriction, $MethodRestriction$Type} from "packages/mekanism/common/integration/computer/$MethodRestriction"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $MethodHelpData extends $Record {
static readonly "CODEC": $Codec<($MethodHelpData)>

constructor(methodName: string, params: $List$Type<($MethodHelpData$Param$Type)>, returns: $MethodHelpData$Returns$Type, description: string, restriction: $MethodRestriction$Type, requiresPublicSecurity: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "methodName"(): string
public "hashCode"(): integer
public static "from"(data: $BoundMethodHolder$BoundMethodData$Type<(any)>): $MethodHelpData
public static "from"(data: $MethodData$Type<(any)>): $MethodHelpData
public "params"(): $List<($MethodHelpData$Param)>
public "description"(): string
public static "getEnumConstantNames"(argClass: $Class$Type<(any)>): $List<(string)>
public "restriction"(): $MethodRestriction
public static "getHumanType"(clazz: $Class$Type<(any)>, extraTypes: ($Class$Type<(any)>)[]): string
public "requiresPublicSecurity"(): boolean
public "returns"(): $MethodHelpData$Returns
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodHelpData$Type = ($MethodHelpData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodHelpData_ = $MethodHelpData$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$CombinerRecipeSerializer$IFactory" {
import {$CombinerRecipe, $CombinerRecipe$Type} from "packages/mekanism/api/recipes/$CombinerRecipe"
import {$ItemStackIngredient, $ItemStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ItemStackIngredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $CombinerRecipeSerializer$IFactory<RECIPE extends $CombinerRecipe> {

 "create"(id: $ResourceLocation$Type, mainInput: $ItemStackIngredient$Type, extraInput: $ItemStackIngredient$Type, output: $ItemStack$Type): RECIPE

(id: $ResourceLocation$Type, mainInput: $ItemStackIngredient$Type, extraInput: $ItemStackIngredient$Type, output: $ItemStack$Type): RECIPE
}

export namespace $CombinerRecipeSerializer$IFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CombinerRecipeSerializer$IFactory$Type<RECIPE> = ($CombinerRecipeSerializer$IFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CombinerRecipeSerializer$IFactory_<RECIPE> = $CombinerRecipeSerializer$IFactory$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/tile/interfaces/$ITileRedstone" {
import {$IRedstoneControl$RedstoneControl, $IRedstoneControl$RedstoneControl$Type} from "packages/mekanism/common/tile/interfaces/$IRedstoneControl$RedstoneControl"
import {$IRedstoneControl, $IRedstoneControl$Type} from "packages/mekanism/common/tile/interfaces/$IRedstoneControl"

export interface $ITileRedstone extends $IRedstoneControl {

 "supportsRedstone"(): boolean
 "onPowerChange"(): void
 "canPulse"(): boolean
 "getControlType"(): $IRedstoneControl$RedstoneControl
 "isPowered"(): boolean
 "wasPowered"(): boolean
 "setControlType"(type: $IRedstoneControl$RedstoneControl$Type): void
}

export namespace $ITileRedstone {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileRedstone$Type = ($ITileRedstone);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileRedstone_ = $ITileRedstone$Type;
}}
declare module "packages/mekanism/common/block/attribute/$Attribute" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ITier, $ITier$Type} from "packages/mekanism/api/tier/$ITier"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$IBlockProvider, $IBlockProvider$Type} from "packages/mekanism/api/providers/$IBlockProvider"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BaseTier, $BaseTier$Type} from "packages/mekanism/api/tier/$BaseTier"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export interface $Attribute {

 "adjustProperties"(props: $BlockBehaviour$Properties$Type): void
}

export namespace $Attribute {
function get<ATTRIBUTE>(blockProvider: $IBlockProvider$Type, type: $Class$Type<(ATTRIBUTE)>): ATTRIBUTE
function get<ATTRIBUTE>(block: $Block$Type, type: $Class$Type<(ATTRIBUTE)>): ATTRIBUTE
function get<ATTRIBUTE>(state: $BlockState$Type, type: $Class$Type<(ATTRIBUTE)>): ATTRIBUTE
function matches<ATTRIBUTE>(block: $Block$Type, type: $Class$Type<(ATTRIBUTE)>, checker: $Predicate$Type<(any)>): boolean
function isActive(state: $BlockState$Type): boolean
function ifPresent<ATTRIBUTE>(block: $Block$Type, type: $Class$Type<(ATTRIBUTE)>, action: $Consumer$Type<(any)>): void
function has(block: $Block$Type, type: $Class$Type<(any)>): boolean
function has(state: $BlockState$Type, type: $Class$Type<(any)>): boolean
function getAll(block: $Block$Type): $Collection<($Attribute)>
function setActive(state: $BlockState$Type, active: boolean): $BlockState
function getTier<TIER>(blockProvider: $IBlockProvider$Type, tierClass: $Class$Type<(TIER)>): TIER
function getTier<TIER>(block: $Block$Type, tierClass: $Class$Type<(TIER)>): TIER
function getFacing(state: $BlockState$Type): $Direction
function setFacing(state: $BlockState$Type, facing: $Direction$Type): $BlockState
function getBaseTier(block: $Block$Type): $BaseTier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Attribute$Type = ($Attribute);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Attribute_ = $Attribute$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$MetallurgicInfuserRecipeSerializer" {
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$ItemStackChemicalToItemStackRecipeSerializer, $ItemStackChemicalToItemStackRecipeSerializer$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackChemicalToItemStackRecipeSerializer"
import {$InfuseType, $InfuseType$Type} from "packages/mekanism/api/chemical/infuse/$InfuseType"
import {$InfusionStack, $InfusionStack$Type} from "packages/mekanism/api/chemical/infuse/$InfusionStack"
import {$ItemStackChemicalToItemStackRecipeSerializer$IFactory, $ItemStackChemicalToItemStackRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackChemicalToItemStackRecipeSerializer$IFactory"
import {$ChemicalStackIngredient$InfusionStackIngredient, $ChemicalStackIngredient$InfusionStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient$InfusionStackIngredient"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$MetallurgicInfuserRecipe, $MetallurgicInfuserRecipe$Type} from "packages/mekanism/api/recipes/$MetallurgicInfuserRecipe"

export class $MetallurgicInfuserRecipeSerializer<RECIPE extends $MetallurgicInfuserRecipe> extends $ItemStackChemicalToItemStackRecipeSerializer<($InfuseType), ($InfusionStack), ($ChemicalStackIngredient$InfusionStackIngredient), (RECIPE)> {

constructor(factory: $ItemStackChemicalToItemStackRecipeSerializer$IFactory$Type<($InfuseType$Type), ($InfusionStack$Type), ($ChemicalStackIngredient$InfusionStackIngredient$Type), (RECIPE)>)

public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetallurgicInfuserRecipeSerializer$Type<RECIPE> = ($MetallurgicInfuserRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MetallurgicInfuserRecipeSerializer_<RECIPE> = $MetallurgicInfuserRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/tile/interfaces/$IHasMode" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IHasMode {

 "nextMode"(): void
 "previousMode"(): void
}

export namespace $IHasMode {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHasMode$Type = ($IHasMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHasMode_ = $IHasMode$Type;
}}
declare module "packages/mekanism/common/content/gear/$IBlastingItem" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $IBlastingItem {

 "getBlastedBlocks"(world: $Level$Type, player: $Player$Type, stack: $ItemStack$Type, pos: $BlockPos$Type, state: $BlockState$Type): $Map<($BlockPos), ($BlockState)>

(world: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type): boolean
}

export namespace $IBlastingItem {
function canBlastBlock(world: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type): boolean
function findPositions(world: $Level$Type, targetPos: $BlockPos$Type, player: $Player$Type, radius: integer): $Map<($BlockPos), ($BlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IBlastingItem$Type = ($IBlastingItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IBlastingItem_ = $IBlastingItem$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$PaintingRecipeSerializer" {
import {$ChemicalStackIngredient$PigmentStackIngredient, $ChemicalStackIngredient$PigmentStackIngredient$Type} from "packages/mekanism/api/recipes/ingredients/$ChemicalStackIngredient$PigmentStackIngredient"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$ItemStackChemicalToItemStackRecipeSerializer, $ItemStackChemicalToItemStackRecipeSerializer$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackChemicalToItemStackRecipeSerializer"
import {$PaintingRecipe, $PaintingRecipe$Type} from "packages/mekanism/api/recipes/$PaintingRecipe"
import {$Pigment, $Pigment$Type} from "packages/mekanism/api/chemical/pigment/$Pigment"
import {$ItemStackChemicalToItemStackRecipeSerializer$IFactory, $ItemStackChemicalToItemStackRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$ItemStackChemicalToItemStackRecipeSerializer$IFactory"
import {$PigmentStack, $PigmentStack$Type} from "packages/mekanism/api/chemical/pigment/$PigmentStack"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $PaintingRecipeSerializer<RECIPE extends $PaintingRecipe> extends $ItemStackChemicalToItemStackRecipeSerializer<($Pigment), ($PigmentStack), ($ChemicalStackIngredient$PigmentStackIngredient), (RECIPE)> {

constructor(factory: $ItemStackChemicalToItemStackRecipeSerializer$IFactory$Type<($Pigment$Type), ($PigmentStack$Type), ($ChemicalStackIngredient$PigmentStackIngredient$Type), (RECIPE)>)

public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PaintingRecipeSerializer$Type<RECIPE> = ($PaintingRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PaintingRecipeSerializer_<RECIPE> = $PaintingRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/inventory/container/sync/$ISyncableData" {
import {$ISyncableData$DirtyType, $ISyncableData$DirtyType$Type} from "packages/mekanism/common/inventory/container/sync/$ISyncableData$DirtyType"
import {$PropertyData, $PropertyData$Type} from "packages/mekanism/common/network/to_client/container/property/$PropertyData"

export interface $ISyncableData {

 "isDirty"(): $ISyncableData$DirtyType
 "getPropertyData"(property: short, dirtyType: $ISyncableData$DirtyType$Type): $PropertyData
}

export namespace $ISyncableData {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISyncableData$Type = ($ISyncableData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISyncableData_ = $ISyncableData$Type;
}}
declare module "packages/mekanism/common/tile/transmitter/$TileEntityDiversionTransporter" {
import {$BoundMethodHolder, $BoundMethodHolder$Type} from "packages/mekanism/common/integration/computer/$BoundMethodHolder"
import {$TileEntityLogisticalTransporterBase, $TileEntityLogisticalTransporterBase$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityLogisticalTransporterBase"
import {$TransmitterType, $TransmitterType$Type} from "packages/mekanism/common/block/states/$TransmitterType"
import {$IComputerTile, $IComputerTile$Type} from "packages/mekanism/common/integration/computer/$IComputerTile"
import {$TransmitterModelData, $TransmitterModelData$Type} from "packages/mekanism/client/model/data/$TransmitterModelData"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $TileEntityDiversionTransporter extends $TileEntityLogisticalTransporterBase implements $IComputerTile {
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
 "blockState": $BlockState

constructor(pos: $BlockPos$Type, state: $BlockState$Type)

public "getTransmitterType"(): $TransmitterType
public "getComputerName"(): string
public "isComputerCapabilityPersistent"(): boolean
public "hasComputerSupport"(): boolean
public "getComputerMethods"(holder: $BoundMethodHolder$Type): void
get "transmitterType"(): $TransmitterType
get "computerName"(): string
get "computerCapabilityPersistent"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityDiversionTransporter$Type = ($TileEntityDiversionTransporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityDiversionTransporter_ = $TileEntityDiversionTransporter$Type;
}}
declare module "packages/mekanism/common/tile/transmitter/$TileEntityLogisticalTransporterBase" {
import {$TransmitterModelData, $TransmitterModelData$Type} from "packages/mekanism/client/model/data/$TransmitterModelData"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ConnectionType, $ConnectionType$Type} from "packages/mekanism/common/lib/transmitter/$ConnectionType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$TileEntityTransmitter, $TileEntityTransmitter$Type} from "packages/mekanism/common/tile/transmitter/$TileEntityTransmitter"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$ModelProperty, $ModelProperty$Type} from "packages/net/minecraftforge/client/model/data/$ModelProperty"

export class $TileEntityLogisticalTransporterBase extends $TileEntityTransmitter {
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
 "blockState": $BlockState


public static "tickClient"(level: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, transmitter: $TileEntityLogisticalTransporterBase$Type): void
public "blockRemoved"(): void
public "onUpdateServer"(): void
public "sideChanged"(side: $Direction$Type, old: $ConnectionType$Type, type: $ConnectionType$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityLogisticalTransporterBase$Type = ($TileEntityLogisticalTransporterBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityLogisticalTransporterBase_ = $TileEntityLogisticalTransporterBase$Type;
}}
declare module "packages/mekanism/common/recipe/serializer/$FluidToFluidRecipeSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$FluidToFluidRecipeSerializer$IFactory, $FluidToFluidRecipeSerializer$IFactory$Type} from "packages/mekanism/common/recipe/serializer/$FluidToFluidRecipeSerializer$IFactory"
import {$FluidToFluidRecipe, $FluidToFluidRecipe$Type} from "packages/mekanism/api/recipes/$FluidToFluidRecipe"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $FluidToFluidRecipeSerializer<RECIPE extends $FluidToFluidRecipe> implements $RecipeSerializer<(RECIPE)> {

constructor(factory: $FluidToFluidRecipeSerializer$IFactory$Type<(RECIPE)>)

public "fromJson"(recipeId: $ResourceLocation$Type, json: $JsonObject$Type): RECIPE
public "fromNetwork"(recipeId: $ResourceLocation$Type, buffer: $FriendlyByteBuf$Type): RECIPE
public "toNetwork"(buffer: $FriendlyByteBuf$Type, recipe: RECIPE): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidToFluidRecipeSerializer$Type<RECIPE> = ($FluidToFluidRecipeSerializer<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidToFluidRecipeSerializer_<RECIPE> = $FluidToFluidRecipeSerializer$Type<(RECIPE)>;
}}
declare module "packages/mekanism/common/content/blocktype/$FactoryType" {
import {$IHasTranslationKey, $IHasTranslationKey$Type} from "packages/mekanism/api/text/$IHasTranslationKey"
import {$BlockRegistryObject, $BlockRegistryObject$Type} from "packages/mekanism/common/registration/impl/$BlockRegistryObject"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Machine$FactoryMachine, $Machine$FactoryMachine$Type} from "packages/mekanism/common/content/blocktype/$Machine$FactoryMachine"

export class $FactoryType extends $Enum<($FactoryType)> implements $IHasTranslationKey {
static readonly "SMELTING": $FactoryType
static readonly "ENRICHING": $FactoryType
static readonly "CRUSHING": $FactoryType
static readonly "COMPRESSING": $FactoryType
static readonly "COMBINING": $FactoryType
static readonly "PURIFYING": $FactoryType
static readonly "INJECTING": $FactoryType
static readonly "INFUSING": $FactoryType
static readonly "SAWING": $FactoryType


public static "values"(): ($FactoryType)[]
public static "valueOf"(name: string): $FactoryType
public "getTranslationKey"(): string
public "getBaseBlock"(): $BlockRegistryObject<(any), (any)>
public "getRegistryNameComponentCapitalized"(): string
public "getBaseMachine"(): $Machine$FactoryMachine<(any)>
public "getRegistryNameComponent"(): string
get "translationKey"(): string
get "baseBlock"(): $BlockRegistryObject<(any), (any)>
get "registryNameComponentCapitalized"(): string
get "baseMachine"(): $Machine$FactoryMachine<(any)>
get "registryNameComponent"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryType$Type = (("crushing") | ("purifying") | ("sawing") | ("enriching") | ("compressing") | ("combining") | ("injecting") | ("infusing") | ("smelting")) | ($FactoryType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FactoryType_ = $FactoryType$Type;
}}
declare module "packages/mekanism/common/item/block/machine/$ItemBlockQIOComponent$ItemBlockQIOInventoryComponent" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$ListTag, $ListTag$Type} from "packages/net/minecraft/nbt/$ListTag"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockTile, $BlockTile$Type} from "packages/mekanism/common/block/prefab/$BlockTile"
import {$IItemSustainedInventory, $IItemSustainedInventory$Type} from "packages/mekanism/common/item/interfaces/$IItemSustainedInventory"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemBlockQIOComponent, $ItemBlockQIOComponent$Type} from "packages/mekanism/common/item/block/machine/$ItemBlockQIOComponent"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$IInventorySlot, $IInventorySlot$Type} from "packages/mekanism/api/inventory/$IInventorySlot"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBlockQIOComponent$ItemBlockQIOInventoryComponent extends $ItemBlockQIOComponent implements $IItemSustainedInventory {
static readonly "BLOCK_ENTITY_TAG": string
static readonly "BLOCK_STATE_TAG": string
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "BASE_ATTACK_SPEED_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer

constructor(block: $BlockTile$Type<(any), (any)>)

public "getSustainedInventory"(stack: $ItemStack$Type): $ListTag
public "getSustainedInventory"(): $ListTag
public "setSustainedInventory"(nbtTags: $ListTag$Type): void
public "setSustainedInventory"(nbtTags: $ListTag$Type, stack: $ItemStack$Type): void
public "getDroppedSlots"(stack: $ItemStack$Type): $List<($IInventorySlot)>
public "hasSustainedInventory"(stack: $ItemStack$Type): boolean
public "hasSustainedInventory"(): boolean
public "canContentsDrop"(stack: $ItemStack$Type): boolean
get "sustainedInventory"(): $ListTag
set "sustainedInventory"(value: $ListTag$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockQIOComponent$ItemBlockQIOInventoryComponent$Type = ($ItemBlockQIOComponent$ItemBlockQIOInventoryComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockQIOComponent$ItemBlockQIOInventoryComponent_ = $ItemBlockQIOComponent$ItemBlockQIOInventoryComponent$Type;
}}
declare module "packages/mekanism/common/content/qio/$QIOCraftingTransferHelper$HashedItemSource" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$List, $List$Type} from "packages/java/util/$List"
import {$QIOCraftingTransferHelper$SingularHashedItemSource, $QIOCraftingTransferHelper$SingularHashedItemSource$Type} from "packages/mekanism/common/content/qio/$QIOCraftingTransferHelper$SingularHashedItemSource"

export class $QIOCraftingTransferHelper$HashedItemSource {

constructor()

public "use"(toUse: integer): $List<($QIOCraftingTransferHelper$SingularHashedItemSource)>
public "getAvailable"(): long
public "hasMoreRemaining"(): boolean
public "matchFound"(): void
public "getQIORemaining"(uuid: $UUID$Type): long
public "getSlotRemaining"(slot: byte): integer
public "hasQIOSources"(): boolean
get "available"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOCraftingTransferHelper$HashedItemSource$Type = ($QIOCraftingTransferHelper$HashedItemSource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOCraftingTransferHelper$HashedItemSource_ = $QIOCraftingTransferHelper$HashedItemSource$Type;
}}
